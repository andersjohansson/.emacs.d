#+TITLE: Emacs org-mode config file
#+AUTHOR: Anders Johansson
#+PROPERTY: header-args :tangle yes :comments no :no-expand t
#+TODO: CHECK TODO | DONE

* Lexical-binding
#+begin_src emacs-lisp
;; -*- lexical-binding: t -*-
#+end_src

* Org-config

** Request, for some connections to zotero and reveal server below
#+begin_src emacs-lisp
(use-package request
  :commands request)
#+end_src

** Org-roam
#+begin_src emacs-lisp
;; these should be installed by emqcsql-sqlite-builtin...
(use-package emacsql-sqlite-builtin :demand t)

(use-package org-roam
  :defer 2
  :custom
  (org-roam-database-connector 'sqlite-builtin)
  (org-roam-directory "/home/aj/jobb/anteckningar")
  (org-roam-db-update-on-save nil)
  (org-roam-link-auto-replace nil) ;; have never had any "roam:" links
  (org-roam-node-display-template (concat "${title:*} " (propertize "${tags:40}" 'face 'org-tag)))
                                        ; I don’t like all the displayed # for tags, so let’s use a hidden “query language”
  (org-roam-node-template-prefixes
   `(("tags" . ,(propertize "#" 'display ""))))
  (org-roam-node-template-prefixes nil)
  (org-roam-buffer-postrender-functions '(visual-line-mode variable-pitch-mode))

  :bind (("C-c n l" . org-roam-buffer-toggle)
         ("C-c n f" . org-roam-node-find)
         ("C-c n g" . org-roam-graph)
         ("C-c n i" . org-roam-node-insert)
         ("C-c n c" . org-roam-capture)
         ;; Dailies, I don’t use it.
         ;; ("C-c n j" . org-roam-dailies-capture-today)
         )
  :config
  (org-roam-db-autosync-mode)

  ;; we know that the completions will be full frame-width, in
  ;; minibuffer (vertico), so patch this:
  (el-patch-defun org-roam-node-read--to-candidate (node template)
    "Return a minibuffer completion candidate given NODE.
TEMPLATE is the processed template used to format the entry."
    (let ((candidate-main (org-roam-node--format-entry
                           template
                           node
                           (1- (el-patch-swap (if (bufferp (current-buffer))
                                                  (window-width) (frame-width))
                                              (frame-width))))))
      (cons (propertize candidate-main 'node node) node)))

  (defun aj/org-roam-add-citar-ref ()
    "Add citekey as roam ref to current node."
    (interactive)
    (org-roam-ref-add (concat "@" (car (citar-select-ref)))))


  ;; add id if we are in roam-dir
  (org-link-set-parameters "id" :store #'aj/org-store-link-maybe-id)
  (defun aj/org-store-link-maybe-id ()
    (when (and (buffer-file-name)
               (file-in-directory-p (buffer-file-name) org-roam-directory))
      (org-id-get-create)
      (prog1 (org-id-store-link)
	    (setq desc (or (plist-get org-store-link-plist
						          :description)
					   ""))))))


(use-package org-roam-ui
  :straight
  (:host github :repo "org-roam/org-roam-ui" :files ("*.el" "out"))
  :after org-roam
  ;;         normally we'd recommend hooking orui after org-roam, but since org-roam does not have
  ;;         a hookable mode anymore, you're advised to pick something yourself
  ;;         if you don't care about startup time, use
  ;;  :hook (after-init . org-roam-ui-mode)
  :custom
  (org-roam-ui-sync-theme t)
  ;; (org-roam-ui-follow t)
  (org-roam-ui-update-on-save t)
  ;; (org-roam-ui-open-on-start t)
  )

(use-package org-roam-timestamps
  :after org-roam
  :custom
  (org-roam-timestamps-remember-timestamps t)
  (org-roam-timestamps-timestamp-parent-file nil)
  :init
  (org-roam-timestamps-mode)
  :config
  (defun aj/org-roam-timestamps-cleanup ()
    "Remove erronous mtime/ctime properties from buffer."
    (interactive)
    (org-map-entries
     (lambda ()
       (let* ((org-trust-scanner-tags t)
              (props (org-entry-properties (point))))
         (unless (assoc "ID" props)
           (when (assoc "MTIME" props)
             (org-entry-delete (point) "MTIME"))
           (when (assoc "CTIME" props)
             (org-entry-delete (point) "CTIME"))))))))
#+end_src
** [[https://github.com/nullman/emacs-org-visibility][org-visibility]]                                                  :ARCHIVE:
Automatically save and restore previous visibility, very useful.
#+begin_src emacs-lisp
(use-package org-visibility
  :after (org)
  :hook (org-mode . org-visibility-mode)
  :custom
  ;; no need for doing other folding work:
  (org-startup-folder 'showeverything)
  ;; all org files
  (org-visibility-include-regexps '("\\.org\\'"))
  (org-visibility-state-file (no-littering-expand-var-file-name "org-visibility")))
#+end_src
** Transclusion
#+begin_src emacs-lisp
(use-package org-transclusion
  :straight (:host github :repo "nobiot/org-transclusion")
  :defer t
  :config
  (add-to-list 'org-transclusion-extensions 'org-transclusion-indent-mode)
  (require 'org-transclusion-indent-mode))
#+end_src

** MobileOrg
#+begin_src emacs-lisp
(setq org-mobile-files (list org-directory)
      org-mobile-files-exclude-regexp "inbox"
      org-mobile-inbox-for-pull "~/org/inbox.org"
      org-mobile-directory "~/Dropbox/Apps/MobileOrg")
#+end_src
** Save org-files every hour
#+begin_src emacs-lisp
;; (run-at-time "00:59" 3600 'org-save-all-org-buffers)
#+end_src
** org-attach
#+begin_src emacs-lisp
(setq org-attach-id-to-path-function-list '(aj/org-attach-id-ts-folder-format))

(defun aj/org-attach-id-ts-folder-format (id)
  "Translate an ID based on a timestamp to a folder-path.
Avoid colons for syncing to windows systems (onedrive)"
  (string-replace ":" "-" id))
#+end_src

** Cosmetics, early definitions

*** [[https://github.com/minad/org-modern][org-modern]]
#+begin_src emacs-lisp
(use-package org-modern
  :demand t
  :config (global-org-modern-mode)
  :custom
  ;; otherwise windows with different font sizes will mess it up for each other:
  (org-modern-label-border 3)
  (org-modern-hide-stars nil)
  (org-modern-star '["❖"])
  (org-modern-table nil)
  ;; (org-modern-table-vertical 1)
  (org-modern-block-name '(("quote" . ("🙶" "🙷"))
                           (t . t)))
  ;; doesn’t work with org-indent:
  (org-modern-block-fringe nil))
#+end_src

*** [[https://github.com/integral-dw/org-superstar-mode/][org-superstar]] (successor to org-bullets) :ARCHIVE:
#+begin_src emacs-lisp
(use-package org-superstar
  :demand t
  :hook (org-mode . org-superstar-mode)
  :custom
  (org-superstar-headline-bullets-list '(?♦))
  (org-superstar-special-todo-items t)
  (org-superstar-todo-bullet-alist
   '(("AVFÖRD" . ?☒)
     ("VÄNTAR" . ?◫)
     ("STARTAD" . ?◧)
     ("DONE" . ?☑)
     ("TODO" . ?☐)
     (default . ?▣)))
  ;; (org-superstar-todo-bullet-alist '((default . ? )))
  (org-superstar-prettify-item-bullets nil)
  ;; when I would like to use plain bullets from time to time:
  (org-superstar-item-bullet-alist '((?- . ?•) (?+ . ?‣))))
#+end_src

*** Prettify-symbols replacements :ARCHIVE:
**** Use prettify-symbols
Define a variable where symbols can be added for use later and enable prettify-symbols-mode for org
#+begin_src emacs-lisp
(defvar aj/org-prettify-symbols nil)

(defun aj/org-enable-prettify ()
  (setq prettify-symbols-alist aj/org-prettify-symbols)
  (prettify-symbols-mode))

(add-hook 'org-mode-hook #'aj/org-enable-prettify)

;; helper macro to replace with longer string
;;from: https://emacs.stackexchange.com/a/34882
(defmacro aj/add-visual-replacement (from to alist)
  "Make `prettify-symbols-mode' replace string FROM with string TO.
Add this to ALIST that is like ‘prettify-symbols-alist’.

Each character of TO is vertically aligned using the baseline,
such that base-left of the character is aligned with base-right
of the preceding character.  Refer to `reference-point-alist'
for more information."
  `(push (cons ,from (let ((composition nil))
                       (dolist (char (string-to-list ,to)
                                     (nreverse (cdr composition)))
                         (push char composition)
                         (push '(Br . Bl) composition))))
         ,alist))
#+end_src

**** Prettify dashes
#+begin_src emacs-lisp
(dolist (kw '(("--" . ?–)
              ("---" . ?—)))
  (add-to-list 'aj/org-prettify-symbols kw))
#+end_src


*** Use org-indent, with some customization

**** Activate org-indent late
activate org-indent late so that it happens after we have variable-pitch etc. (org-startup-indented is nil).
Add it to ~org-modern-mode-hook~, so that customization below works. When using ~global-org-modern-mode~, the activation seems to be done after normal mode hooks, so we need this even later than ~org-mode-hook.~
#+begin_src emacs-lisp
;; (add-hook 'org-mode-hook #'org-indent-mode 50)
(add-hook 'org-modern-mode-hook #'org-indent-mode)
#+end_src

**** Match org-indent character widths perfectly
Redefine ~org-indent--compute-prefixes~ for better alignment in ~variable-pitch-mode~
See discussion here: https://lists.gnu.org/archive/html/emacs-orgmode/2019-01/msg00235.html

With my use of org-modern, the last star is replaced by a symbol (S), so making ~org-indent--text-line-prefixes~, lines like =*****S =, will make sure it aligns perfectly.
#+begin_src emacs-lisp
(el-patch-feature org-indent)
(with-eval-after-load 'org-indent
  (el-patch-defun org-indent--compute-prefixes ()
    "Compute prefix strings for regular text and headlines."
    (setq org-indent--heading-line-prefixes
	      (make-vector org-indent--deepest-level nil))
    (setq org-indent--inlinetask-line-prefixes
	      (make-vector org-indent--deepest-level nil))
    (setq org-indent--text-line-prefixes
	      (make-vector org-indent--deepest-level nil))
    (when (> org-indent-indentation-per-level 0)
      (dotimes (n org-indent--deepest-level)
        (let ((indentation (if (<= n 1) 0
			                 (* (1- org-indent-indentation-per-level)
			                    (1- n)))))
          ;; Headlines line prefixes.
          (let ((heading-prefix (make-string indentation ?*)))
	        (aset org-indent--heading-line-prefixes
	              n
	              (org-add-props heading-prefix nil 'face 'org-indent))
	        ;; Inline tasks line prefixes
	        (aset org-indent--inlinetask-line-prefixes
	              n
	              (cond ((<= n 1) "")
		                ((bound-and-true-p org-inlinetask-show-first-star)
		                 (concat org-indent-inlinetask-first-star
			                     (substring heading-prefix 1)))
		                (t (org-add-props heading-prefix nil 'face 'org-indent)))))
          ;; Text line prefixes.
          (aset org-indent--text-line-prefixes
	            n
	            (org-add-props
                    (el-patch-swap
                      (concat (make-string (+ n indentation) ?\s)
			                  (and (> n 0)
			                       (char-to-string org-indent-boundary-char)))
                      (if (> n 0)
                          (concat
                           (make-string (+ n indentation -1) ?*)
                           (aref org-modern--star-cache
                                 (min (1- (length org-modern--star-cache)) n))
                           (char-to-string org-indent-boundary-char))
                        ""))
		            nil 'face 'org-indent)))))))
#+end_src

*** Do org-indent indentation with display spaces :ARCHIVE:
With a special "thin" space for org-indent, we can have lines with low line-height (creating lines) even when we have indent. But the indent then has to be set with a space ~:align-to~ property. For this we do some patching of the org-indent machinery

Commented code for also indenting quote-blocks

#+begin_src emacs-lisp

(defface aj/org-quote-beg-end-face `((t . (:height 0.1 :foreground "#f0e0d4" :background "#f0e0d4" :extend t)))
  "Face for begin and end line of org quotes"
  :group 'aj)

(add-hook 'org-font-lock-set-keywords-hook #'aj/org-prettify-blockquotes)
(defun aj/org-prettify-blockquotes ()
  (setq org-font-lock-extra-keywords
        (append
         org-font-lock-extra-keywords
         '(( "#\\+\\(begin\\|end\\)_quote\n" . (0 'aj/org-quote-beg-end-face t))))))

(with-eval-after-load 'org-indent
  (defface aj/org-indent-thin '((t . (:inherit org-indent :height 0.1)))
    "Thin org-indent"
    :group 'aj)

  (defvar-local aj/org-indent--heading-wrap-prefixes nil)
  (defvar-local aj/org-indent--text-wrap-prefixes nil)
  (defvar-local aj/org-indent--inlinetask-wrap-prefixes nil)

  (advice-add 'org-indent--compute-prefixes :override #'aj/org-indent--compute-prefixes)

  ;; (defun aj/org-indent--compute-prefixes ()
  ;;   "Compute prefix strings for regular text and headlines."
  ;;   (setq org-indent--heading-line-prefixes
  ;;         (make-vector org-indent--deepest-level nil))
  ;;   (setq aj/org-indent--heading-wrap-prefixes
  ;;         (make-vector org-indent--deepest-level nil))
  ;;   (setq org-indent--inlinetask-line-prefixes
  ;;         (make-vector org-indent--deepest-level nil))
  ;;   (setq org-indent--text-line-prefixes
  ;;         (make-vector org-indent--deepest-level nil))
  ;;   (dotimes (n org-indent--deepest-level)
  ;;     (let* ((indentation (if (<= n 1) 0
  ;;   		                (* (1- org-indent-indentation-per-level)
  ;;   		                   (1- n))))
  ;;            (headerstring (if (< 0 n)
  ;;                              (concat
  ;;                               (make-string (+ n indentation -1) ?*)
  ;;                               (char-to-string (car org-superstar-headline-bullets-list))
  ;;                               (char-to-string org-indent-boundary-char))
  ;;                            "")))
  ;;       ;; Headlines line prefixes.
  ;;       (aset org-indent--heading-line-prefixes
  ;;             n
  ;;             (propertize (make-string indentation ?*) 'face 'org-indent))
  ;;       ;; and wrap prefixes
  ;;       (aset aj/org-indent--heading-wrap-prefixes
  ;;             n
  ;;             (propertize (concat headerstring "   ") 'face 'org-indent))
  ;;       ;; Inline tasks line prefixes (no indent needed I think)
  ;;       (aset org-indent--inlinetask-line-prefixes n "")
  ;;       ;; Text line prefixes.
  ;;       (aset org-indent--text-line-prefixes
  ;;             n
  ;;             (if (> n 0)
  ;;                 (aj/org-make-indent-string headerstring)
  ;;               ""))
  ;;       )))

  (defun aj/org-indent--compute-prefixes ()
    "Compute prefix strings for regular text and headlines."
    (setq org-indent--heading-line-prefixes
	      (make-vector org-indent--deepest-level nil))
    (setq aj/org-indent--heading-wrap-prefixes
	      (make-vector org-indent--deepest-level nil))
    (setq org-indent--inlinetask-line-prefixes
	      (make-vector org-indent--deepest-level nil))
    (setq aj/org-indent--inlinetask-wrap-prefixes
	      (make-vector org-indent--deepest-level nil))
    (setq org-indent--text-line-prefixes
	      (make-vector org-indent--deepest-level nil))
    (setq aj/org-indent--text-wrap-prefixes
          (make-vector org-indent--deepest-level nil))
    (let* ((pbuf (aj/string-pixel-width-setup-buf))
           (spacewidth (aj/string-pixel-width-line pbuf " ")))
      (dotimes (n org-indent--deepest-level)
        (let* ((indentation (if (<= n 1) 0
			                  (* (1- org-indent-indentation-per-level)
			                     (1- n))))
               (headerstring (if (< 0 n)
                                 (concat
                                  (make-string (+ n indentation -1) ?*)
                                  (seq-first org-modern-star)
                                  ;; (char-to-string (car org-superstar-headline-bullets-list))
                                  (char-to-string org-indent-boundary-char))
                               ""))
               (headerstringwidth (aj/string-pixel-width-line pbuf headerstring)))
          ;; Headlines line prefixes.
          (aset org-indent--heading-line-prefixes
                n
                (propertize (make-string indentation ?*) 'face 'org-indent))
          ;; and wrap prefixes
          (aset aj/org-indent--heading-wrap-prefixes
                n
                (propertize (concat headerstring "   ") 'face 'org-indent))
	      ;; Inline tasks line prefixes (no indent needed I think)
	      (aset org-indent--inlinetask-line-prefixes n "")
          (aset aj/org-indent--inlinetask-wrap-prefixes n
                (if (<= org-inlinetask-min-level n)
                    (aj/org-make-indent-string
                     (concat (make-string (- n 2) ?*)
                             (make-string 2 (string-to-char (seq-first org-modern-star)))
                             " ")
                     nil pbuf)
                  ""))
          ;; Text line prefixes.
          (aset org-indent--text-line-prefixes
	            n
                (if (> n 0)
                    (aj/org-make-indent-string headerstring headerstringwidth)
                  ""))
          ;; Indent can be up to 100 here...
          (aset aj/org-indent--text-wrap-prefixes n (make-vector 100 nil))
          (dotimes (j 100)
            (aset (aref aj/org-indent--text-wrap-prefixes n)
                  j
                  (aj/org-make-indent-string
                   (concat headerstring (make-string j ?\s))
                   (+ headerstringwidth (* j spacewidth)))))))
      (kill-buffer pbuf)))

  (defun aj/string-pixel-width-setup-buf (&optional mode)
    (let ((fra face-remapping-alist)
          (pbuf (generate-new-buffer " *aj-string-pixel-width*")))
      (with-current-buffer pbuf
        (when (fboundp mode)
          (funcall mode)
          (font-lock-ensure))
        (setq-local face-remapping-alist fra))
      pbuf))

  (defun aj/string-pixel-width-line (pbuf string)
    (with-current-buffer pbuf
      (with-silent-modifications
        (setf (buffer-string) string))
      (if (get-buffer-window (current-buffer))
	      (car (window-text-pixel-size nil (line-beginning-position) (point)))
        (set-window-buffer nil (current-buffer))
        (car (window-text-pixel-size nil (line-beginning-position) (point))))))

  (defun aj/org-make-indent-string (string &optional width pbuf)
    (propertize
     string
     'display `(space :width ,(list (or width (aj/string-pixel-width-line pbuf string))))
     'face 'aj/org-indent-thin))


  ;; if we have different text-scale in main and indirect buffer, the
  ;; indentation will be off in one of them

  (add-hook 'text-scale-mode-hook #'aj/org-indent-recalculate)

  (defun aj/org-indent-recalculate ()
    (when (derived-mode-p 'org-mode)
      (org-indent--compute-prefixes)
      (org-indent-refresh-maybe (point-min) (point-max) t)))

  (defun aj/org-indent-recalculate-all-org-buffers ()
    (cl-loop for buf being the buffers do
             (with-current-buffer buf
               (aj/org-indent-recalculate))))

  (add-hook 'aj/cycle-font-size-hook #'aj/org-indent-recalculate-all-org-buffers)

  (advice-add 'org-indent-set-line-properties :override #'aj/org-indent-set-line-properties)
  (defun aj/org-indent-set-line-properties (level indentation &optional heading)
    "Set prefix properties on current line and move to next one.

LEVEL is the current level of heading.  INDENTATION is the
expected indentation when wrapping line.

When optional argument HEADING is non-nil, assume line is at
a heading.  Moreover, if it is `inlinetask', the first star will
have `org-warning' face."
    (let* ((line (aref (pcase heading
		                 (`nil org-indent--text-line-prefixes)
		                 (`inlinetask org-indent--inlinetask-line-prefixes)
		                 (_ org-indent--heading-line-prefixes))
		               level))
	       (wrap
            (pcase heading
              (`nil
               (aref
                (aref aj/org-indent--text-wrap-prefixes level)
                (if (eq 0 indentation) 0 (min (1+ indentation) 20))))
              (`inlinetask (aref aj/org-indent--inlinetask-wrap-prefixes level))
              (_ (aref aj/org-indent--heading-wrap-prefixes level)))))
      ;; Add properties down to the next line to indent empty lines.
      (add-text-properties (line-beginning-position) (line-beginning-position 2)
			               `(line-prefix ,line wrap-prefix ,wrap)))
    (forward-line))


  ;; THIS IS FOR SPECIAL org-quote INDENT.
  ;; (advice-add 'org-indent-add-properties :override #'aj/org-indent-add-properties)

  ;;   (defun aj/org-indent-add-properties (beg end &optional delay)
  ;;     "Add indentation properties between BEG and END.

  ;; When DELAY is non-nil, it must be a time value.  In that case,
  ;; the process is asynchronous and can be interrupted, either by
  ;; user request, or after DELAY.  This is done by throwing the
  ;; `interrupt' tag along with the buffer position where the process
  ;; stopped."
  ;;     (save-match-data
  ;;       (org-with-wide-buffer
  ;;        (goto-char beg)
  ;;        (beginning-of-line)
  ;;        ;; Initialize prefix at BEG, according to current entry's level.
  ;;        (let* ((case-fold-search t)
  ;; 	          (limited-re (org-get-limited-outline-regexp))
  ;; 	          (level (or (org-current-level) 0))
  ;; 	          (time-limit (and delay (org-time-add nil delay))))
  ;;          ;; For each line, set `line-prefix' and `wrap-prefix'
  ;;          ;; properties depending on the type of line (headline, inline
  ;;          ;; task, item or other).
  ;;          (with-silent-modifications
  ;; 	       (while (and (<= (point) end) (not (eobp)))
  ;; 	         (cond
  ;; 	          ;; When in asynchronous mode, check if interrupt is
  ;; 	          ;; required.
  ;; 	          ((and delay (input-pending-p)) (throw 'interrupt (point)))
  ;; 	          ;; In asynchronous mode, take a break of
  ;; 	          ;; `org-indent-agent-resume-delay' every DELAY to avoid
  ;; 	          ;; blocking any other idle timer or process output.
  ;; 	          ((and delay (org-time-less-p time-limit nil))
  ;; 	           (setq org-indent-agent-resume-timer
  ;; 		             (run-with-idle-timer
  ;; 		              (time-add (current-idle-time) org-indent-agent-resume-delay)
  ;; 		              nil #'org-indent-initialize-agent))
  ;; 	           (throw 'interrupt (point)))
  ;; 	          ;; Headline or inline task.
  ;; 	          ((looking-at org-outline-regexp)
  ;; 	           (let* ((nstars (- (match-end 0) (match-beginning 0) 1))
  ;; 		              (type (or (looking-at-p limited-re) 'inlinetask)))
  ;; 	             (org-indent-set-line-properties nstars 0 type)
  ;; 	             ;; At an headline, define new value for LEVEL.
  ;; 	             (unless (eq type 'inlinetask) (setq level nstars))))
  ;;               ;; indent quotes
  ;;               ((org-in-block-p '("quote"))
  ;;                (if (org-at-item-p)
  ;; 	               (org-indent-set-line-properties
  ;; 	                (1+ level)
  ;;                     (length (match-string 0)))
  ;;                  (org-indent-set-line-properties
  ;;                   (+ 1 level)
  ;;                   (current-indentation))))
  ;; 	          ;; List item: `wrap-prefix' is set where body starts.
  ;; 	          ((org-at-item-p)
  ;; 	           (org-indent-set-line-properties
  ;; 	            level
  ;;                 (length (match-string 0))))
  ;; 	          ;; Regular line.
  ;; 	          (t
  ;; 	           (org-indent-set-line-properties
  ;; 	            level
  ;; 	            (current-indentation)
  ;; 	            ;; When adapt indentation is 'headline-data, use
  ;; 	            ;; `org-indent--heading-line-prefixes' for setting
  ;; 	            ;; headline data indentation.
  ;; 	            (and (eq org-adapt-indentation 'headline-data)
  ;; 		             (or (org-at-planning-p)
  ;; 		                 (org-at-clock-log-p)
  ;; 		                 (looking-at-p org-property-start-re)
  ;; 		                 (looking-at-p org-property-end-re)
  ;; 		                 (looking-at-p org-property-re))))))))))))


  )
#+end_src


** Don’t activate mouse-behaviour for tags (I often just accidentally click them)
#+begin_src emacs-lisp
(defun aj/org-activate-tags (limit)
  (when (re-search-forward org-tag-line-re limit t)
    (org-remove-flyspell-overlays-in (match-beginning 1) (match-end 1))
    ;; (add-text-properties (match-beginning 1) (match-end 1)
	;; 		             (list 'mouse-face 'highlight
	;; 		                   'keymap org-mouse-map))
    (org-rear-nonsticky-at (match-end 1))
    t))

(advice-add 'org-activate-tags :override #'aj/org-activate-tags)
#+end_src

** Remove duplicates when setting tags
#+begin_src emacs-lisp
(advice-add 'org-set-tags :filter-args #'aj/org-remove-duplicate-tags)

(defun aj/org-remove-duplicate-tags (tags)
  (let ((tags (pcase tags
		        ((pred listp) tags)
		        ((pred stringp) (split-string (org-trim tags) ":" t))
		        (_ (error "Invalid tag specification: %S" tags)))))
    (cl-remove-duplicates tags :test #'equal)))
#+end_src
** Sort tags
#+begin_src emacs-lisp
(setq org-tags-sort-function #'aj/org-tag-sort-lessp)

(defun aj/org-tag-sort-lessp (a b)
  "Return non-nil if S1 is less than S2 in collation order.
Sort symbols _@#% first, ignore case and collate depending on current locale."
  (let* ((fa (string-to-char a))
         (fb (string-to-char b))
         ;; the possibly allowed symbols all have charcode less than
         ;; 65, letters from 65 and up
         (fas (< fa 65))
         (fbs (< fb 65)))
    (cond
     ((and fas (not fbs)) t)
     ((and fbs (not fas)) nil)
     ((and fas fbs (not (= fa fb))) (< fa fb))
     (t (string-collate-lessp a b nil t)))))

(with-eval-after-load 'orgqda
  (add-to-list 'orgqda-sort-parameters
               '(symbols-first (:description . "Sort symbols first")
                               (:compare . aj/org-tag-sort-lessp)))
  (setq orgqda-keep-tags-sorted 'symbols-first))
#+end_src

** Keybindings and templates
*** Special C-a, C-e
#+begin_src emacs-lisp
(setq org-special-ctrl-a/e t)

;; both org and visual-line-mode remaps ‘move-beginning/end-of-line’
;; and visual-line-modes binding takes precedence. Binding C-a and C-e
;; explicitly in ‘org-mode-map’ overrides this.
(bind-keys :map org-mode-map
           ("C-a" . org-beginning-of-line)
           ("C-e" . org-end-of-line))
#+end_src

*** Disable some disturbing keybindings
Disable keys for org-cycle-agenda-files, org-agenda-file-to-front etc.
I never use this.
#+begin_src emacs-lisp
(define-key org-mode-map [(control ?,)] nil)
(define-key org-mode-map [(control ?\')] nil)
(define-key org-mode-map "\C-c[" nil)
(define-key org-mode-map "\C-c]" nil)
#+end_src

*** Speed commands at more places
#+begin_src emacs-lisp
(defun aj/org-speed-command-here-p ()
  (and (looking-at org-outline-regexp) (looking-back "^\**" (point-at-bol))))

(setq org-use-speed-commands
      #'aj/org-speed-command-here-p)
#+end_src

*** Speed command for "DONE"
#+begin_src emacs-lisp
(add-to-list 'org-speed-commands
             '("T" . aj/org-done))

(defun aj/org-done ()
  (interactive)
  (org-todo 'done))
#+end_src

*** Speed command for adding property
#+begin_src emacs-lisp
(add-to-list 'org-speed-commands '("P" . org-set-property))
#+end_src

*** Add extra wrappers for smartparens
By default, ~smartparens-org~ defines wrappers for all the emphasize characters except ~+~.
#+begin_src emacs-lisp
(with-eval-after-load 'smartparens-org
  (sp-local-pair 'org-mode "\\(" "\\)" :trigger "$$")
  ;; (sp-local-pair 'org-mode  "+" "+" :unless
  ;;                '(sp-point-after-word-p) :post-handlers '(("[d1]" "SPC")))
  )
#+end_src

*** Hydra for emphasize functions
An alternative to the smartparens solution. Really fast for example when marking up lots of words here and there in a text.
#+begin_src emacs-lisp
(defhydra hydra-org-emphasize (:color pink)
  "
Org emphasize: _b_old  _i_talic _u_nderline _c_ode _v_erbatim _s_trikethrough  _d_elete [_?_] _q_uit"
  ("b" (aj/org-toggle-emphasis "*") nil)
  ("i" (aj/org-toggle-emphasis "/") nil)
  ("u" (aj/org-toggle-emphasis "_") nil)
  ("c" (aj/org-toggle-emphasis "~") nil)
  ("v" (aj/org-toggle-emphasis "=") nil)
  ("s" (aj/org-toggle-emphasis "+") nil)
  ("*" (aj/org-toggle-emphasis "*") nil)
  ("/" (aj/org-toggle-emphasis "/") nil)
  ("_" (aj/org-toggle-emphasis "_") nil)
  ("~" (aj/org-toggle-emphasis "~") nil)
  ("=" (aj/org-toggle-emphasis "=") nil)
  ("+" (aj/org-toggle-emphasis "+") nil)
  ("d" (aj/org-toggle-emphasis "") nil)
  ("?" (org-info "Emphasis and monospace") nil)
  ("q" nil nil :exit t))

(bind-keys :map org-mode-map
           ("C-c u" . hydra-org-emphasize/body)
           ("C-c C-x C-f" . aj/org-toggle-emphasis))

(defun aj/org-toggle-emphasis (&optional wrap)
  (interactive)
  (let ((startpoint (point))
        (wrap (or wrap "/")))
    (if (org-region-active-p)
        (sp-wrap-with-pair wrap)
      (if (get-text-property startpoint 'org-emphasis)
          (let ((emph (plist-get (sp-get-enclosing-sexp) :op)))
            (if (equal emph wrap)
                (sp-unwrap-sexp)
              (sp-rewrap-sexp (cons wrap wrap))))
        (if (eolp)
            (progn (insert wrap wrap)
                   (backward-char))
          (save-excursion
            (backward-word)
            (mark-word)
            (sp-wrap-with-pair wrap)))))))
#+end_src

*** Insert org macro
#+begin_src emacs-lisp
(defun aj/org-insert-macro ()
  (interactive)
  (insert
   (format
    "{{{%s}}}"
    (completing-read "Macro: " (cl-loop for (m . _e) in org-macro-templates collect m)))))
#+end_src

*** CHECK Template inserting (hydra)
If before headline, insert options template with completion.

Otherwise hydra for template insertion.

#+begin_src emacs-lisp
(defvar aj/org-header-keywords-history nil)
(defun aj/org-insert-header-keyword ()
  (interactive)
  (insert "#+"
          (completing-read "Keyword: "
                           (append org-options-keywords
                                   (mapcar (lambda (x) (concat x ":")) (org-get-export-keywords)))
                           nil t nil
                           aj/org-header-keywords-history)
          " "))

(require 'org-tempo)
(setq org-structure-template-alist
      '(("a" . "export ascii")
        ("c" . "center")
        ("C" . "comment")
        ("e" . "src emacs-lisp")
        ("E" . "example")
        ("h" . "export html")
        ("l" . "export latex")
        ("n" . "notes")
        ("q" . "quote")
        ("s" . "src")
        ("v" . "verse")
        ("x" . "export")))

(defun aj/org-insert-attr (str)
  (insert "#+attr_" str ": "))

(eval `(defhydra aj/hydra-org-template (:hint t :color blue :columns 4)
         "Great stuff"
         ,@(cl-loop for (key . word) in org-tempo-keywords-alist collect
                    (list key `(aj/org-keyword-expand ,key) word))
         ("I" (aj/org-keyword-expand "I") "include")
         ("ö l" (aj/org-insert-attr "latex") "attr_latex")
         ("ö h" (aj/org-insert-attr "html") "attr_html")
         ("ö r" (aj/org-insert-attr "reveal") "attr_reveal")
         ("." (org-insert-structure-template (read-string "Block type: ")) "Custom block type")
         ,@(cl-loop for (key . word) in org-structure-template-alist collect
                    (list key `(org-insert-structure-template ,word) word))))

(autoload 'org-tempo-complete-tag "org-tempo")
(defun aj/org-keyword-expand (str)
  "Expand ‘org-tempo-keywords-alist’ template."
  (insert "<" str)
  (org-tempo-complete-tag))

(defun aj/org-template-completion ()
  (interactive)
  (if (or (region-active-p) (looking-back "^" (point-at-bol)))
      (if (org-before-first-heading-p)
          (aj/org-insert-header-keyword)
        (aj/hydra-org-template/body))
    (self-insert-command 1)))

(bind-key "<" #'aj/org-template-completion org-mode-map)
#+end_src

*** Extra bindings
#+begin_src emacs-lisp
(bind-keys :map org-mode-map
           ("C-c S-C-l" . org-store-link))
#+end_src

** Org-table-header-line-mode :ARCHIVE:
#+begin_src emacs-lisp
(setq org-table-header-line-p nil)

;; (el-patch-feature org-table)
;; (with-eval-after-load 'org-table
;;   (el-patch-defun org-table-header-set-header ()
;;     "Display the header of the table at point."
;;     (when (overlayp org-table-header-overlay)
;;       (delete-overlay org-table-header-overlay))
;;     (let* ((ws (window-start))
;; 	       (beg (save-excursion
;;                   (el-patch-add (goto-char ws))
;;                   (goto-char (org-table-begin))
;; 		          (while (or (org-at-table-hline-p)
;; 			                 (looking-at-p ".*|\\s-+<[rcl]?\\([0-9]+\\)?>"))
;; 		            (move-beginning-of-line 2))
;; 		          (point)))
;; 	       (end (save-excursion (goto-char beg) (point-at-eol))))
;;       (if (pos-visible-in-window-p beg)
;; 	      (when (overlayp org-table-header-overlay)
;; 	        (delete-overlay org-table-header-overlay))
;;         (setq org-table-header-overlay
;; 	          (make-overlay ws (+ ws (- end beg))))
;;         (org-overlay-display
;;          org-table-header-overlay
;;          (org-table-row-get-visible-string beg)
;;          'org-table-header)))))
#+end_src

** Agenda, todo, scheduling etc.
*** Todo stuff
**** Todo on chosen date
#+begin_src emacs-lisp
(defun aj/org-todo-choose-date (arg)
  "Call ‘org-todo’ with prompted date. ARG is passed on."
  (interactive "P")
  (cl-letf ((todofn (if (eq major-mode 'org-agenda-mode)
                        #'org-agenda-todo
                      #'org-todo))
            (org-use-last-clock-out-time-as-effective-time t)
            ((symbol-function #'org-clock-get-last-clock-out-time)
             (lambda () (org-read-date nil t nil "Todo at: "))))
    (apply todofn arg)))

#+end_src
**** Todo keywords, Todo states
Special faces for these states are also defined, but in [[file:~/.emacs.d/init.org::*My own face definitions][init.org]].
#+begin_src emacs-lisp
(setq org-todo-keywords '((sequence "TODO(t)" "STARTAD(s)" "VÄNTAR(v)" "DONE(d)")
                          (sequence "|" "AVFÖRD(a)")))

;; (dolist (kw '(("AVFÖRD" . " ☒")
;;               ("VÄNTAR" . " ◫")
;;               ("STARTAD" . " ◧")
;;               ("DONE" . " ☑")
;;               ("TODO" . " ☐")
;;               ;; ("AVFÖRD" . ?☒)
;;               ;; ("VÄNTAR" . ?◫)
;;               ;; ("STARTAD" . ?◧)
;;               ;; ("DONE" . ?☑)
;;               ;; ("TODO" . ?☐)
;;               ;; ("TODO" . ?!)
;;               ;; ("DONE" . ?✓)
;;               ;; ("STARTAD" . ?⇒)
;;               ;; ("VÄNTAR" . ?⇥)
;;               ;; ("AVFÖRD" . ?×)
;;               ))
;;   (add-to-list 'aj/org-prettify-symbols kw))
#+end_src

**** Todo tree
I often find it useful to copy in a tree from somewhere (for instance reviewer comments on a scientific paper) and make every heading a TODO. This makes it easy!
#+begin_src emacs-lisp
(defvar aj/org-todo-tree-maxlevel 100)

(defun aj/org-todo-tree (&optional arg)
  "Make TODO states of all nodes in current tree and add [/]
A numeric prefix ARG determines the depth where TODO states are created.
Two prefixes let’s you choose the state."
  (interactive "P")
  (let ((maxlevel
         (if (and arg (not (equal '(16) arg)))
             (+ (org-current-level) (prefix-numeric-value arg))
           100))
        (state (if (equal '(16) arg)
                   (completing-read "State: " org-todo-keywords-1 nil t)
                 (car org-todo-keywords-1))))
    (save-restriction
      (save-excursion
        (org-narrow-to-subtree)
        (goto-char (point-max))
        (while (outline-previous-heading)
          (aj/org-add-todo-and-cookie maxlevel state))))))

(defun aj/org-add-todo-and-cookie (maxlevel state)
  "Add TODO if not in a TODO state and a [/]-cookie if there are children"
  (let ((level (org-current-level)))
    (unless (or (> level maxlevel)
                (org-get-todo-state))
      (org-todo state))
    (when (and
           (not (>= level maxlevel))
           (not (re-search-forward
		         "\\(\\[[0-9]*%\\]\\|\\[[0-9]*/[0-9]*\\]\\)"
		         (point-at-eol) t))
           (save-excursion (org-goto-first-child)))
      (let ((org-special-ctrl-a/e t)
            (visual-line-mode nil))
        (org-end-of-line)
        (insert " [/]")
        (org-update-statistics-cookies nil)))
    (goto-char (point-at-bol))))
#+end_src
**** Hierarchical TODO automatization
If you would like a TODO entry to automatically change to DONE when
all children are done, you can use the following setup:
#+begin_src emacs-lisp
(defun aj/org-summary-todo (n-done n-not-done)
  "Switch entry to DONE when all subentries are done, to TODO otherwise."
  (let (org-log-done org-todo-log-states)   ; turn off logging
    (org-todo (cond
               ((= n-not-done 0) "DONE")
               ((and (member "VÄNTAR" org-not-done-keywords)
                     (aj/org-any-todo-state-below "VÄNTAR"))
                "VÄNTAR")
               ((and (member "STARTAD" org-not-done-keywords)
                     (or (and (< 0 n-done) (< 0 n-not-done))
                         (aj/org-any-todo-state-below "STARTAD")))
                "STARTAD")
               (t "TODO")))))

(add-hook 'org-after-todo-statistics-hook 'aj/org-summary-todo)

(defun aj/org-any-todo-state-below (state)
  "Checks if any of our children has the todo state STATE."
  (catch 'found
    (org-map-region
     (lambda ()
       (when (string= state (org-get-todo-state))
         (throw 'found t)))
     (1+ (point-at-eol))
     (save-excursion (progn (org-end-of-subtree) (point))))))
#+end_src

*** Agenda
**** Functions for sunrise and sunset
#+begin_src emacs-lisp
(require 'solar)

(setq calendar-location-name "GBG"
      calendar-latitude 57.7
      calendar-longitude 11.9
      calendar-time-display-form '(24-hours ":" minutes))

(defun aj/diary-sun-rise-set (&optional set?)
  "Local time of sunrise or SET? as a diary entry. But only for today."
  (with-no-warnings (defvar date)) ; hack for the dynamically bound date
  (when (equal date (calendar-current-date))
    (cl-destructuring-bind (rise set _dur) (solar-sunrise-sunset date)
      (apply #'solar-time-string (if set? set rise)))))
#+end_src

**** Extra keybindings for agenda
#+begin_src emacs-lisp
(with-eval-after-load 'org-agenda
  (bind-keys :map
             org-agenda-mode-map
             ;; I don’t use meaningless ‘org-agenda-toggle-diary’ anyway:
             ("D" . aj/org-agenda-todo-to-done)
             ("C-z" . org-agenda-undo))
  (defun aj/org-agenda-todo-to-done () (interactive) (org-agenda-todo 'done)))
#+end_src

**** Agenda configuration variables and general styling
#+begin_src emacs-lisp
(setq org-log-into-drawer t
      org-clock-into-drawer t
      org-columns-default-format-for-agenda
      "%40ITEM(Task) %TODO %8AGENDA_DURATION(Takes){:} %CATEGORY %TAGS %DEADLINE %SCHEDULED %PRIORITY"
      org-habit-show-habits-only-for-today t
      org-habit-graph-column 60
      ;; time grid with mostly whitespace:
      org-agenda-time-grid '((daily today require-timed)
                             (800 1000 1200 1300 1500 1700)
                             " " " ")
      org-agenda-current-time-string "───────────"

      ;; better alignment with variable-pitch (see below):
      org-agenda-time-leading-zero t

      org-agenda-columns-add-appointments-to-effort-sum t
      org-enforce-todo-dependencies t
      org-agenda-dim-blocked-tasks t
      ;; Don’t display deadlines too often
      org-agenda-skip-deadline-prewarning-if-scheduled t
      org-agenda-skip-deadline-if-done t
      ;; By default, I want a 10 day rolling agenda starting from today:
      org-agenda-span 10
      org-agenda-start-on-weekday nil
      org-agenda-start-day nil)


;; change agenda prefix format, add effort, wider categories,
;; Use variable-pitch and align with displayed spaces
(with-eval-after-load 'org-agenda
  (add-hook 'org-agenda-mode-hook #'variable-pitch-mode)
  (add-hook 'org-agenda-mode-hook #'aj/org-agenda-line-spacing)
  (defun aj/org-agenda-line-spacing ()
    (setq line-spacing 0.2))

  (setf (alist-get 'agenda org-agenda-prefix-format)
        (concat "  %-14c"
                (propertize " " 'display '(space :align-to 13))
                "%?-12t%"
                (propertize " " 'display '(space :align-to 26))
                "s%-4e"
                (propertize " " 'display '(space :align-to 32)))
        ;; " %i %-10c%?-12t% s%-4e"
        )

  (setq org-agenda-format-date #'aj/org-agenda-format-date)

  (defun aj/org-agenda-format-date (date)
    (let ((time (org-time-from-absolute date)))
      (concat
       (format-time-string "%A" time)
       (propertize " " 'display '(space :align-to 13))
       (format-time-string "%d %B" time)
       (propertize " " 'display '(space :align-to 25))
       )))


  (defun aj/org-agenda-habit-align-right (graph)
    (concat (propertize " " 'display '(space :align-to (- right 30)))
            graph))

  (advice-add 'org-habit-build-graph :filter-return #'aj/org-agenda-habit-align-right))

(defun aj/org-agenda-fix-faces (&rest _ignore)
  (with-eval-after-load 'org-habit
    (cl-loop for f in '(org-habit-alert-face
                        org-habit-alert-future-face
                        org-habit-clear-face
                        org-habit-clear-future-face
                        org-habit-overdue-face
                        org-habit-overdue-future-face
                        org-habit-ready-face
                        org-habit-ready-future-face)
             do
             (set-face-attribute f nil :inherit
                                 (append (let ((fa (face-attribute f :inherit nil nil)))
                                           (if (listp fa)
                                               fa
                                             (list fa)))
                                         '(fixed-pitch)))))
  ;; (with-eval-after-load 'org-faces
  ;;   (set-face-attribute 'org-agenda-date nil :overline "#CCCCCC")
  ;;   (set-face-attribute 'org-agenda-date-weekend nil :overline "#CCCCCC"))
  )



(aj/org-agenda-fix-faces)

(add-hook 'aj/face-definitions-hook #'aj/org-agenda-fix-faces)
#+end_src

**** Hl-line-mode in agenda
#+begin_src emacs-lisp
(add-hook 'org-agenda-mode-hook #'hl-line-mode)
#+end_src

**** Agenda custom commands
#+begin_src emacs-lisp
(setq org-agenda-custom-commands
      '(("n" "Agenda and all TODO's"
         ((agenda "")
          (alltodo "")))
        ("u" "Not scheduled or categorized" alltodo ""
         ((org-agenda-skip-function
           '(and
             ;; include those in the "osorterat" (unsorted) category
             (if (string= (org-get-category) "osorterat") nil (aj/org-return-next-hp))
             ;; If missing either sched, dead, or ts we should also
             ;; include it
             (or (org-agenda-skip-entry-if (quote scheduled) (quote deadline)
                                           (quote timestamp))
                 ;; also if subtasks are not scheduled
                 (aj/org-subscheduled))))
          (org-agenda-overriding-header "Osorterade eller ej schemalagda: ")))
        ("w" "Väntande" todo "VÄNTAR") ; waiting tasks
        ("j" "Bara jobb" agenda "" ((org-agenda-files aj/org-work-agenda-files)))
        ("d" "TODO in this dir" todo "" ((org-agenda-files (aj/org-files-in-project-dir))))
        ("W" "Weekly review"
         agenda ""
         ((org-agenda-start-day "-14d")
          (org-agenda-span 15)
          (org-agenda-time-grid nil)
          (org-agenda-start-on-weekday 1)
          (org-agenda-start-with-log-mode t)
          (org-agenda-skip-function '(org-agenda-skip-entry-if 'nottodo 'done))))))

(defun aj/org-files-in-project-dir ()
  (directory-files-recursively
   (or (locate-dominating-file default-directory ".git")
       default-directory)
   "\\.org$"))

(defun aj/org-return-next-hp (&optional same-level)
  "Return position of next heading, optionally on SAME-LEVEL."
  (save-excursion
	(if same-level
		(org-forward-heading-same-level 1 t)
	  (outline-next-heading))
	(1- (point))))

(defun aj/org-subscheduled ()
  "Skips trees with entire subtrees appropriately scheduled in some way."
  (let (subsc npos)
    (save-excursion
      (let ((level (org-current-level)))
        (org-get-heading t t)
        (while (and (setq npos (outline-next-heading)) (< level (org-current-level)))
          (push (and (org-agenda-skip-entry-if 'todo 'todo)
                     (org-agenda-skip-entry-if 'notscheduled)) subsc))))
    (if (and (not (null subsc)) (cl-every 'null subsc))
        ;; everything ok. skip to next heading of same level.
        (if (number-or-marker-p npos) (1- npos) (aj/org-return-next-hp))
      nil)))
#+end_src

**** Agenda categories icons :ARCHIVE:
I don’t use this now, can just put UTF-8, emojis and whatever in category names. Works well


I want to be able to use emojis \etc. But that doesn’t work with the way ~org-agenda-category-icon-alist~, hence the patch below.

#+begin_src emacs-lisp
(el-patch-feature org-agenda)
(with-eval-after-load 'org-agenda
  (el-patch-defun org-agenda-get-category-icon (category)
    "Return an image for CATEGORY according to `org-agenda-category-icon-alist'."
    (cl-dolist (entry org-agenda-category-icon-alist)
      (when (string-match-p (car entry) category)
        (el-patch-swap
          (if (listp (cadr entry))
	          (cl-return (cadr entry))
	        (cl-return (apply #'create-image (cdr entry))))
          (cond
           ((listp (cadr entry))
            (cl-return (cadr entry)))
           ((characterp (cadr entry))
            (cl-return (string (cadr entry))))
           (t
            (cl-return (apply #'create-image (cdr entry))))
           ))))))

(setq org-agenda-category-icon-alist
      '(("^C-.*" ?📅)))
#+end_src

**** External calendars
Currently I need to sync both with my work exchange server and some private google calendars.
***** Functions for syncing some or all external calendars
#+begin_src emacs-lisp
(use-package deferred
  :commands deferred:$)

(defun aj/org-cal-sync-maybe (probefile hours program &optional force)
  (let ((mtime (nth 5 (file-attributes probefile))))
    (when (or force (not mtime)
              (< (/ 24 hours) (time-to-number-of-days (time-subtract (current-time) mtime))))
      (deferred:process program))))

(defun aj/org-calendar-maybe-sync-all (&optional force)
  (interactive "P")
  (deferred:$
   (deferred:parallel
    (aj/org-cal-sync-maybe "~/org/imp/G.org" 8 "aj-gcal-to-org" force)
    (aj/org-cal-sync-maybe "~/org/imp/chalmerskalender.org" 3 "aj-sync-exchange-calendar" force))
   (deferred:nextc it
                   (lambda (args)
                     ;; (message "All synced!")
                     (when args (buffer-live-p org-agenda-buffer)
                           (with-current-buffer org-agenda-buffer
                             (org-agenda-redo t)))))))

(defun aj/org-calendar-sync-all ()
  (interactive)
  (aj/org-calendar-maybe-sync-all t))

;; no suitable hook, want to do it just after org-agenda-list,
;; org-agenda-finalize-hook happens too often.
(advice-add 'org-agenda-list :after #'aj/org-calendar-sync-all-ignore-args)
(defun aj/org-calendar-sync-all-ignore-args (&rest _ignore)
  (aj/org-calendar-maybe-sync-all))

(with-eval-after-load 'org-agenda
  (bind-key "å" #'aj/org-calendar-sync-all org-agenda-mode-map))
#+end_src

***** Syncing with org-caldav :ARCHIVE:
Settings for calendars kept in custom.el
#+begin_src emacs-lisp
(use-package org-caldav
  :straight (:host github :repo "dengste/org-caldav")
  :config
  (setq org-icalendar-timezone "Europe/Stockholm"))
#+end_src

***** Syncing google calendar
Downloads and converts ics-files from google calendar (where I keep my appointments) to org. My script ~gcal-to-org~ calls the conversion script from here on all my calendars: http://perlstalker.vuser.org/blog/2014/06/04/importing-ical-into-org-mode/

*** Refile, and agenda refile settings
I want to be able to refile to all other agenda files, excluding files imported from google calendar (under "imp/" subdirectory).
In addition, eligible trees should not include TODO entries without subtasks.
#+begin_src emacs-lisp
;; default targets: this file + agenda files
(setq org-refile-targets
      '((nil . (:maxlevel . 4))
        (aj/org-agenda-refile-targetfiles . (:maxlevel . 4))))

;; targets in agenda mode
(add-hook 'org-agenda-mode-hook #'aj/org-agenda-set-refile-targets)

(defun aj/org-agenda-set-refile-targets ()
  (setq-local org-refile-targets
              '((aj/org-agenda-refile-targetfiles . (:maxlevel . 4))))
  (setq-local org-refile-target-verify-function
              #'aj/org-entry-is-not-single-todo-done-p))

(defun aj/org-agenda-refile-targetfiles ()
  (cl-remove-if (apply-partially #'string-match "imp/")
                (org-agenda-files)))

(defun aj/org-entry-is-not-single-todo-done-p ()
  "Skips a heading which is in a TODO state but has no summary-cookie (or is DONE))"
  (let ((ts (org-get-todo-state)))
    (if (or (member ts org-done-keywords)
            (and (member ts org-todo-keywords-1)
                 (not (save-excursion
                        (search-forward-regexp
                         "\\[[0-9]+%\\]\\|\\[[0-9]+/[0-9]+\\]" (point-at-eol) t)))))
        (org-forward-heading-same-level 1 t) ;skip subtree and return nil
      t)))

(defun aj/org-entry-is-not-todo-done-p ()
  "Skips a heading with any TODO state."
  (if (member (org-get-todo-state) org-todo-keywords-1)
      (org-forward-heading-same-level 1 t) ;skip subtree and return nil
    t))

(put 'org-refile-target-verify-function 'safe-local-variable
     '(lambda (arg)
        (member arg '(aj/org-entry-is-not-todo-done-p
                      aj/org-entry-is-not-single-todo-done-p))))

#+end_src
**** Agenda evaluation :ARCHIVE:
#+begin_src emacs-lisp
(use-package aj-org-agendautv
  :load-path "~/kodat/elisp/org-weektree/"
  :commands (aj/org-agenda-weekplan-to-utv
             aj/org-agenda-morningplan aj/org-agenda-days-to-utv))
#+end_src
*** Times and clocking
**** Enable Swedish for parsing of names of weekdays and months
The date input prompt uses functionality from ~parse-time~. I want it to be able to guess from Swedish names for months and weekdays as well as English. This just means adding a few elements to the relevant lists (some of the names or abbreviations are identical in English and Swedish, e.g. "April").
#+begin_src emacs-lisp
(with-eval-after-load "parse-time"
  (setq parse-time-months
        '(;; english, default
          ("jan" . 1) ("feb" . 2) ("mar" . 3) ("apr" . 4) ("may" . 5) ("jun" . 6)
          ("jul" . 7) ("aug" . 8) ("sep" . 9) ("oct" . 10) ("nov" . 11)
          ("dec" . 12) ("january" . 1) ("february" . 2) ("march" . 3)
          ("april" . 4) ("june" . 6) ("july" . 7) ("august" . 8) ("september" . 9)
          ("october" . 10) ("november" . 11) ("december" . 12)
          ;; Swedish, short
          ("sept" . 9) ("okt" . 10)
          ;; Swedish full
          ("januari" . 1) ("februari" . 2) ("mars" . 3) ("maj" . 5)
          ("juni" . 6) ("juli" . 7) ("augusti" . 8) ("oktober" . 10))
        )

  (setq parse-time-weekdays
        '(("sun" . 0) ("mon" . 1) ("tue" . 2) ("wed" . 3) ("thu" . 4) ("fri" . 5)
          ("sat" . 6) ("sunday" . 0) ("monday" . 1) ("tuesday" . 2)
          ("wednesday" . 3) ("thursday" . 4) ("friday" . 5) ("saturday" . 6)
          ("sön" . 0) ("mån" . 1) ("tis" . 2) ("ons" . 3) ("tor" . 4) ("fre" . 5)
          ("lör" . 6) ("söndag" . 0) ("måndag" . 1) ("tisdag" . 2) ("onsdag" . 3)
          ("torsdag" . 4) ("fredag" . 5) ("lördag" . 6)
          ;; very short
          ("sö" . 0) ("må" . 1) ("ti" . 2) ("on" . 3) ("to" . 4) ("fr" . 5) ("lö" . 6)
          )))
#+end_src

**** Auto deadline
#+begin_src emacs-lisp
(defun aj/org-add-auto-deadline (force)
  "Inserts deadline based on scheduled time and effort."
  (interactive "P")
  (let* ((st (org-get-scheduled-time (point)))
         (dt (org-get-deadline-time (point)))
         (eff (org-entry-get nil org-effort-property))
         ;; (effs (* 60 (org-duration-string-to-minutes eff)))
         )
    (when (and
           (or force (not dt))
           st eff)
      (org--deadline-or-schedule nil 'deadline st)
      (org--deadline-or-schedule
       nil 'deadline
       (concat "++" eff)))))

(bind-key "C-c C-x C-d" #'aj/org-add-auto-deadline org-mode-map)
#+end_src


**** Clocking
***** Standard variables
#+begin_src emacs-lisp
(setq org-clock-persist 'history
      org-clock-history-length 10
      org-clock-x11idle-program-name "xprintidle"
      org-clock-idle-time 10
      org-clock-string-limit 25
      org-clock-in-switch-to-state "STARTAD")

(org-clock-persistence-insinuate)

;; don’t want unsafe variable complaints about this
(put 'org-clock-in-switch-to-state 'safe-local-variable 'stringp)
#+end_src

***** Only clock in items in a TODO state.
Add a function to ~org-clock-in-prepare-hook~, run in ~org-clock-in~, where we can throw ~abort~, to abort the clock-in.
#+begin_src emacs-lisp
(defun aj/org-only-clock-in-todos ()
  (unless (member (org-get-todo-state) org-not-done-keywords)
    (message "Not a todo item!")
    (throw 'abort nil)))

(add-hook 'org-clock-in-prepare-hook #'aj/org-only-clock-in-todos)
#+end_src

***** org-pomodoro
#+begin_src emacs-lisp
(use-package org-pomodoro
  :init (let ((samesound
               "/usr/share/sounds/freedesktop/stereo/complete.oga"))
          (setq
           org-pomodoro-audio-player "paplay"
           org-pomodoro-finished-sound samesound
           org-pomodoro-long-break-sound samesound
           org-pomodoro-short-break-sound samesound
           org-pomodoro-overtime-sound samesound
           org-pomodoro-time-format "%.2m"
           org-pomodoro-format "P~%s"
           org-pomodoro-keep-killed-pomodoro-time t
           org-pomodoro-manual-break t))
  :config
  (alert-add-rule
   :category "org-pomodoro"
   :style 'libnotify
   :continue nil))
#+end_src

**** Clocksum variables, duration units, effort global properties
#+begin_src emacs-lisp
(use-package org-duration
  :straight nil
  :custom (org-duration-units `(("min" . 1)
                                ("p" . 25) ; time of a pomodoro!
                                ("h" . 60)
                                ("d" . ,(* 60 8)) ; 8 hour work day
                                ("w" . ,(* 60 8 5)) ; 5 days a week
                                ("m" . ,(* 60 8 21)) ; 21 working days per month
                                ;; 10.5 such working months (because I have 31 days of
                                ;; vacation. 🙌 Swedish working agreements)
                                ("y" . ,(round (* 60 8 21 10.5)))))
  (org-duration-format
   '(("m") ("w") ("d") (special . h:mm)))
  :config
  (org-duration-set-regexps))

;; :ETC makes these the values offered for completion, but won’t require a match
(add-to-list
 'org-global-properties
 '("Effort_ALL" . "0:15 1p 2p 3p 4p 1h 2h 3h 4h 6h 1d 2d 3d 4d 1w 2w 3w :ETC"))
#+end_src

**** Org clock select task. Return agenda tasks to clock in to
#+begin_src emacs-lisp
(advice-add 'org-clock-select-task :override #'aj/org-clock-select-task)

(defun aj/org-clock-select-task (&optional _prompt)
  "Select a task for clocking"
  (interactive)
  (let ((targets (aj/org-get-clock-targets)))
    (or
     (when-let
         ((sel (consult--multi
                `((:name "Recent" :category org-entry :items ,(aj/org-clock-history))
                  (:name "Agenda entries" :category org-entry :items ,targets))))
          (m (get-text-property 0 :marker (car sel))))
       (prog1
           (copy-marker m)
         (cl-loop for e in targets do
                  (set-marker (get-text-property 0 :marker e) nil))))
     (user-error "No clock in task chosen"))))

;; (defun aj/org-get-clock-targets ()
;;   (cl-loop for f in (aj/org-agenda-refile-targetfiles) append
;;            (with-current-buffer (org-get-agenda-file-buffer f)
;;              (org-element-cache-map
;;               (lambda (el)
;;                 (when (eq 'todo (org-element-property :todo-type el))
;;                   (aj/org-clock-history-candidate (set-marker (make-marker) (org-element-property :begin el)))))
;;               :granularity 'headline
;;               :restrict-elements '(headline)))))

(defun aj/org-get-clock-targets ()
  (cl-loop for f in (aj/org-agenda-refile-targetfiles) append
           (with-current-buffer (org-get-agenda-file-buffer f)
             (org-element-cache-map
              (lambda (el)
                (when (eq 'todo (org-element-property :todo-type el))
                  (propertize (aj/org-element-parents-outline el)
                              :marker
                              (set-marker (make-marker) (org-element-property :begin el)))))
              :granularity 'headline
              :restrict-elements '(headline)))))

(defun aj/org-element-parents-outline (child)
  (let ((parent (org-element-property :parent child)))
    (if (eq 'headline (org-element-type parent))
        (concat
         (aj/org-element-parents-outline parent)
         "/"
         (org-element-property :raw-value child))
      (file-name-base (buffer-file-name)))))

(defun aj/org-clock-history ()
  (let (och)
    ;; Remove successive dups from the clock history to consider
    (dolist (c org-clock-history)
      (unless (equal c (car och))
        (push c och)))
    (cl-loop for m in (reverse och)
             when (marker-buffer m)
             collect (aj/org-clock-history-candidate m))))

(defun aj/org-clock-history-candidate (marker)
  (with-temp-buffer
    (let ((cm (org-clock-insert-selection-line 0 marker)))
      (goto-char (point-min))
      (propertize (buffer-substring 4 (point-at-eol)) :marker (cdr cm)))))

;; TODO add sources for
;; org-clock-default task, interrupted-task, current clocking task
;; (when (marker-buffer org-clock-default-task)
;;   (insert (org-add-props "Default Task\n" nil 'face 'bold))
;;   (setq s (org-clock-insert-selection-line ?d org-clock-default-task))
;;   (push s sel-list))
;; (when (marker-buffer org-clock-interrupted-task)
;;   (insert (org-add-props "The task interrupted by starting the last one\n" nil 'face 'bold))
;;   (setq s (org-clock-insert-selection-line ?i org-clock-interrupted-task))
;;   (push s sel-list))
;; (when (org-clocking-p)
;;   (insert (org-add-props "Current Clocking Task\n" nil 'face 'bold))
;;   (setq s (org-clock-insert-selection-line ?c org-clock-marker))
;;   (push s sel-list))




#+end_src

** org-id, add id's in this file! And for all org files in a directory.
#+begin_src emacs-lisp
(defun aj/org-id-update-id-locations-from-file ()
  (interactive)
  (when-let (fn (buffer-file-name))
    (org-id-update-id-locations (list fn))))

(defun aj/org-id-update-id-locations-recursive (dir)
  (interactive "D")
  (let ((recentf-active recentf-mode))
    (recentf-mode -1)
    (org-id-update-id-locations
     (directory-files-recursively dir ".*\\.org$" nil t t))
    (when recentf-active (recentf-mode))))
#+end_src

** Completion for linking to headlines
Do this with a custom link type?
#+begin_src emacs-lisp
(with-eval-after-load 'ol
  (org-link-set-parameters "#"
                           :complete #'aj/org-complete-ids)


  (defun aj/org-complete-ids ()
    (let ((candidates))
      (org-element-cache-map
       (lambda (hl)
         (when-let ((id (org-element-property :CUSTOM_ID hl))
                    (id (concat "#" id)))
           (let ((cand (concat (org-element-property :title hl) "   " (propertize id 'face 'shadow))))
             (add-text-properties 0 1
                                  `(consult--candidate ,id)
                                  cand)
             (push cand candidates))))

       :granularity 'headline)
      (consult--read
       (nreverse candidates)
       :prompt "Custom id link: "
       :require-match nil
       :sort nil
       :lookup #'consult--lookup-candidate)
      ;; (pp-display-expression s "*ids*")
      )))


;; (defun aj/org-get-names ()
;;   (let (candidates)
;;     (org-element-cache-map
;;      (lambda (el)
;;        (when-let ((name (org-element-property :name el)))
;;          (push name candidates)
;;          ;; (let ((cand (concat (org-element-property :title hl) "   " (propertize name 'face 'shadow))))

;;          ;;   (add-text-properties 0 1
;;          ;;                        `(consult--candidate ,name)
;;          ;;                        cand)
;;          ;;   (push cand candidates))
;;          ))

;;      :granularity 'element)
;;     (pp-display-expression candidates "*names*"))

;;   )

#+end_src

** Visibility, folding, display etc.
*** Patch initial display of trees with folded visibility property
When outline visibility is set so that these trees wouldn’t be shown (for example with ~show2levels~) we don’t want them to be shown just because they bave a visibility property set to ~folded~. This patch fixes that problem.
#+begin_src emacs-lisp
(el-patch-feature org-cycle)
(with-eval-after-load 'org-cycle
  (el-patch-defun org-cycle-set-visibility-according-to-property ()
    "Switch subtree visibility according to VISIBILITY property."
    (interactive)
    (let ((regexp (org-re-property "VISIBILITY")))
      (org-with-point-at 1
        (while (re-search-forward regexp nil t)
	      (let ((state (match-string 3)))
	        (if (not (org-at-property-p)) (outline-next-heading)
	          (save-excursion
	            (org-back-to-heading t)
                (el-patch-wrap 2
                  (unless (and (equal "folded" state)
                               (org-fold-folded-p (point-at-eol)))
	                (org-fold-subtree t)
	                (org-fold-reveal)
	                (pcase state
		              ("folded"
		               (org-fold-subtree t))
		              ("children"
		               (org-fold-show-hidden-entry)
		               (org-fold-show-children))
		              ("content"
		               (save-excursion
		                 (save-restriction
		                   (org-narrow-to-subtree)
		                   (org-cycle-content))))
		              ((or "all" "showall")
		               (org-fold-show-subtree))
		              (_ nil)))))
	          (org-end-of-subtree))))))))
#+end_src

*** Make visibility property "folded" behave as if subtree was archived, i.e. always hidden after visibility cycling
This is based on ~org-cycle-hide-archived-trees~.
#+begin_src emacs-lisp
(add-hook 'org-cycle-hook #'aj/org-cycle-hide-folded-trees)

(defun aj/org-cycle-hide-folded-trees (state)
  "Re-hide all trees with visibility folded after a visibility state change.
STATE should be one of the symbols listed in the docstring of
`org-cycle-hook'."
  (when (not (or org-cycle-open-archived-trees ; just re-use this
                 (memq state '(overview folded))))
    (save-excursion
      (let* ((globalp (memq state '(contents all)))
             (beg (if globalp (point-min) (point)))
             (end (if globalp (point-max) (org-end-of-subtree t))))
        (aj/org-hide-folded-trees beg end)
        (goto-char beg)
        (when (equal "folded" (org-entry-get (point) "visibility"))
          (message "%s" (substitute-command-keys
                         "Subtree has VISIBILITY: folded, and stays closed.  Use \
`\\[org-cycle-force-archived]' to cycle it anyway.")))))))

(defun aj/org-hide-folded-trees (beg end)
  "Re-hide all subtrees with visibility folded after a visibility state change."
  (org-with-wide-buffer
   (let ((case-fold-search nil)
         (re ":VISIBILITY: folded"))
     (goto-char beg)
     (beginning-of-line) ; Include headline point is currently on.
     (while (and (< (point) end) (search-forward re end t))
       (org-cycle-set-visibility-according-to-property)))))
#+end_src

*** Read-only-trees :ARCHIVE:
Trees can be defined as read only with tag ~read_only~
From: http://kitchingroup.cheme.cmu.edu/blog/2014/09/13/Make-some-org-sections-read-only/

But I don’t actually use this much at all. Disable it for now

#+begin_src emacs-lisp
(defface aj/org-readonly-face '((t . (:inherit fringe)))
  "Face for read-only-sections"
  :group 'aj)

(defun aj/org-mark-readonly (&rest _ignore)
  (interactive)
  (unless (eq 0 (buffer-size))
    (org-map-entries
     (lambda ()
       (let* ((element (org-element-at-point))
              (begin (org-element-property :begin element))
              (end (org-element-property :end element)))
         (add-text-properties begin (- end 1)
                              '(read-only t font-lock-face aj/org-readonly-face))))
     "read_only" 'file)))

(defun aj/org-remove-readonly (&rest _ignore)
  (interactive)
  (org-map-entries
   (lambda ()
     (let* ((element (org-element-at-point))
            (begin (org-element-property :begin element))
            (end (org-element-property :end element))
            (inhibit-read-only t))
       (remove-text-properties begin (- end 1) '(read-only t font-lock-face aj/org-readonly-face))))
   "read_only" 'file))

(add-hook 'org-mode-hook #'aj/org-mark-readonly)

;; make tags editable
(advice-add 'org-set-tags-command :before #'aj/org-remove-readonly)
(advice-add 'org-set-tags-command :after #'aj/org-mark-readonly)


#+end_src

*** Version of ~org-tree-to-indirect-buffer~ that works as I want it to
That is, always create a new buffer. (Is there anything more changed?)
#+begin_src emacs-lisp
(defun aj/org-tree-to-indirect-buffer (&optional arg)
  "My own simple version of `org-tree-to-indirect-buffer'"
  (interactive "P")
  (let ((cbuf (current-buffer))
        (cwin (selected-window))
        (pos (point))
        beg end heading ibuf)
    (save-excursion
      (org-back-to-heading t)
      (when (numberp arg)
	    (setq level (org-outline-level))
	    (when (< arg 0) (setq arg (+ level arg)))
	    (while (> (setq level (org-outline-level)) arg)
	      (org-up-heading-safe)))
      (setq beg (point)
	        heading (org-get-heading 'no-tags))
      (org-end-of-subtree t t)
      (when (and (not (eobp)) (org-at-heading-p)) (backward-char 1))
      (setq end (point)))
    ;; don’t replace old indirect buffers, why would I want that?
    (setq ibuf (org-get-indirect-buffer cbuf heading)
          org-last-indirect-buffer ibuf)
    ;; always want other-window, disregard ‘org-indirect-buffer-display’
    (pop-to-buffer ibuf)
    (narrow-to-region beg end)
    ;; changed to not unfold blocks and drawers:
    (org-fold-show-all '(headings))
    (goto-char pos)
    (run-hook-with-args 'org-cycle-hook 'all)
    (and (window-live-p cwin) (select-window cwin))))

(bind-key "C-c C-x b" #'aj/org-tree-to-indirect-buffer org-mode-map)
#+end_src


** org-download
#+begin_src emacs-lisp
(use-package org-download
  :init (org-download-enable)
  :commands (org-download-enable)
  :config
  (setq org-download-backend 'curl)
  (setq-default org-download-heading-lvl nil
                org-download-image-dir "./bilder"))

#+end_src

** File-associations, opening links externally :org_async:
#+begin_src emacs-lisp
(add-to-list 'org-file-apps '("\\.pdf\\'" . emacs)) ; open pdfs in emacs
(add-to-list 'org-file-apps '("\\.odt\\'" . system)) ; force odt to system
;;use xdg-open instead of mailcap
;; this won’t work in a real console, but I won’t open files from org in a real console
(setq org-file-apps-gnu '((remote . emacs) (system . "xdg-open %s") (t . "xdg-open %s")))

;; disassociates started processes so they wont get killed if emacs is killed.
(advice-add 'org-open-file :around  #'aj/org-open-file-around-advice)
(defun aj/org-open-file-around-advice (fn &rest args)
  "Set `process-connection-type' to nil"
  (let ((process-connection-type nil))
    (apply fn args)))

(defun aj/org-open-file-with-system (path)
  (org-open-file path 'system))

#+end_src

** Local variables headings
A local variables comment block that is placed at the end of the file may be lost or moved if the last subtree (under which it is viewed as being filed) is removed or moved. We don’t want that! Instead, automatically place local variables under their own top-level heading. By default I put the ~ARCHIVE~ tag on this heading, to hide it away a bit and avoid exporting it.
#+begin_src emacs-lisp
(defun aj/org-insert-local-variable-heading (&rest _args)
  "Insert a heading under which local variables can be stored, if not already present"
  (when (eq major-mode 'org-mode)
    (push-mark)
    (save-excursion
      (save-restriction
        (widen)
        (goto-char (point-max))
        ;;this is maybe done in a more stable way in `modify-file-local-variable'
        (unless (search-backward-regexp "^\\* \\(COMMENT \\)?Local [Vv]ariables\\( :ARCHIVE:\\)?"
                                        (max (- (point-max) 3000) (point-min)) t)
          (if (search-backward-regexp "^\\# Local [Vv]ariables:" nil t)
              (open-line 1)
            (newline))
          (insert "\n* Local Variables :ARCHIVE:\n"))))))

(advice-add 'add-file-local-variable :before #'aj/org-insert-local-variable-heading)
#+end_src

** Structure editing

*** Display name of invisible parent when promoting/demoting
#+begin_src emacs-lisp
(add-hook 'org-after-demote-entry-hook #'aj/org-show-parent-for-demote-promote)
(add-hook 'org-after-promote-entry-hook #'aj/org-show-parent-for-demote-promote)

(defun aj/org-show-parent-for-demote-promote ()
  (when
      ;; not true for some org-capture cases that we want to avoid.
      (eq (selected-window) (get-buffer-window))
    (when-let ((prev (save-excursion
                       (when (org-up-heading-safe)
                         (cons (point) (org-get-heading t t t t))))))
      (unless (pos-visible-in-window-p (car prev))
        (with-silent-modifications
          (momentary-string-display (concat
                                     (propertize
                                      " "
                                      'display
                                      '(space . (:align-to
                                                 (- right (+ 30)))))
                                     "⮴ "
                                     (cdr prev))
                                    (point-at-eol)))))))
#+end_src

*** Sorting by last name
I often have lists of names for headlines. Nice to be able to sort them by last name. Here is a function to be used for creating a sort key that sorts on last name for ~org-sort-entries~ or ~org-sort-list~.
#+begin_src emacs-lisp
(defun aj/org-sort-last-names-headings ()
  "Create sort key for sorting by last names in headings"
  (let ((line (org-sort-remove-invisible (org-get-heading t t t t))))
    (if (string-match "^[[:space:]]*\\([^[:space:]]+\\) *\\(.*\\)$" line)
        (concat (match-string 2 line)
                (match-string 1 line))
      line)))


(defun aj/org-sort-last-names-list-entries ()
  "Create sort key for sorting by last names in plain lists"
  (let ((line (org-sort-remove-invisible
		       (buffer-substring (match-end 0) (point-at-eol)))))
    (if (string-match "^[[:space:]]*\\([^[:space:]]+\\) *\\(.*\\)$" line)
        (concat (match-string 2 line)
                (match-string 1 line))
      line)))
#+end_src

*** Even levels
Sometimes (especially importing from html) we get trees where a level 4 heading is beneath a level 2 heading. Not pretty. This promotes all such subtrees to the correct level (one level below parent).

#+begin_src emacs-lisp
(defun aj/org-even-levels ()
  "Promote all subtrees that are more than two levels below closest parent.

Doesn’t care at all about ‘org-odd-levels-only’, because I don’t use it."
  (interactive)
  (save-restriction
    (save-excursion
      (org-narrow-to-subtree)
      (goto-char (point-max))
      (while (outline-previous-heading)
        (aj/org-even-levels-maybe-promote)))))

(cl-defun aj/org-even-levels-maybe-promote ()
  (let ((diff (- (org-current-level)
                 (save-excursion
                   (if (org-up-heading-safe)
                       (org-current-level)
                     (cl-return-from aj/org-even-levels-maybe-promote))))))
    (when (< 1 diff)
      (dotimes (_i (1- diff))
        (org-promote-subtree)))))
#+end_src

** Refile settings
#+begin_src emacs-lisp
(setq org-refile-use-outline-path 'file
      org-outline-path-complete-in-steps nil)
#+end_src

*** Refile targets --- org files in same buffer
Useful for ~org-roam-directory~ for example.
#+begin_src emacs-lisp
(defun aj/org-refile-targets-same-dir ()
  (directory-files default-directory t ".*\\.org$" t))
#+end_src

** Navigation (consult-org)
Loaded already in init.el, but configuration here:
#+begin_src emacs-lisp
(embark-define-keymap aj/org-heading-map
  "Keymap for org mode headings"
  ("i"  aj/embark-org-clone-indirect-heading))

(setf (alist-get 'consult-org-heading embark-keymap-alist) 'aj/org-heading-map)

(defun aj/embark-org-clone-indirect-heading (heading)
  (when-let ((m (get-text-property 0 'consult--candidate heading)))
    (let ((consult-after-jump-hook nil))
      (save-excursion
        (save-restriction
          (consult--jump-1 m)
          (aj/org-tree-to-indirect-buffer))))))
#+end_src


** Columns view
*** Cut field length in org-columns-view dblocks
#+begin_src emacs-lisp
(el-patch-feature org-colview)

;; silence byte-compiler warnings
(declare-function org-columns-quit "org-colview")
(defvar org-columns-top-level-marker)
(defvar org-columns-current-fmt-compiled)

(with-eval-after-load 'org-colview
  (el-patch-defun org-columns--capture-view (maxlevel match skip-empty exclude-tags format local)
    "Cut down fields to field format length"

    (org-columns (not local) format)
    (goto-char org-columns-top-level-marker)
    (let ((columns (length org-columns-current-fmt-compiled))
	      (has-item (assoc "ITEM" org-columns-current-fmt-compiled))
          (el-patch-add (lengths (mapcar (lambda (col) (nth 2 col)) org-columns-current-fmt-compiled)))
	      table)
      (org-map-entries
       (lambda ()
         (when (get-char-property (point) 'org-columns-key)
	       (let (row)
	         (dotimes (i columns)
	           (let* ((col (+ (line-beginning-position) i))
		              (p (get-char-property col 'org-columns-key))
                      (el-patch-add (l (nth i lengths)))
                      (el-patch-add (str (get-char-property col
					                                        (if (string= p "ITEM")
					                                            'org-columns-value
					                                          'org-columns-value-modified)))))
	             (push (org-quote-vert
		                (el-patch-swap
                          (get-char-property col
					                         (if (string= p "ITEM")
					                             'org-columns-value
					                           'org-columns-value-modified))
                          (if (and l (< l (length str)))
                              (substring str 0 l)
                            str)))
		               row)))
	         (unless (or
		              (and skip-empty
			               (let ((r (delete-dups (remove "" row))))
			                 (or (null r) (and has-item (= (length r) 1)))))
		              (and exclude-tags
			               (cl-some (lambda (tag) (member tag exclude-tags))
				                    (org-get-tags))))
	           (push (cons (org-reduced-level (org-current-level)) (nreverse row))
		             table)))))
       (or (and maxlevel (format "LEVEL<=%d" maxlevel))
	       (and match match))
       (and local 'tree)
       'archive 'comment)
      (org-columns-quit)
      ;; Add column titles and a horizontal rule in front of the table.
      (cons (mapcar #'cadr org-columns-current-fmt-compiled)
	        (cons 'hline (nreverse table))))
    ))


#+end_src

** Extra org-entities :org_async:
#+begin_src emacs-lisp
(add-to-list 'org-entities-user '("slash" "\\slash{}" nil "/" "/" "/" "/"))
(add-to-list 'org-entities-user '("textelp" "\\textelp{}" nil "[…]" "[...]" "[...]" "[…]"))
#+end_src

** Archiving hierarchically
I want my archive files to retain some structure, placing archived entries in a copy of the branches above.

Adapted from code by Florian Adamsky, now here:
https://gitlab.com/andersjohansson/org-archive-hierarchically
#+begin_src emacs-lisp
(use-package org-archive-hierarchically
  :straight (:depth full :host github :repo "andersjohansson/org-archive-hierarchically")
  :commands org-archive-hierarchically
  :init (setq org-archive-default-command #'org-archive-hierarchically))
#+end_src

** Org capture

*** Capture in new frame
#+begin_src emacs-lisp
;; in /lisp
(use-package org-capture-new-frame
  :bind ([remap org-capture] . org-capture-new-frame-open)
  :straight nil)
#+end_src

*** Save files after capturing and refiling
I almost always finish capturing by refiling, and while ~org-capture-finalize~ does normally save the file, this doesn’t apply in ~org-capture-refile~. Additionally, we can’t be sure if we are still in the same buffer, so we just save all open org-buffer.
#+begin_src emacs-lisp
(advice-add 'org-capture-finalize :after #'org-save-all-org-buffers)
#+end_src
*** Capture templates
Templates are private and kept in custom.el.
#+begin_src emacs-lisp
(setq org-default-notes-file (expand-file-name "notes.org" org-directory))
#+end_src

*** Ensure line break in captured section
I often mess up and remove the last line-break in the capture buffer. This can inadvertantly include the [[file:~/.emacs.d/lisp/aj-org-config.org::*Local%20variables%20headings][Local variables heading]] that is below the last captured headline under this headline.
This function run with ~org-capture-prepare-finalize-hook~ avoids this problem by always making sure we have at least one linebreak at the end of the capture buffer.

#+begin_src emacs-lisp
(defun aj/ensure-linebreak-at-eob ()
  (unless (progn (goto-char (point-max))
                 (looking-back "
" 1))
    (insert "\n")))

(add-hook 'org-capture-prepare-finalize-hook #'aj/ensure-linebreak-at-eob)
#+end_src

*** Capture help functions
**** Add ID to some notes
Currently those entered with "a", could of course be generalized.
#+begin_src emacs-lisp
(with-eval-after-load 'org-capture
  (defun aj/org-capture-maybe-add-id ()
    (when (equal "a" (org-capture-get :key t))
      (org-id-get-create)))

  (add-hook 'org-capture-prepare-finalize-hook #'aj/org-capture-maybe-add-id))
#+end_src

**** Check off reading habit when capturing a reading note.
#+begin_src emacs-lisp
(with-eval-after-load 'org-capture
  (defun aj/org-capture-maybe-mark-read ()
    (when (equal "l" (org-capture-get :key t))
      (aj/org-id-todo-state "aj:read-habit" 'done)))

  (add-hook 'org-capture-prepare-finalize-hook #'aj/org-capture-maybe-mark-read))
#+end_src

**** Insert weektree CUSTOM_ID
#+begin_src emacs-lisp
(advice-add 'org-datetree--find-create :after #'aj/insert-datetree-custom-id)

(defun aj/insert-datetree-custom-id (&rest _args)
  "Gives each week in a week-tree a custom id"
  (let ((ch (org-get-heading t t)))
    (when (and (not (org-entry-get (point) "CUSTOM_ID"))
               (string-match-p "^[12][0-9]\\{3\\}-W[0-5][0-9]$" ch))
      (org-entry-put
       (point)
       "CUSTOM_ID" ch
       ;; (replace-regexp-in-string "[^a-zåäöA-ZÅÄÖ0-9]+" "-" ch)
       ))))
#+end_src

**** For journal with writing log :ARCHIVE:
Don’t really use this now. Unsure if it works
#+begin_src emacs-lisp
(defun aj/org-skrivande-journal-template ()
  (format
   (concat
    "* Skrivet %%u :skrivlogg:\n"
    ":PROPERTIES:\n"
    ":textmängd: %s\n"
    ":PROPERTIES:\n"
    "CLOCK: => %s\n"
    "%%?")
   (read-from-minibuffer "Textmängd (antal w, p, pp, s):")
   (with-current-buffer
       (find-file-noselect
        (expand-file-name "jobbplanering.org" org-directory))
     (aj/org-skrivande-senaste nil))))

(defun aj/org-skrivande-senaste (choose)
  "Returns"
  (interactive "P")
  (let ((period
         (cond
          ((equal choose '(4))
           (intern
            (completing-read "Period"
                             '(today yesterday thisweek lastweek
                                     thismonth lastmonth thisyear lastyear)
                             nil t 'today)))
          ((equal choose '(16)) 'interactive)
          (t 'today))))
    (message (aj/org-get-tagged-clocked-in-file "skrivande" period))))

(defun aj/org-get-tagged-clocked-in-file (tag period)
  "Period can be a symbol recognized by `org-clock-special-range'
or a list with start and end date (in days) as first and last
element"
  (let* ((tste
          (if (symbolp period)
              (let ((pp (butlast (org-clock-special-range period))))
                (mapcar #'time-to-days pp));; TODO, kolla att det blev rätt
            period)))
    (org-duration-from-minutes
     (cadr
      (org-clock-get-table-data
       (buffer-file-name)
       `(:maxlevel 15 :tags ,tag :tstart ,(car tste) :tend ,(cadr tste)))))))

#+end_src

Att få dagens klockade tid för specifikt item är inte så svårt:
#+begin_src emacs-lisp
(defun aj/org-clock-sum-current-item-today (&optional headline-filter)
  "Return time, clocked on current item today."
  (save-excursion
    (save-restriction
      (let ((range (org-clock-special-range 'today)))
        (org-narrow-to-subtree)
        (org-clock-sum (car range) (cadr range) headline-filter :org-clock-minutes-today)
        org-clock-file-total-minutes))))
#+end_src
**** For fieldnotes :ARCHIVE:
Don’t use it now
#+begin_src emacs-lisp
(defun aj/org-fieldnote-capture ()
  (let
      ((typ (completing-read "Typ: " '("Observation" "Reflektion" "Forskningsdagbok") nil t nil nil "Observation"))
       (titel (read-from-minibuffer "Titel: " nil nil nil nil "Observation av")))
    (org-set-property "TYP" typ)
    (org-set-property "EXPORT_DATE" (format-time-string "%Y-%m-%d" (org-capture-get :default-time)))
    (save-excursion (move-end-of-line nil) (insert " :" typ ":"))
    titel))

(add-hook 'org-capture-after-finalize-hook #'aj/org-fieldnote-commit-after-capture)
(defun aj/org-fieldnote-commit-after-capture ()
  (when (equal "f" (org-capture-get :key))
    (let* ((file (cadr (org-capture-get :target)))
           (filend (file-name-nondirectory file))
           (dir (file-name-directory file)))
      (when (y-or-n-p "Committa filen?")
        ;;(save-buffer)
        ;;(shell-command (format "git add %s" file))
        (magit-status dir)
        (magit-stage-file filend)
        (aj/org-fieldnote-commit-template dir)
        (call-interactively #'magit-commit-popup)))))


(defun aj/org-fieldnote-commit-template (basedir)
  (save-window-excursion
    (aj/write-string-to-file
     (let ((tmp ""))
       (with-temp-buffer
         (cd basedir)
         (insert (shell-command-to-string "git diff --cached"))
         (goto-char (point-min))
         (while (re-search-forward
                 "^+\\*\\*\\*\\*\\(?: +\\)?\\(?: +\\(?:\\[#.\\]\\)\\)?\\(?: +\\(.*?\\)\\)??\\(?:[   ]+\\(:[[:alnum:]_@#%:]+:\\)\\)?[    ]*$"
                 nil t)
           (setq tmp (concat tmp (match-string-no-properties 1) "\n"))))
       tmp)
     (expand-file-name ".git/info/commit-template.txt" basedir))))
#+end_src


**** Return zotxt-references. :ARCHIVE:
#+begin_src emacs-lisp
(defun aj/org-return-org-zotxt-ref ()
  "Fetch an org-zotxt link and return it as a string"
  (let ((zotxt--debug-sync t))
    (with-temp-buffer
      (org-zotxt-insert-reference-link nil)
      (buffer-string))))
#+end_src

**** Return citations
#+begin_src emacs-lisp
;; To use it for ROAM_REFS in capture
(defvar aj/org-last-returned-citation-key nil)
(defun aj/org-last-returned-citation-key ()
  aj/org-last-returned-citation-key)

(defun aj/org-return-citation (&optional initial-input)
  "Fetch a citation and return it as a string.
Possibly passss INITIAL-INPUT"
  (let* ((key (car (citar-select-refs :multiple nil :initial-input initial-input))))
    (setq aj/org-last-returned-citation-key key)
    (concat "[cite:@" key "]")))

(defun aj/org-return-reference-author-year-title (&optional initial-input)
  "Fetch a simply formatted reference and return it as a string.
Possibly passss INITIAL-INPUT"
  (let* ((key (car (citar-select-refs :multiple nil :initial-input initial-input))))
    (setq aj/org-last-returned-citation-key key)
    (citar-format--entry "${author editor} (${year issued date}) “${title}”" key)))

#+end_src

**** Capture in new frame.                                       :ARCHIVE:
Useful for launching a small capture frame from window manager with a call like:
~emacsclient --eval "(aj/org-capture-new-frame \"$1\" $2)"~
#+begin_src emacs-lisp
(defun aj/org-capture-new-frame (key &optional height)
  (let ((ocframe (make-frame `((width . 100)
                               (height . ,(or height 20))
                               (name . "org-capture")
                               (window-system . x)
                               (fullscreen . nil)))))
    (select-frame-set-input-focus ocframe)
    (aj/center-frame)
    (org-capture nil key)
    (delete-other-windows)
    (add-hook 'org-capture-after-finalize-hook #'delete-frame)))

;; if we don’t run capture with new frame
(add-hook 'org-capture-mode-hook
          (lambda () (remove-hook 'org-capture-after-finalize-hook #'delete-frame)))
#+end_src


** org-protocol-capture-html: Capture web pages from browser
#+begin_src emacs-lisp
(use-package org-protocol-capture-html
  :straight (org-protocol-capture-html :repo "alphapapa/org-protocol-capture-html" :host github :files ("org-protocol-capture-html.el"))
  :custom org-protocol-capture-html-pandoc-extra-args '("--lua-filter=/home/aj/kodat/000-egna-skript/pandoc-remove-header-attributes.lua"))
#+end_src

** org-protocol for linking into org files
I keep some notes for papers in org-mode, but sort my papers in Zotero. With this I can easily add a link to the specific note from Zotero, which is launched and resolved through org-protocol.
#+begin_src emacs-lisp
(use-package org-protocol
  :straight nil ;; included with org
  :config
  (add-to-list 'org-protocol-protocol-alist
               '(link
                 :protocol "link"
                 :function aj/org-resolve-link))

  (defun aj/org-resolve-link (plist)
    (org-link-open-from-string
     (org-link-make-string (plist-get plist :link))))

  (defun aj/get-org-protocol-link ()
    (format "org-protocol://link?link=id:%s" (org-id-get-create)))

  (defun aj/org-make-unique-link-clipoard ()
    (interactive)
    (gui-set-selection 'CLIPBOARD (aj/get-org-protocol-link)))

  (defalias 'aj/org-id-org-protocol-link-copy 'aj/org-make-unique-link-clipoard))

(defun aj/add-zotero-link-to-headline ()
  (interactive)
  (if-let ((link (aj/get-org-protocol-link))
           (id (or
                (car-safe (org-roam-node-refs (org-roam-node-at-point)))
                (car-safe (citar-org-key-at-point))
                (save-excursion
                  (org-back-to-heading)
                  (when (search-forward "[cite:" (point-at-eol) t)
                    (car-safe (citar-org-key-at-point))))
                (when-let ((ref (org-entry-get (point) "roam_refs")))
                  (and (string-match org-element-citation-key-re ref)
                       (match-string 1 ref)))))
           (fn (buffer-file-name (org-base-buffer (current-buffer)))))
      (request
        "http://127.0.0.1:23119/zotxt/inserturl"
        :params
        `(("betterbibtexkey" . ,id)
          ("url" . ,link)
          ("title" . ,(format "org-link to %s" fn)))
        :success (cl-function
                  (lambda (&key _data &allow-other-keys)
                    (message "Linked!")))
        :error (cl-function
                (lambda (&key response &allow-other-keys)
                  (message "Failed on %s" (request-response-url response)))))
    (user-error "Couldn’t construct link.")))

;; (with-eval-after-load 'zotxt
;;   (defun aj/add-zotero-link-to-headline ()
;;     (interactive)
;;     (if-let ((link (aj/get-org-protocol-link))
;;              (id (or
;;                   (org-zotxt-extract-link-id-at-point)
;;                   (save-excursion
;;                     (org-back-to-heading)
;;                     (when (search-forward "[[" (point-at-eol) t)
;;                       (org-zotxt-extract-link-id-at-point))))))
;;         (request
;;           (format "%s/inserturl" zotxt-url-base)
;;           :params
;;           `(("key" . ,id)
;;             ("url" . ,link)
;;             ("title" . "org")))
;;       (user-error "Couldn’t create link")))
;;   (with-eval-after-load 'org-zotxt
;;     (bind-key "C-c \" l" #'aj/add-zotero-link-to-headline org-zotxt-mode-map)))
#+end_src

** Special commands for org-babel-tangle
#+begin_src emacs-lisp
(defun aj/org-babel-tangle-tagged (tag)
  (interactive (list (completing-read "tag: " (org-get-buffer-tags) nil t)))
  (org-scan-tags
   (lambda () (save-restriction
           (org-narrow-to-subtree)
           (org-babel-tangle)))
   (org-make-tags-matcher tag)
   nil))

(defun aj/org-tangle-computer-config ()
  "Tangle config tagged with current ‘system-name’"
  (interactive)
  (aj/org-babel-tangle-tagged (system-name)))
#+end_src

** Copy region as html or ascii
#+begin_src emacs-lisp
(defun aj/org-export-copy-region-or-subtree-as (&optional backend)
  "Places selected region in kill ring as ascii, or HTML with prefix arg.
Can be passed any ox BACKEND in a non-interactive call"
  (interactive "P")
  (let* ((backend (cond
                   ((and backend (symbolp backend)) backend)
                   (backend 'html)
                   (t 'thinascii)))
         (epl (org-export--get-subtree-options backend)))
    (kill-new
     (if (region-active-p)
         (save-restriction
           (narrow-to-region (region-beginning) (region-end))
           (org-export-as backend nil t t epl))
       (save-excursion
         (org-back-to-heading)
         (org-export-as backend t nil t epl))))))
(bind-key "M-W" #'aj/org-export-copy-region-or-subtree-as org-mode-map)

(defun aj/second-identity (_first second &rest _args)
  second)

(autoload 'org-export-define-derived-backend "ox")
(org-export-define-derived-backend 'thinascii 'ascii
  :translate-alist '((bold . aj/second-identity)
                     (italic . aj/second-identity)
                     (underline . aj/second-identity))
  :options-alist '((:ascii-charset nil nil 'utf-8)
                   (:ascii-text-width nil nil 3000)))
#+end_src

** Org-annotate :org_async:
#+begin_src emacs-lisp
(use-package org-annotate
  :straight (:host github :repo "girzel/org-annotate"
                   :fork (:host github :repo "andersjohansson/org-annotate" :branch "org9.3"))
  :bind (:map org-mode-map
              ("C-c C-ä" . org-annotate-add-note)
              ("C-c C-Ä" . org-annotate-delete-note)
              ("C-c C-x C-ä" . org-annotate-display-notes))
  :demand t
  :custom
  (org-annotate-special-brackets '("{" ":" "}"))
  ;; functions defined below
  (org-annotate-export-functions
   '((html . org-annotate-export-html-tooltip)
     (latex . aj/org-annotate-export-latex-fixme-and-inline)
     (odt . aj/org-annotate-export-odt-annotation-or-inline)
     (md . aj/org-annotate-export-md-pandoc-odt)
     (pandoc . aj/org-annotate-export-org-pandoc-odt)))


  :config
  (set-face-attribute 'org-annotate-bracket-face nil :inherit 'font-lock-variable-name-face :weight 'bold)
  (set-face-attribute 'org-annotate-face nil :underline nil :weight 'unspecified :inherit 'font-lock-comment-face)

  (defun aj/org-annotate-extract-author (note)
    (if (string-match "{\\([^}]+\\)} *" note)
        (list (match-string 1 note)
              (replace-match "" t t note))
      (list nil note)))

  (defun aj/org-annotate-export-latex-fixme-and-inline (path desc)
    (let ((optstring "")
          opt)
      (when (string-match "^inline:\\(.+\\)" path)
        (setq opt '("inline" "notodonotesbw" "nomargin"))
        (setq path (match-string 1 path)))
      (cl-destructuring-bind
          (author path) (aj/org-annotate-extract-author path)
        (setq path (org-export-data-with-backend path 'latex nil))
        (when author (push (concat "author=" author) opt))
        (when opt (setq optstring (concat "[" (string-join opt ",") "]")))
        (if desc
            (format "\\fxnote*%s{%s}{%s}" optstring path
                    (org-export-data-with-backend desc 'latex nil))
          (format "\\fxnote%s{%s}" optstring path)))))

  (defun aj/org-annotate-export-org-pandoc-odt (path desc)
    (concat
     "@@opendocument:" ;; for pandoc, in real org should be “odt”
     (aj/org-annotate-export-odt-annotation-or-inline path desc)
     "@@"))

  (defun aj/org-annotate-export-md-pandoc-odt (path desc)
    (concat
     "`"
     (aj/org-annotate-export-odt-annotation-or-inline path desc)
     "`{=opendocument}"))

  (defun aj/org-annotate-export-odt-annotation-or-inline (path desc)
    "Let notes prefixed with \"inline:\" just be set in italics.
    Otherwise export as odt annotation"
    (setq path (org-export-data-with-backend path 'odt nil)
          desc (when desc (org-export-data-with-backend desc 'odt nil)))
    (cl-destructuring-bind
        (author path) (aj/org-annotate-extract-author path)
      (let
          ((author (or author (user-full-name)))
           (date (let ((ct (current-time)))
                   (concat (format-time-string "%FT%T." ct) (number-to-string (nth 2 ct))))))
        (if (string-match "^inline:\\(.+\\)" path)
            (format "<text:span text:style-name=\"Emphasis\">%s</text:span> %s"
                    (match-string 1 path) (or desc "<text:line-break/>"))
          (if desc
              (let ((an-name (concat "__Annot_" (number-to-string (random)))))
                (format "<office:annotation office:name=\"%s\"><dc:creator>%s</dc:creator><dc:date>%s</dc:date><text:list><text:list-item><text:p>%s</text:p></text:list-item></text:list></office:annotation>%s<office:annotation-end office:name=\"%s\"/>"
                        an-name author date path desc an-name))
            (format "<office:annotation><dc:creator>%s</dc:creator><dc:date>%s</dc:date><text:list><text:list-item><text:p>%s</text:p></text:list-item></text:list></office:annotation>"
                    author date path))))))

  ;; some notes are more private and don’t need to go with the export
  (defcustom aj/org-annotate-ignored-prefixes '("noexport")
    "Prefixes for avoiding export of org-annotate-notes.
List of prefix strings or regex."
    :group 'aj
    :type '(choice (repeat string)
                   regexp)
    :safe (lambda (x) (or (stringp x) (cl-every #'stringp x))))

  (defun aj/org-annotate-maybe-ignore (oldfun path desc format)
    (let ((re
           (cl-typecase aj/org-annotate-ignored-prefixes
             (string aj/org-annotate-ignored-prefixes)
             ((and list (not null))
              (format "^%s:" (regexp-opt aj/org-annotate-ignored-prefixes))))))
      (if (and re (string-match-p re path))
          (or desc "")
        (funcall oldfun path desc format))))

  (advice-add 'org-annotate-export-note :around #'aj/org-annotate-maybe-ignore)

  ;; I want my text-mode abbreviations to work when I enter a note,
  (defun aj/org-annotate-add-note-advice (fun &rest args)
    (let ((minibuffer-setup-hook
           (cons 'abbrev-mode minibuffer-setup-hook))
          (global-abbrev-table text-mode-abbrev-table)
          (minibuffer-local-map
           (let ((map (make-sparse-keymap)))
             (set-keymap-parent map minibuffer-local-map)
             (define-key map (kbd "C-ö") #'aj/org-annotate-name)
             map)))
      (apply fun args)))

  (advice-add 'org-annotate-add-note :around #'aj/org-annotate-add-note-advice)

  (org-link-set-parameters "note" :follow #'org-insert-link ; following should just edit!
                           :activate-func #'aj/org-annotate-activate-note ; highlight author as well
                           )

  ;; ascii-export
  (defvar org-annotate-ascii-export-function #'aj/org-annotate-export-ascii)

  (defun aj/org-annotate-export-ascii (path desc)
    (let ((path (org-export-data-with-backend path 'ascii nil)))
      (if desc
          (format "❰%s❱%s" path
                  (org-export-data-with-backend desc 'ascii nil))
        (format "❰%s❱" path))))

  ;; add name
  (defvar aj/org-annotate-name-history nil)
  (defun aj/org-annotate-name (&optional name)
    (interactive
     (list (completing-read "Name: " aj/org-annotate-name-history
                            nil nil nil aj/org-annotate-name-history)))
    (save-excursion
      (beginning-of-line)
      (insert (concat "{" name "} "))))

  ;; with author
  (defun aj/org-annotate-activate-note (start end _path _bracketp)
    "Add text properties to display annotation links in a special way."
    (save-match-data
      (save-excursion
        (let (aend descb desce)
          ;; show first and last bracket, with custom face
          (org-fold-region start (1+ start) t 'org-link-description)
          (org-fold-region (1- end) end t 'org-link-description)
          (add-text-properties start (1+ start)
                               `(face org-annotate-bracket-face
                                      display ,(nth 0 org-annotate-special-brackets)))
          (add-text-properties (1- end) end
                               `(face org-annotate-bracket-face
                                      display ,(nth 2 org-annotate-special-brackets)))

          ;; hide "note:"
          (org-fold-region (1+ start) (+ start 7) nil)
          (org-fold-region (1+ start) (+ start 7) t 'org-link)

          (goto-char (+ 7 start))
          ;; author?
          (when-let ((ll (looking-at "{[^}]+}"))
                     (amb (match-beginning 0))
                     (ame (match-end 0)))
            ;; hide first {
            (org-fold-region amb (1+ amb) nil)
            (org-fold-region amb (1+ amb) t 'org-link)
            (add-text-properties (1+ amb) ame '(face (bold italic))) ; bold author
            (add-text-properties (1- ame) ame '(display ":")) ; display } as :
            (goto-char ame))
          (setq aend (point))

          (search-forward-regexp "\\(]]\\|]\\[\\)")

          ;; show note (url) with correct face
          (org-fold-region aend (- (point) 2) t 'org-link-description)
          (add-face-text-property aend (- (point) 2) 'org-annotate-face)

          (when (< (point) end) ; with desc
            (setq descb (1+ (point))
                  desce (- end 2))

            ;; description face (already folded correctly?):
            (add-face-text-property descb desce 'org-annotate-text-face)

            ;; middle brackets
            (org-fold-region (- (point 2)) (1- (point)) t 'org-link-description)
            (add-text-properties (- (point) 2) (1- (point))
                                 `(face org-annotate-bracket-face
                                        display ,(nth 1 org-annotate-special-brackets))))))))
  )


;;; NOTES IN MARGINS!!
(define-minor-mode aj/org-annotate-in-margins-mode
  "Display ‘org-annotate’ notes in margin."
  :global t
  :group 'aj
  (if aj/org-annotate-in-margins-mode
      (progn
        (advice-add 'org-annotate-add-note :after #'aj/org-annotate-add-right-margin)
        (add-hook 'org-mode-hook #'aj/org-annotate-maybe-add-right-margin)
        (org-link-set-parameters "note" :activate-func #'aj/org-annotate-activate-note-margin))
    (advice-remove 'org-annotate-add-note #'aj/org-annotate-add-right-margin)
    (remove-hook 'org-mode-hook #'aj/org-annotate-maybe-add-right-margin)
    (when (eq major-mode 'org-mode)
      (save-buffer)
      (revert-buffer) ;; doesn’t really work, doesn’t clean out the
      ;; text properties appropriately. Usually we need to close and
      ;; reopen the file anyway.
      (set-window-margins (selected-window) nil nil))
    (org-link-set-parameters "note" :activate-func #'aj/org-annotate-activate-note)))


(defface aj/org-annotate-face-margin
  `((t (:inherit variable-pitch :height 0.7)))
  "Face for note links in margin in org-mode."
  :group 'aj)

(defun aj/org-annotate-add-right-margin (&rest _ignore)
  (when (< (or (cdr (window-margins)) 0) 50)
    (set-window-margins (selected-window) nil 50)))

(defun aj/org-annotate-activate-note-margin (start end _path _bracketp)
  "Add text properties to display annotation links in a special way"
  (save-match-data
    (save-excursion
      (goto-char start)
      (when (looking-at org-link-bracket-re)
        (add-text-properties start (1+ start) ;;first bracket
                             '(invisible nil face org-annotate-bracket-face display "/"))

        (add-text-properties (1- (match-beginning 1)) (match-beginning 1) ;; note bracket start
                             '(invisible t))

        ;; note, inline if inline and in margin otherwise
        (if (string-prefix-p "note:inline" (match-string 1))
            (progn
              (add-text-properties (match-beginning 1) (+ 12 (match-beginning 1))
                                   '(invisible nil display "▸ " face org-annotate-bracket-face))
              (add-text-properties (+ 12 (match-beginning 1)) (match-end 1)
                                   '(invisible nil face font-lock-comment-face)))
          (add-text-properties (match-beginning 1) (match-end 1) ; note
                               `(invisible nil face aj/org-annotate-face-margin
                                           display ((margin right-margin)
                                                    ,(concat "·" (buffer-substring-no-properties
                                                                  (+ 5 (match-beginning 1)) (match-end 1)))))))

        (add-text-properties (match-end 1) (1+ (match-end 1)) ;; note bracket end
                             '(invisible t))

        (add-text-properties (1- end) end ; end bracket
                             '(invisible nil face org-annotate-bracket-face display "/"))

        (when (match-end 2) ; make desc visible
          (add-text-properties (1- (match-beginning 2)) (match-beginning 2)
                               '(invisible nil face org-annotate-bracket-face display "·")) ;; start bracket
          (add-text-properties (match-beginning 2) (match-end 2)
                               '(invisible nil face org-annotate-text-face))
          (add-text-properties (match-end 2) (1+ (match-end 2))
                               '(invisible nil face org-annotate-bracket-face display "·")) ;; start bracket
          )))))

(defun aj/org-annotate-maybe-add-right-margin ()
  (org-with-wide-buffer
   (goto-char (point-min))
   (when (search-forward "[[note:" nil t)
     (aj/org-annotate-add-right-margin))))
#+end_src

** Cite with new org-cite
*** Inserting with citar
#+begin_src emacs-lisp
(use-package citar
  :custom
  (citar-at-point-function 'embark-act)
  (citar-file-open-functions '(("html". citar-file-open-external)
                               (t . find-file-other-window)))
  ;; This is slow every time because citeproc parses the bib-file
  ;; Better to adapt the template so we get enough data.
  (citar-format-reference-function #'citar-citeproc-format-reference)

  (citar-crossref-variable nil)
  (citar-ellipsis "…")
  (citar-notes-paths '("~/jobb/anteckningar/"))
  (citar-citeproc-csl-styles-dir org-cite-csl-styles-dir)
  (citar-citeproc-csl-locales-dir org-cite-csl-locales-dir)

  (citar-symbols
   `((file ,(all-the-icons-faicon "file-o" :face 'all-the-icons-green :v-adjust -0.1) . " ")
     (note ,(all-the-icons-material "speaker_notes" :face 'all-the-icons-blue :v-adjust -0.3) . " ")
     (link ,(all-the-icons-octicon "link" :face 'all-the-icons-orange :v-adjust 0.01) . " ")))
  (citar-symbol-separator "  ")

  ;; only the ones I use, no need to do the other work:
  (citar-file-sources (list (list :items #'citar-file--get-from-file-field
                                  :hasitems #'citar-file--has-file-field)))
  (citar-file-parser-functions '(citar-file--parser-default))

  :config
  ;; (setf (alist-get 'preview citar-templates)
  ;;         "${author editor} (${year issued date}) ${title}, \
  ;; ${journal journaltitle publisher container-title collection-title}, ${volume} (${issue}). ${DOI URL}\n")

  (setq citar-citeproc-csl-style "apa.csl") ;; because it’s a defvar...
  (define-key citar-citation-map (kbd "z") (cons "open in zotero" #'aj/org-cite-zotero-follow))
  (define-key citar-citation-map (kbd "F") (cons "open externally" #'aj/citar-open-file-externally))
  (defun aj/citar-open-file-externally (keys)
    "Open citation KEYS in external program."
    (interactive (list (citar-select-refs)))
    (let ((citar-file-open-functions
           '((t . citar-file-open-external))))
      (citar-open-files keys)))

  (defun aj/org-cite-zotero-follow (key)
    "Follow citation KEY to Zotero."
    (request
      "http://127.0.0.1:23119/zotxt/select"
      :params `(("betterbibtexkey" . ,key))))

  ;; (defun aj/citar-fetch-zotero-json ()
  ;;   (call-process-shell-command
  ;;    (format "curl http://127.0.0.1:23119/better-bibtex/export/library?/1/library.json -o %s"
  ;;            (car citar-bibliography))))

  (defun aj/citar-copy-references-new-frame ()
    (aj/run-cmd-in-small-frame 100 20 #'citar-copy-reference "References" t))
  )



;;Nice display (activation) with csl styles
(use-package oc-csl-activate
  :straight (:host github :repo "andras-simonyi/org-cite-csl-activate")
  :demand t
  :custom (org-cite-csl-activate-use-citar-cache t)
  :hook (org-mode . cursor-sensor-mode))

(use-package citar-embark
  :after citar embark
  :config (citar-embark-mode))

(use-package citar-org
  :after (org oc citar)
  :straight nil
  :demand t
  :bind ( :map org-mode-map
          ("C-c C-å" . org-cite-insert))
  :custom
  (citar-org-activation-functions '(org-cite-csl-activate citar-org-activate-keymap))
  (org-cite-insert-processor 'citar)
  (org-cite-follow-processor 'citar)
  (org-cite-activate-processor 'citar)

  :config
  (setf (alist-get
         'key-at-point
         (alist-get '(org-mode) citar-major-mode-functions nil nil #'equal))
        #'aj/citar-org-key-at-point)

  (defun aj/citar-org-key-at-point ()
    "Return key at point for org-cite citation-reference or citekey."
    (or (citar-org-key-at-point)
        (when (org-in-regexp org-element-citation-key-re)
          (cons (substring (match-string 0) 1)
                (cons (match-beginning 0)
                      (match-end 0)))))))

(use-package citar-org-roam
  :after (citar org-roam)
  :straight (:host github :repo "emacs-citar/citar-org-roam")
  :config
  (defun aj/citar-org-roam--create-capture-note (citekey entry)
    "Open or create org-roam node for CITEKEY and ENTRY."
    ;; adapted from https://jethrokuan.github.io/org-roam-guide/#orgc48eb0d
    (let ((title (citar-format--entry
                  "${author editor} (${year issued date}) “${title}”"
                  citekey)))
      (org-roam-capture-
       :templates
       '(("r" "reference" entry "* ${title} %? :#läsning%^g" :if-new
          (file+datetree "~/jobb/anteckningar/anteckningar-%<%Y>.org" month)
          :immediate-finish nil
          :unnarrowed nil))
       :node (org-roam-node-create :title title))
      (org-roam-ref-add (concat "@" citekey))
      (org-id-get-create)))

  (advice-add 'citar-org-roam--create-capture-note :override
              #'aj/citar-org-roam--create-capture-note)
  (citar-org-roam-mode)
  )

#+end_src
*** Add extra group for current refs to citar :ARCHIVE:
#+begin_src emacs-lisp
(use-package citar-current-refs
  :straight (:host 'gitlab :repo "andersjohansson/citar-current-refs")
  :demand t)
#+end_src

*** Follow, with three choices. :ARCHIVE:
I just override ~org-cite-follow~, because these choices are what I always want.
#+begin_src emacs-lisp

;; (advice-add 'org-cite-follow :override #'aj/org-cite-follow)

;; (defun aj/org-cite-follow (datum arg)
;;   (funcall
;;    (cl-case
;;        (read-char-choice
;;         "p. Open pdf\nb. Open in BibTeX\nz. Open in Zotero"
;;         '(?p ?b ?z))
;;      (?p #'aj/org-cite-open-file-via-bibtex)
;;      (?b #'org-cite-basic-goto)
;;      (?z #'org-cite-zotxt-follow))
;;    datum arg))

;; (embark-define-keymap embark-org-cite-map
;;   "Keymap for org-cite commands."
;;   ("p" #'aj/org-cite-open-file-via-bibtex)
;;   ("x" #'aj/org-cite-open-file-externally-via-bibtex)
;;   ("b" #'org-cite-basic-goto)
;;   ("z" #'org-cite-zotxt-follow))

;; (add-to-list 'embark-keymap-alist
;;              '(org-cite . embark-org-cite-map))

;; (defun aj/org-cite-follow (datum arg)
;;   (let ((action
;;          (or (embark--prompt (funcall embark-indicator)
;;                              (embark--action-keymap 'org-cite nil)
;;                              (aj/org-cite-get-citekeys datum)
;;                              ;; (string-join  ", ")
;;                              )
;;              (user-error "Canceled"))))
;;     (funcall action datum arg)))

;; (defun aj/org-cite-get-citekeys (datum)
;;   "Return list of citekeys."
;;   (let ((keys (if (eq 'citation-reference (org-element-type datum))
;;                   (org-element-property :key datum)
;;                 (org-cite-get-references datum t))))
;;     (if (stringp keys)
;;         (list keys)
;;       keys)))

;; (defun aj/org-cite-open-file-via-bibtex (datum _arg)
;;   (bibtex-completion-open-pdf
;;    (aj/org-cite-get-citekeys datum)))

;; (defun aj/org-cite-open-file-externally-via-bibtex (datum _arg)
;;   (let ((bibtex-completion-pdf-open-function #'consult-file-externally))
;;     (bibtex-completion-open-pdf
;;      (aj/org-cite-get-citekeys datum))))


#+end_src


*** Exporting
**** Setting up
#+begin_src emacs-lisp
;; processor registration can’t be autoloaded ... or?
(require 'oc-biblatex)

(setq org-cite-export-processors
      '((latex biblatex)
        (pandoc pandoc)
        (t . (csl "apa.csl" "apa.csl"))))
#+end_src

**** Oc-pandoc, export to markdown with pandoc citations. :ARCHIVE:
See also [[file:../init.org::*ox-md-pandoc-zotero]] for the zotero-conversion export
#+begin_src emacs-lisp
(use-package oc-pandoc
  :straight (:host gitlab :repo "andersjohanssson/org-cite-pandoc"))
#+end_src

** Zotxt (old, moving away from this in favor of org-cite) :ARCHIVE:
For using Zotero reference management in plain text.
https://gitlab.com/egh/zotxt
https://gitlab.com/egh/zotxt-emacs
https://gitlab.com/egh/org-pdcite/

But see also:
https://gitlab.com/andersjohansson/zotxt
https://gitlab.com/andersjohansson/zotxt-emacs
https://gitlab.com/andersjohansson/org-pdcite/

And my custom stuff in
https://gitlab.com/andersjohansson/emacs-zotxt-extra

*** Zotxt configuration :org_async:
#+begin_src emacs-lisp
(use-package zotxt
  :straight (:host gitlab :repo "egh/zotxt-emacs" :depth 'full
                   :fork (:host gitlab :repo "andersjohansson/zotxt-emacs" :branch "ajfixes"))
  :custom (zotxt-default-bibliography-style "apa")
  (zotxt-default-search-method :title-creator-year)
  :commands zotxt--json-read
  :config

  (defconst zotxt-url-base
	"http://127.0.0.1:23119/zotxt"
	"Base URL to contact.")
  ;; funkar det inte med custom?
  (setq zotxt-default-bibliography-style "apa"))

(use-package org-pdcite
  :straight (:depth full :host gitlab :repo "andersjohansson/org-pdcite"
                    :branch "extend-regexes")
  :commands 'org-pdcite-full-cite-parser)

(use-package zotxt-extra
  :straight (:depth full :host gitlab :repo "andersjohansson/emacs-zotxt-extra" :files ("zotxt-extra.el"))
  :after zotxt
  :defer t
  :commands zotxt-extra-maybe-edit-description
  zotxt-extra-link-parse-desc zotxt-extra--replace-consecutive)

(use-package org-zotxt
  :straight nil ;; already installed with zotxt-emacs above
  ;; :hook (org-mode . org-zotxt-mode)
  :defer t
  :init (setq org-zotxt-link-description-style :citekey)
  :commands org-zotxt-extract-link-id-at-point org-zotxt-choose-path
  :config
  ;; don’t try to export:
  (org-link-set-parameters "zotero"
                           :export #'ignore)
  ;;prompt to add page references in quotes
  ;; (advice-add 'org-zotxt-insert-reference-link-to-item
  ;;   		  :after #'zotxt-extra-maybe-edit-description)

  ;; Special fontification, I often manipulate rows of references,
  ;; and then it’s useful to display the outer brackets, for easy
  ;; killing and yanking.

  ;; (org-link-set-parameters "zotero"
  ;;   					   :face 'org-scheduled-today
  ;;                          ;;invisibility is handled in the activate function
  ;;   					   :activate-func #'aj/org-zotxt-activate)

  ;; (defun aj/org-zotxt-activate (start end _path _bracketp)
  ;;   "Add text properties to display zotxt citation links in a good way"
  ;;   ;; it’s always 36 chars, I think: "[[zotero://select/items/1_EEIVB8QC]["
  ;;   (org-fold-region start (1+ start) t 'org-link-description)
  ;;   (org-fold-region (1+ start) (+ start 36) t 'org-link)
  ;;   (org-fold-region (- end 2) (1- end)  t 'org-link)
  ;;   (org-fold-region (1- end) end t 'org-link-description))


  ;;   (advice-add 'org-zotxt-insert-reference-links-to-items :override
  ;;               #'aj/org-zotxt-insert-reference-links-to-items)
  ;;   (defun aj/org-zotxt-insert-reference-links-to-items (items)
  ;;     "Insert links to Zotero ITEMS in buffer.
  ;; Just insert space between multiple links."
  ;;     (cl-loop for i in items do
  ;;              (org-zotxt-insert-reference-link-to-item i)
  ;;              (insert " ")))
  )
#+end_src

*** My own view attachment which parses page numbers and jumps to page :ARCHIVE:
Also a function to get all annotations in a pdf file
#+begin_src emacs-lisp
(with-eval-after-load "org-zotxt"
  (autoload 'pdf-zotxt-quote-acquire-variables "pdf-zotxt-quote")
  (autoload 'pdf-zotxt-quote-goto-page "pdf-zotxt-quote")

  (defun aj/org-zotxt-open-attachment ()
    "Open attachment of Zotero items linked at point."
    (interactive)
    (let* ((item-id (org-zotxt-extract-link-id-at-point))
           (page (plist-get (zotxt-extra-link-parse-desc
                             (aj/org-zotxt-extract-link-desc-at-point))
                            :locator))
           (pagenum (if page (string-to-number page) 1)))
      (deferred:$
       (aj/get-zotxt-item-path-deferred item-id)
       (deferred:nextc it
                       (lambda (path)
                         (org-open-file path 1)
                         ;; Maybe the pagenumber is logical, hopefully it’s stored
                         ;; with pdf-zotxt-quote:
                         (if (pdf-zotxt-quote-acquire-variables)
                             (pdf-zotxt-quote-goto-page page)
                           (pdf-view-goto-page pagenum))))
       (if zotxt--debug-sync (deferred:sync! it)))))


  (bind-key "C-c \" a" #'aj/org-zotxt-open-attachment org-zotxt-mode-map)

  (defun aj/org-zotxt-extract-link-desc-at-point ()
    "Extract the Zotero key of the link at point."
    (let ((ct (org-element-context)))
      (if (eq 'link (org-element-type ct))
          (buffer-substring-no-properties (org-element-property :contents-begin ct)
                                          (org-element-property :contents-end ct))
        nil)))

  (autoload 'pdf-zotxt-quote-get-all-annots-in-buffer-or-file "pdf-zotxt-quote")

  (defun aj/get-zotxt-pdf-annotations ()
    (interactive)
    (let ((item-id (org-zotxt-extract-link-id-at-point)))
      (deferred:$
       (aj/get-zotxt-item-path-deferred item-id)
       (deferred:nextc it
                       (lambda (path)
                         (pdf-zotxt-quote-get-all-annots-in-buffer-or-file path)))
       (deferred:sync! it))))

  (defun aj/get-zotxt-item-path-deferred (item-id)
    (let ((d (deferred:new)))
      (request
        (format "%s/items" zotxt-url-base)
        :params `(("key" . ,item-id) ("format" . "paths"))
        :parser #'zotxt--json-read
        :success (cl-function
                  (lambda (&key data &allow-other-keys)
                    (deferred:callback-post
                     d (org-zotxt-choose-path
                        (cdr (assq 'paths (elt data 0))))))))
      d))
  )
#+end_src

*** Converting back from latex :ARCHIVE:
Some hackish functions
#+begin_src emacs-lisp
(use-package biblatex-to-zotxt
  :straight nil
  :load-path "~/kodat/elisp/biblatex-to-zotxt/"
  :commands biblatex-to-zotxt)
#+end_src

** Zotxt to org cite :ARCHIVE:
Compatibility library for converting old zotxt citations to new org-cite ones.
#+begin_src emacs-lisp
(use-package zotxt-to-org-cite
  :straight (:host 'gitlab :repo "andersjohansson/zotxt-to-org-cite"))
#+end_src

** Export :org_async:
*** Some more or less general export settings
#+begin_src emacs-lisp
(setq org-export-async-init-file (expand-file-name "init-org-async" user-emacs-directory)
      org-odt-styles-file "~/.emacs.d/orgtemp.ott"
      org-export-with-archived-trees nil
      org-export-allow-bind-keywords t
      org-export-with-section-numbers nil ; most commonly
      org-export-with-statistics-cookies nil ; irrelevant for exported "documents"
      org-export-with-smart-quotes t
      org-export-with-toc nil ; I seldom want toc
      org-export-with-tags nil ; tags are mostly internal for me
      org-export-with-timestamps nil
      org-export-with-todo-keywords nil ; mostly don’t want this

      org-export-time-stamp-file nil
      org-export-with-creator nil
      org-html-doctype "html5"
      org-html-html5-fancy t
      org-html-validation-link ""
      org-export-exclude-tags '("noexport" "outline")
      org-ditaa-eps-jar-path "~/lib/DitaaEps.jar"
      org-ditaa-jar-path "/usr/share/ditaa/ditaa.jar"
      org-export-dispatch-use-expert-ui t)
#+end_src
*** New link types for special exports
**** Video
Mostly for html and reveal
#+begin_src emacs-lisp
(org-link-set-parameters "video"
                         :export #'aj/org-video-export
                         :complete #'aj/org-video-complete-link
                         :follow #'aj/org-open-file-with-system)

(defun aj/org-video-export (path desc backend)
  (let ((sources (split-string path "::" t)))
    (cond
     ((org-export-derived-backend-p backend 'html)
      (format "<video title=\"%s\" class=\"stretch\">\n%s\n</video>"
              desc
              (cl-loop for source in sources
                       concat (format "<source src=\"%s\" type=\"%s\">"
                                      (if (or (string-match-p "://" source)
                                              (not (file-name-absolute-p source)))
                                          source
                                        (concat "file://" source))
                                      (mailcap-extension-to-mime
                                       (file-name-extension source))))))
     (t (format "Video: %s" path)))))

(defun aj/org-video-complete-link ()
  (aj/org-complete-link "video:"))
#+end_src

*** Html-export cleanup
An option for "cleaning up" exported html from some org markup. Good for generating clean html for pasting into systems.
#+begin_src emacs-lisp
(defcustom org-aj-export-html-cleanup nil
  "If non-nil, cleanup html from org classes etc.

Named with org prefix to be preserved in org exports."
  :group 'aj
  :type 'boolean
  :safe #'booleanp)

(add-to-list 'org-export-filter-final-output-functions
             #'aj/org-export-html-cleanup)

(defun aj/org-export-html-cleanup (string backend _info)
  (if (and (eq backend 'html)
           org-aj-export-html-cleanup)
      (with-temp-buffer
        (insert string)
        (goto-char (point-min))
        (flush-lines "</?div")
        (cl-loop for r in '(" class=\"org-ul\""
                            " id=\"[^\"]+\"")
                 do
                 (goto-char (point-min))
                 (while (search-forward-regexp r nil t)
                   (replace-match "")))
        (buffer-string))
    string))
#+end_src

*** ox-ascii, don’t fill paragraphs
#+begin_src emacs-lisp
(setq org-ascii-inner-margin 0
      org-ascii-text-width 3000
      org-ascii-charset 'utf-8)

(advice-add 'org-ascii-template--document-title :filter-args #'aj/ox-ascii-fix-title)
(defun aj/ox-ascii-fix-title (info)
  (list (plist-put (car info) :ascii-text-width 72)))
#+end_src

*** org-re-reveal, reveal.js
**** Loading
#+begin_src emacs-lisp
(use-package org-re-reveal
  :straight (org-re-reveal
             :fork (:host gitlab :repo "andersjohansson/org-re-reveal" :branch "preferred-id-fix"))
  :demand t
  :custom
  (org-re-reveal-revealjs-version "4")
  (org-re-reveal-root (concat "file://" (expand-file-name "~/lib/reveal.js")))
  ;; org-re-reveal-mathjax-url "https://cdnjs.cloudflare.com/ajax/libs/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
  (org-re-reveal-plugins '(zoom notes))
  (org-re-reveal-theme "white")
  (org-re-reveal-transition "slide")
  (org-re-reveal-transition-speed "fast")
  (org-re-reveal-default-frag-style "appear")
  (org-re-reveal-center nil)
  (org-re-reveal-progress nil)
  (org-re-reveal-history nil)
  (org-re-reveal-control nil)
  (org-re-reveal-rolling-links nil)
  (org-re-reveal-keyboard t)
  (org-re-reveal-overview nil)
  (org-re-reveal-hlevel 2)
  (org-re-reveal-hashonebasedindex t)
  (org-re-reveal-extra-options "hash: true, navigationMode: 'linear'")

  :config

  ;; To browse slide from current headline.
  (org-export-define-derived-backend
      'revealid 're-reveal
    :menu-entry
    '(?v 2
         ((?c "As file, browse at current HL"
              aj/org-reveal-export-to-html-browse))))

  (defun aj/org-reveal-export-to-html-browse (&optional async subtreep visible-only body-only ext-plist)
    "Export current buffer to a reveal.js file, browse at current HL."
    (interactive)
    (let (created-id)
      (unwind-protect
          (let* ((slide-id
                  (unless (org-before-first-heading-p)
                    (or (org-entry-get (point) "custom_id")
                        (org-entry-get (point) "id")
                        (progn (setq created-id t) (org-id-get-create)))))
                 (file-url (browse-url-file-url
                            (expand-file-name
                             (org-re-reveal-export-to-html
                              async subtreep visible-only body-only ext-plist)))))
            (browse-url (concat file-url (when slide-id
                                           (concat "#slide-" slide-id)))))
        (when created-id (org-entry-delete (point) "id"))))))
#+end_src

**** reveal - org-annotate-style
#+begin_src emacs-lisp
(with-eval-after-load "org-re-reveal"
  (defvar org-annotate-reveal-export-function
    #'aj/org-annotate-export-html-tooltip
    "The reveal export style for Org notes, as a symbol.")

  (defun aj/org-annotate-export-html-tooltip (path desc)
    (format "<span style=\"font-size:.5em;font-style:italic;color:#a00\">[%s]</span> %s" path (or desc ""))))
#+end_src

**** reveal: Commands for exporting, starting server, and displaying presentations via server :ARCHIVE:
#+begin_src emacs-lisp
(defvar aj/path-to-revealjs "~/lib/reveal.js/")

(org-export-define-derived-backend
    'reveallink 're-reveal
  :menu-entry
  '(?v 2
       ((?x "As file linked to server"
            aj/org-reveal-export-to-html-link)
        (?c "As linked file and browse"
            aj/org-reveal-export-to-html-link-and-browse)
        (?z "Link, and package for publish"
            aj/org-reveal-export-to-html-link-and-package))))

(defconst aj/revealjs-base-url "http://localhost:8000/")

(defun aj/org-reveal-export-to-html-link
	(&optional async subtreep visible-only body-only ext-plist)
  "Export current buffer to a reveal.js and link the folder to server dir."
  (interactive)
  (let* ((fn (expand-file-name (org-re-reveal-export-to-html async subtreep visible-only body-only ext-plist)))
         (fnnd (file-name-nondirectory fn))
         (dir (file-name-directory fn))
		 (dirname (directory-file-name dir))
         (nextlastdir (file-name-nondirectory
                       (directory-file-name
                        (file-name-directory
                         dirname))))
	     (lastdir (file-name-nondirectory
                   dirname))
         (linkeddir (concat aj/path-to-revealjs nextlastdir "-" lastdir))
	     (newfile (concat linkeddir "/" fnnd)))
	(make-symbolic-link dir linkeddir t)
	newfile))

(defvar aj/org-reveal-current-url nil)
(defvar aj/org-reveal-last-url nil)
(defvar aj/org-reveal-current-file nil)
(defvar aj/org-reveal-current-slide-id nil)
(defvar-local aj/org-reveal-url-parameters "")
(put 'aj/org-reveal-url-parameters 'safe-local-variable #'stringp)

(defun aj/org-reveal-export-to-html-link-and-browse (&optional async subtreep visible-only body-only ext-plist)
  "Export current buffer to a reveal.js, launch server and browse file"
  (interactive)
  (let (created-id)
    (unwind-protect
        (progn
          (setq ;; aj/org-reveal-current-url nil
           aj/org-reveal-current-slide-id
           (unless (org-before-first-heading-p)
             (or (org-entry-get (point) "custom_id")
                 (org-entry-get (point) "id")
                 (progn (setq created-id t) (org-id-get-create))))
           aj/org-reveal-current-file
           (expand-file-name
            ;;export:
            (aj/org-reveal-export-to-html-link async subtreep visible-only body-only ext-plist))
           ;; form url:
           aj/org-reveal-current-url
           (concat aj/revealjs-base-url (file-name-nondirectory (directory-file-name (file-name-directory aj/org-reveal-current-file)))
                   "/" (file-name-nondirectory aj/org-reveal-current-file)
                   aj/org-reveal-url-parameters
                   (when aj/org-reveal-current-slide-id
                     (concat "#slide-" aj/org-reveal-current-slide-id)))
           aj/org-reveal-last-url aj/org-reveal-current-url)
          ;; browse:
          (aj/org-reveal-try-server-browse-url aj/org-reveal-current-url))
      (setq aj/org-reveal-current-slide-id nil
            ;; aj/org-reveal-current-url nil
            )
      (when created-id (org-entry-delete (point) "id")))))

(defun aj/org-reveal-try-server-browse-url (&optional url server-running)
  (setq aj/org-reveal-current-url ; used in callback function below
        (or url aj/org-reveal-current-url))
  (if server-running
      (request (url-encode-url aj/org-reveal-current-url)
        :success #'aj/org-reveal-browse-current-url
        :error (cl-function (lambda (&key _data &allow-other-keys)
                              (message "Couldn’t access %s"
                                       aj/org-reveal-current-url))))
    (request (url-encode-url aj/revealjs-base-url)
      :success #'aj/org-reveal-browse-current-url
      :error #'aj/org-reveal-try-server-start)))

(cl-defun aj/org-reveal-browse-current-url (&key _data &allow-other-keys)
  (browse-url
   aj/org-reveal-current-url)
  (setq aj/org-reveal-current-url nil))

(cl-defun aj/org-reveal-browse-current-file (&key _data &allow-other-keys)
  (browse-url-of-file
   aj/org-reveal-current-file))

(cl-defun aj/org-reveal-try-server-start (&key _data &allow-other-keys)
  (let ((proc
         (start-process "revealserver"
                        (generate-new-buffer "revealserver")
                        "aj-startreveal")))
    ;; (sleep-for 3)
    (set-process-filter
     proc
     (lambda (process output)
       (when (string-match-p "Running server" output)
         (aj/org-reveal-try-server-browse-url aj/org-reveal-current-url t)
         (set-process-filter process nil))))
    (accept-process-output proc 5)))

(defun aj/org-reveal-start-server ()
  (interactive)
  (setq aj/org-reveal-current-url aj/org-reveal-last-url)
  (aj/org-reveal-try-server-start :data nil))



(defun aj/org-reveal-export-to-html-link-and-package (&optional async subtreep visible-only body-only ext-plist)
  "Export current buffer to reveal.js, package for publishing."
  (interactive)
  (make-directory "publish" 'noerror)
  (let* ((copydir (expand-file-name "publish/"))
         (exportfile (expand-file-name (aj/org-reveal-export-to-html-link async subtreep visible-only body-only ext-plist)))
         (default-directory (file-name-directory exportfile)))
    (cl-loop for f in
             (directory-files "../assets" 'absolute
                              (rx (or (seq bol "webfont-")
                                      (seq (or ".css" ".js" ".svg") eol))))
             do (make-symbolic-link f copydir 'overwrite))
    (make-symbolic-link (expand-file-name "../plugin") copydir 'overwrite)

    (with-temp-buffer
      (insert-file-contents exportfile)
      (goto-char (point-min))
      (while (search-forward-regexp
              (rx (or
                   (seq (or "src=" "href=" "data-background=")
                        ?\"
                        (group-n 1 (+ (not ?\")))
                        ?\")
                   (seq "src:" (* " ")
                        ?'
                        (group-n 1 (+ (not ?')))
                        ?')))
              nil t)
        (let ((fn (match-string 1)))
          (when (file-exists-p fn)
            (let ((fnd (file-name-nondirectory fn)))
              (replace-match fnd t t nil 1)
              (make-symbolic-link (expand-file-name fn) copydir 'overwrite)))))

      (write-file (file-name-concat copydir "index.html")))
    ))
#+end_src

**** Mode and hydra for help with input
#+begin_src emacs-lisp
(with-eval-after-load 'org-re-reveal
  (define-minor-mode aj/org-reveal-mode
    "Minor mode with some custom keybindings for help in creating org-reveal presentations"
    :keymap `((,(kbd "C-c C-ö") . aj/hydra-org-reveal-templates/body)))

  (defvar aj/org-reveal-classes
    '(("r-stack")
      ("r-stretch")
      ("r-fit-text")
      ("fillheight")
      ("large")
      ("Large")
      ("LARGE")
      ("huge")
      ("small")
      ("footnotesize")
      ("tiny")
      ("larger")
      ("much-larger")
      ("very-much-larger")
      ("smaller")
      ("much-smaller")
      ("extratopmargin")
      ("attrib: picture attributions" )
      ("whiteoverlay: overlay over background" )
      ("pic-row: for pictures in row")
      ("shadow: box shadow")
      ("shapeshadow: shadow for complex shapes")
      ( "columns: wrapper for flexing elements")
      ("vertical-center")
      ("center-emphasize")
      ("bottom-note")
      ("random-container" "container for randomly placed elements")
      ("absolute-random: elements inside random-container")
      ("fade-out: Fragment: Start visible, fade out")
      ("fade-up: Fragment: Slide up while fading in")
      ("fade-down: Fragment: Slide down while fading in")
      ("fade-left: Fragment: Slide left while fading in")
      ("fade-right: Fragment: Slide right while fading in")
      ("fade-in-then-out: Fragment: Fades in, then out on the next step")
      ("fade-in-then-semi-out: Fragment: Fades in, then to 50% on the next step")
      ("grow: Fragment: Scale up")
      ("shrink: Fragment: Scale down")
      ("strike: Fragment: Strike through")
      ("highlight-red: Fragment: Turn text red")
      ("highlight-green: Fragment: Turn text green")
      ("highlight-blue: Fragment: Turn text blue")
      ("highlight-bold: Fragment: Turn text bold")
      ("highlight-current-red: Fragment: Turn text red, then back to original on next step")
      ("highlight-current-green: Fragment: Turn text green, then back to original on next step")
      ("highlight-current-blue: Fragment: Turn text blue, then back to original on next step")
      ("highlight-current-bold: Fragment: Turn text bold, then back to original on next step"))
    "Classes for elements in reveal.js presentations")

  (defhydra aj/hydra-org-reveal-templates (:color blue :columns 4)
    "Reveal templates"
    ("+" (aj/org-insert-element-attributes "#+attr_reveal: :frag (t)") "Piecewise list")
    ("f" (aj/org-insert-element-attributes "#+attr_reveal: :frag t") "Appear (frag)")
    ("n" (aj/org-keyword-expand "n") "Notes")
    ("i" (aj/org-insert-element-attributes (format "#+attr_reveal: :frag t :frag_idx !!" )) "Frag id")
    ("s" (insert "#+reveal: split") "Split frame")
    ("c" (aj/org-insert-element-attributes
          (concat "#+attr_html: :class "
                  (mapconcat
                   (lambda (c)
                     (car (split-string c ":" t)))
                   (completing-read-multiple
                    "Class: " aj/org-reveal-classes)
                   " ")))
     "Insert html class for element")
    ("x" (org-set-property "html_headline_class"
                           (mapconcat
                            (lambda (c)
                              (car (split-string c ":" t)))
                            (completing-read-multiple
                             "Class: " aj/org-reveal-classes)
                            " "))
     "Add class on headline")
    ("C" (progn (org-set-property "reveal_data_state" "centered-headline")
                (org-toggle-tag "centered_headline" 'on))
     "Centered headline")
    ("S" (progn (org-set-property "reveal_data_state" "split-headline")
                (org-toggle-tag "split_headline" 'on))
     "Split headline")

    ("F" (insert (completing-read "Frag style" '(grow shrink roll-in fade-out highlight-red highlight-green highlight-blue appear))) "Frag style")
    ("H" (insert "#+reveal_html: ") "HTML")
    ("b" (org-set-property "reveal_background"
                           (file-relative-name
                            (read-file-name "Background image: "
                                            nil nil nil nil)))
     "Background image")
    ("B" (org-set-property "reveal_background_trans"
                           (completing-read "Transition: "
                                            '("none" "fade" "slide" "convex" "concave" "zoom")))
     "Background image-transition")
    ("y" (aj/org-insert-element-attributes "#+attr_html: :style font-size: 0.9em;") "Style element etc.")
    ("p" (insert (format
                  "#+attr_html: :class stretch\n%s"
                  (with-temp-buffer (org-insert-link '(4) nil "") (buffer-string))))
     "Picture with stretch")
    ("z" (insert "#+html: <div id=\"zotxtbibliography\"></div>") "Bibliography")
    ("N" (org-toggle-tag "notitle") "No title headline")
    ("q" nil)))
#+end_src

**** COMMENT Fix file paths when inserting links in ~aj-org-reveal-mode~ :ARCHIVE:
Fungerar inte på grund av relativiseringen av sökvägar i slutet av org-insert-link
#+begin_src emacs-lisp
;; (advice-add 'org-link-complete-file :filter-return #'aj/org-reveal-link-fix-path)

;; (defun aj/org-reveal-link-fix-path (filepath)
;;   (if aj/org-reveal-mode
;;       (string-replace "/home/aj/jobb/presentationer/" "../" filepath)
;;     filepath))
#+end_src

**** Override ~org-html--wrap-image~ to put classes etc. on figure
#+begin_src emacs-lisp
(defvar aj/reveal-wrap-classes
  '("appear" "grow" "shrink" "fade" "fade-up" "fade-down"
	"fade-left" "fade-right" "fade-in-then-out"
	"fade-in-then-semi-out" "highlight-current-blue"
	"highlight-red" "highlight-green" "highlight-blue"
    "fragment" "stretch" "fillheight" "fh40" "fh50" "fh60" "fh70" "fh80"
    "captionasattrib"))

(defvar aj/reveal-wrap-attributes
  '("style" "data-fragment-index"))

(advice-add 'org-html--wrap-image :override #'aj/org-html--wrap-image)

(defun aj/org-html--wrap-image (contents info &optional caption label)
  "Wrap CONTENTS string within an appropriate environment for images.
INFO is a plist used as a communication channel.  When optional
arguments CAPTION and LABEL are given, use them for caption and
\"id\" attribute."
  (let ((html5-fancy (org-html--html5-fancy-p info))
        attributes
        classes)
    (when (libxml-available-p)
      (with-temp-buffer
        (insert contents)
        (let ((img ; wrapped in html -> body
               (car (dom-children
                     (car (dom-children
                           (libxml-parse-html-region
                            (point-min) (point-max))))))))
          (cl-loop for (n . v) in (dom-attributes img)
                   when (member n aj/reveal-wrap-attributes)
                   do (push (format "%s=\"%s\"" n v) attributes)
                   (dom-remove-attribute img n))
          (when-let ((classattr (dom-attr img 'class)))
            (cl-loop for c in (split-string classattr)
                     if (member c aj/reveal-wrap-classes)
                     do (push c classes)
                     else collect c into saved
                     finally do (dom-set-attribute img 'class (string-join saved " "))))

          (delete-region (point-min) (point-max))
          (dom-print img)
          (setq contents (encode-coding-string (buffer-string) 'utf-8)))))
    (format (if html5-fancy "\n<figure%s>\n%s%s\n</figure>"
	          "\n<div%s class=\"figure\">\n%s%s\n</div>")
	        ;; ID.
	        (concat (if (org-string-nw-p label) (format " id=\"%s\"" label) "")
                    (when attributes
                      (concat " " (string-join attributes " ")))
                    (when classes
                      (concat " class=\"" (string-join classes " ") "\"")))
	        ;; Contents.
	        (if html5-fancy contents (format "<p>%s</p>" contents))
	        ;; Caption.
	        (if (not (org-string-nw-p caption)) ""
	          (format (if html5-fancy "\n<figcaption>%s</figcaption>"
			            "\n<p>%s</p>")
		              caption)))))
#+end_src


**** Empty headline
#+begin_src emacs-lisp
(add-hook 'org-export-filter-parse-tree-functions #'aj/org-reveal-empty-headline-title)

(defun aj/org-reveal-empty-headline-title (data backend info)
  (unless (eq backend 'org-notes)
    (org-element-map data 'headline
      (lambda (h)
        (when (member "notitle" (org-element-property :tags h))
          (org-element-put-property h :title nil)
          (org-element-put-property
           h :tags (delete "notitle" (org-element-property :tags h)))
          (org-element-put-property h :REVEAL_DATA_STATE "notitle")))
      info nil))
  data)

(add-hook 'org-export-filter-final-output-functions #'aj/org-reveal-prune-empty-headlines)

(defun aj/org-reveal-prune-empty-headlines (string backend _info)
  (if (eq backend 're-reveal)
      (replace-regexp-in-string "<h2[^>]+></h2>" "" string)
    string))
#+end_src

**** Use ~data-src~ instead of ~src~ for images etc.
#+begin_src emacs-lisp
(defun aj/org-reveal-lazy-load-links (string backend info)
  (when (and (org-export-derived-backend-p backend 'reveal 're-reveal)
             (not (plist-get info :reveal-single-file))
             (string-match-p "^<\\(img\\|video\\|iframe\\)" string))
    (replace-regexp-in-string "src=" "data-src=" string nil t)))

(add-to-list 'org-export-filter-link-functions #'aj/org-reveal-lazy-load-links)
#+end_src

**** Enable citations in quote blocks captions
Now we can add captions to quote blocks. They are added to the cite attribute (which I have css for displaying). Works well with citations!
#+begin_src emacs-lisp
(defun aj/org-html-quote-block (quote-block contents info)
  "Transcode a QUOTE-BLOCK element from Org to HTML.
CONTENTS holds the contents of the block.  INFO is a plist
holding contextual information.
We also allow for a caption, which will be put in a cite attribute."
  (format "<blockquote%s>\n%s</blockquote>"
	      (let* ((reference (org-html--reference quote-block info t))
		         (attributes (org-export-read-attribute :attr_html quote-block))
                 (caption (org-export-get-caption quote-block))
                 (attributes (if (or (not reference) (plist-member attributes :id))
			                     attributes
		                       (plist-put attributes :id reference)))
                 (attributes (if caption
                                 (plist-put attributes :cite
                                            (replace-regexp-in-string
                                             "</?a[^>]*>" ""
                                             (org-trim (org-export-data caption info))))
                               attributes))
		         (attr (org-html--make-attribute-string attributes)))
	        (if (org-string-nw-p attr) (concat " " attr) ""))
	      contents))

;; Let’s just redefine the transcoder for the html backend.
(setf (alist-get 'quote-block
                 (org-export-backend-transcoders (org-export-get-backend 'html)))
      #'aj/org-html-quote-block)
#+end_src

**** Let center have attributes
#+begin_src emacs-lisp
(defun aj/org-html-center-block (center-block contents _info)
  "Transcode a CENTER-BLOCK element from Org to HTML.
CONTENTS holds the contents of the block.  INFO is a plist
holding contextual information."
  (let* ((attributes (org-export-read-attribute :attr_html center-block))
         (attributes (plist-put attributes :class (concat (plist-get attributes :class) " org-center")))
         (attr (org-html--make-attribute-string attributes)))
    (format "<div%s>\n%s</div>"
            (if (org-string-nw-p attr) (concat " " attr) "")
            contents)))

;; Let’s just redefine the transcoder for the html backend.
(setf (alist-get 'center-block
                 (org-export-backend-transcoders (org-export-get-backend 'html)))
      #'aj/org-html-center-block)
#+end_src

**** Bibliograhy -- and splitting

Split bibliography across reveal.js slides. We install an output filter for doing this.
#+begin_src emacs-lisp
(use-package org-re-reveal-citeproc
  :custom (org-re-reveal-citeproc-bib "references")
  :config
  (add-to-list 'org-export-filter-paragraph-functions
               #'org-re-reveal-citeproc-filter-cite))

(defun aj/org-reveal-split-bibliography (string backend _info)
  (if (org-export-derived-backend-p backend 're-reveal 'reveal)
      (with-temp-buffer
        (insert string)
        (goto-char (point-min))
        ;; we assume just one bibliography
        (when (search-forward "<div class=\"csl-bib-body\">" nil t)
          (cl-loop with i = 0
                   with positions = nil
                   while (search-forward "<div class=\"csl-entry\">" nil t) do
                   (cl-incf i)
                   (when (eq 0 (mod i 6))
                     (push (match-beginning 0) positions))
                   finally do ;; this is from the bottom, so pos is correct
                   (cl-loop for pos in positions do
                            (goto-char pos)
                            (insert "</div></section><section><h2>References cont.</h2><div class=\"csl-bib-body\">"))))
        (buffer-string))
    string))

(add-to-list 'org-export-filter-final-output-functions #'aj/org-reveal-split-bibliography)

#+end_src

**** Possibly add end-slide if using a certain template
For my university template, add a final slide with the logo.
#+begin_src emacs-lisp
(add-hook 'org-export-filter-parse-tree-functions #'aj/org-reveal-add-end-slide)

(defun aj/org-reveal-add-end-slide (data backend info)
  (when (and (eq backend 're-reveal)
             (string-search "ajchalmers.css" (plist-get info :reveal-extra-css)))
    (org-element-adopt-elements data
      (org-element-create
       'headline
       '(:REVEAL_DATA_STATE "chalmers-final-slide" :level 1 :raw-value ""))))
  data)
#+end_src
**** Rewrite image-paths for inclusion. :ARCHIVE:
#+begin_src emacs-lisp
(add-to-list 'org-export-filter-parse-tree-functions
             #'aj/org-reveal-rewrite-image-file-paths)

(defun aj/org-reveal-rewrite-image-file-paths (tree backend info)
  (if (org-export-derived-backend-p backend 're-reveal)
      (org-element-map tree 'link
        (lambda (l)
          (when (equal "file" (org-element-property :type l))
            (let ((path (org-element-property :path l)))
              (when (string-match "^\\(?:/home/aj\\|~\\)/jobb/presentationer/bilder/\\(.+\\)" path)
                (org-element-put-property
                 l :path
                 (replace-match "../bilder/\\1" nil nil path))))))
        info))
  tree)

#+end_src
**** Rewrite image-paths, using compressed files for html embedding (~org-re-reveal-single-file~).
#+begin_src emacs-lisp
(defvar aj/org-re-reveal-compressed nil
  "Use compressed files when non-nil.")

;; (defun aj/org-re-reveal-use-compressed-files1 (backend)
;;   (when
;;       (and aj/org-re-reveal-compressed
;;            (org-export-derived-backend-p backend 're-reveal))

;;     (while (search-forward "bilder/lego" nil t)
;;       (replace-match "bilder/lego-comp"))))

;; (add-hook 'org-export-before-parsing-hook
;;           #'aj/org-re-reveal-use-compressed-files)

(add-hook 'org-export-filter-parse-tree-functions
          #'aj/org-re-reveal-use-compressed-files)

(defun aj/org-re-reveal-use-compressed-files (tree backend info)
  (when (and aj/org-re-reveal-compressed
             (org-export-derived-backend-p backend 're-reveal))
    (org-element-map tree '(link)
      (lambda (link)
        (when (equal "file" (org-element-property :type link))
          (let* ((path (org-element-property :path link))
                 (ext (file-name-extension path))
                 (nonext (file-name-sans-extension path))
                 (comp (concat nonext "_comp." ext)))
            (when (file-exists-p comp)
              (org-element-put-property link :path comp)))))
      info))
  tree)
#+end_src
**** Exporting tree of notes
#+begin_src emacs-lisp
(defun aj/org-notes-export (async subtreep visible-only body-only)
  (org-export-to-buffer 'org-notes "*org-notes*"
    async subtreep visible-only body-only nil #'org-mode))

(defun aj/org-notes-filter-parse-tree (tree backend info)
  (when (eq backend 'org-notes)
    (org-element-map tree (append org-element-all-elements org-element-all-objects)
      (lambda (e)
        (unless (or (member (org-element-type e) '(headline section))
                    (when-let ((sb (org-element-lineage e '(special-block) t)))
                      (string= (downcase (org-element-property :type sb)) "notes")))
          (org-element-extract-element e)))
      info))
  tree)

(add-to-list 'org-export-filter-parse-tree-functions #'aj/org-notes-filter-parse-tree)

(require 'ox-org)
(org-export-define-derived-backend 'org-notes 'org
  :menu-entry '(?v 3
                   ((?n "As notes"
                        aj/org-notes-export)))
  :translate-alist
  '((special-block . aj/org-notes-special-block)))

(defun aj/org-notes-special-block (special-block contents _info)
  "Transcode a SPECIAL-BLOCK element from Org to Org if it is notes."
  (when (string= (downcase (org-element-property :type special-block))
                 "notes")
    contents))

;; (defun aj/org-get-all-notes ()
;;   (interactive)
;;   (let (notes)
;;     (org-element-map (org-element-parse-buffer) '(special-block)
;;       (lambda (sb)
;;         (when (string= (downcase (org-element-property :type sb)) "notes")
;;           (push (concat
;;                  "* "
;;                  (org-export-data-with-backend
;;                   (org-element-property
;;                    :title
;;                    (org-export-get-parent-headline sb))
;;                   'org nil)
;;                  ;; (org-export-string-as
;;                  ;;  (org-element-property :title (org-export-get-parent-headline sb))
;;                  ;;  'org t)
;;                  "\n"
;;                  (buffer-substring-no-properties
;;                   (org-element-property :contents-begin sb)
;;                   (org-element-property :contents-end sb)))
;;                 notes))))
;;     (pop-to-buffer (generate-new-buffer "*org notes*"))
;;     (insert (string-join notes "\n\n"))
;;     (goto-char (point-min))
;;     (org-mode)))
#+end_src

**** Minify css and js
#+begin_src emacs-lisp
(defun aj/org-re-reveal--read-file (file)
  (with-temp-buffer
    (cond
     ((string-match "\\.css$" file)
      (call-process-shell-command (concat "python -mrcssmin <" file) nil t))
     ((string-match "\\.js$" file)
      (call-process-shell-command (concat "python -mrjsmin <" file) nil t))
     (t (insert-file-contents-literally file)))
    (buffer-string)))

(advice-add 'org-re-reveal--read-file :override #'aj/org-re-reveal--read-file)
#+end_src
*** Ignored drawers
#+begin_src emacs-lisp
(with-eval-after-load 'ox
  (setq org-export-with-drawers '(not "LOGBOOK" "IGNORE")))
#+end_src

*** Give exported subtrees automatic file names from headline if not present
Advice which will add a generated EXPORT_FILE_NAME if it does not exist.
There are two mechanisms for getting filenames, ~org-export--get-subtree-options~ and ~org-export-output-file-name~. I’m unsure if the former is meaningful, as the latter is used for most calls to ~org-export-to-file~, where the filename is really used, in the exporters.
#+begin_src emacs-lisp
;; (advice-add 'org-export--get-subtree-options :filter-return #'aj/org-export-add-subtree-filename)

;; (defun aj/org-export-add-subtree-filename (plist)
;;   "Adds a filename derived from the heading name if no filename
;; is defined the subtree during org subtree export."
;;   (unless (plist-get plist :export-file-name)
;;     (plist-put plist :export-file-name
;;                (aj/org-export-headline-filename
;;                 (car (plist-get plist :title))))))

(advice-add 'org-export-output-file-name
            :around #'aj/org-export-return-subtree-filename)

(defun aj/org-export-return-subtree-filename (fun ext &optional subtreep pub-dir)
  "Adds a filename derived from the heading name if no filename
is defined for the subtree during org subtree export."
  (if (and (not pub-dir) subtreep (not (org-entry-get nil "EXPORT_FILE_NAME")))
      (concat (aj/org-export-headline-filename
               (org-get-heading t t t t))
              ext)
    (funcall fun ext subtreep pub-dir)))


(defvar reftex-derive-label-parameters)
(autoload 'reftex-string-to-label "reftex-ref")
(defun aj/org-export-headline-filename (headline)
  (let ((reftex-derive-label-parameters
         '(5 30 nil 'maybeshorten "-"
             ("the" "on" "in" "off" "a" "for" "by" "of" "and" "is" "to")
             t)))
    (concat "./" (reftex-string-to-label headline))))

#+end_src
*** Helper functions
**** For inserting list attributes
#+begin_src emacs-lisp
(defun aj/org-insert-element-attributes (attr)
  (save-excursion
    (if-let ((p (org-in-item-p))
             (tp (org-list-get-top-point (org-list-struct))))
        (progn
          (goto-char tp)
          (open-line 1)
          (insert attr))
      (unless (looking-at-p "^$")
        (org-backward-paragraph)
        (open-line 1))
      (insert attr))))
#+end_src

**** CHECK For special completion in custom link types
#+begin_src emacs-lisp
(defun aj/org-complete-link (rep)
  "Helper function to enable correct handling of relative/absolute
paths also for links of special types."
  (let ((link (org-link-complete-file)))
    (when (string-match "^\\(file:\\)\\(.*\\)" link)
      (let* ((type (match-string 1 link))
             (origpath (match-string 2 link))
             (path (aj/org-filename-possibly-relative origpath)))
        (setq link (concat type path))))
    (replace-regexp-in-string "file:" rep link)))

(defun aj/org-filename-possibly-relative (path)
  "Copy of parts of org-insert-link to determine whether a filename
should be relativized or not. Returns the possibly relativized filename"
  (let ((case-fold-search nil))
    (cond
     ((eq org-link-file-path-type 'absolute)
      (abbreviate-file-name (expand-file-name path)))
     ((eq org-link-file-path-type 'noabbrev)
      (expand-file-name path))
     ((eq org-link-file-path-type 'relative)
      (file-relative-name path))
     (t
      (save-match-data
        (if (string-match (concat "^" (regexp-quote
                                       (expand-file-name
                                        (file-name-as-directory
                                         default-directory))))
                          (expand-file-name path))
            ;; We are linking a file with relative path name.
            (substring (expand-file-name path)
                       (match-end 0))
          (expand-file-name path)))))))
#+end_src

*** Redefine ~org-export--skip-p~ to avoid comments introducing paragraph breaks
#+begin_src emacs-lisp
(el-patch-feature ox)
(with-eval-after-load 'ox

  (el-patch-defun org-export--skip-p (datum options selected excluded)
    "Non-nil when element or object DATUM should be skipped during export.
OPTIONS is the plist holding export options.  SELECTED, when
non-nil, is a list of headlines or inlinetasks belonging to
a tree with a select tag.  EXCLUDED is a list of tags, as
strings.  Any headline or inlinetask marked with one of those is
not exported."
    (cl-case (org-element-type datum)
      ((comment comment-block)
       ;; Skip all comments and comment blocks.  Make to keep maximum
       ;; number of blank lines around the comment so as to preserve
       ;; local structure of the document upon interpreting it back into
       ;; Org syntax.
       (let* ((previous (org-export-get-previous-element datum options))
	          (before (or (org-element-property :post-blank previous) 0))
	          (after (or (org-element-property :post-blank datum) 0)))
         (when previous
	       (org-element-put-property previous :post-blank (max before after (el-patch-remove 0)))))
       t)
      (clock (not (plist-get options :with-clocks)))
      (drawer
       (let ((with-drawers-p (plist-get options :with-drawers)))
         (or (not with-drawers-p)
	         (and (consp with-drawers-p)
		          ;; If `:with-drawers' value starts with `not', ignore
		          ;; every drawer whose name belong to that list.
		          ;; Otherwise, ignore drawers whose name isn't in that
		          ;; list.
		          (let ((name (org-element-property :drawer-name datum)))
		            (if (eq (car with-drawers-p) 'not)
		                (member-ignore-case name (cdr with-drawers-p))
		              (not (member-ignore-case name with-drawers-p))))))))
      (fixed-width (not (plist-get options :with-fixed-width)))
      ((footnote-definition footnote-reference)
       (not (plist-get options :with-footnotes)))
      ((headline inlinetask)
       (let ((with-tasks (plist-get options :with-tasks))
	         (todo (org-element-property :todo-keyword datum))
	         (todo-type (org-element-property :todo-type datum))
	         (archived (plist-get options :with-archived-trees))
	         (tags (org-export-get-tags datum options nil t)))
         (or
	      (and (eq (org-element-type datum) 'inlinetask)
	           (not (plist-get options :with-inlinetasks)))
	      ;; Ignore subtrees with an exclude tag.
	      (cl-some (lambda (tag) (member tag excluded)) tags)
	      ;; When a select tag is present in the buffer, ignore any tree
	      ;; without it.
	      (and selected (not (memq datum selected)))
	      ;; Ignore commented sub-trees.
	      (org-element-property :commentedp datum)
	      ;; Ignore archived subtrees if `:with-archived-trees' is nil.
	      (and (not archived) (org-element-property :archivedp datum))
	      ;; Ignore tasks, if specified by `:with-tasks' property.
	      (and todo
	           (or (not with-tasks)
		           (and (memq with-tasks '(todo done))
		                (not (eq todo-type with-tasks)))
		           (and (consp with-tasks) (not (member todo with-tasks))))))))
      ((latex-environment latex-fragment) (not (plist-get options :with-latex)))
      (node-property
       (let ((properties-set (plist-get options :with-properties)))
         (cond ((null properties-set) t)
	           ((consp properties-set)
	            (not (member-ignore-case (org-element-property :key datum)
				                         properties-set))))))
      (planning (not (plist-get options :with-planning)))
      (property-drawer (not (plist-get options :with-properties)))
      (statistics-cookie (not (plist-get options :with-statistics-cookies)))
      (table (not (plist-get options :with-tables)))
      (table-cell
       (and (org-export-table-has-special-column-p
	         (org-export-get-parent-table datum))
	        (org-export-first-sibling-p datum options)))
      (table-row (org-export-table-row-is-special-p datum options))
      (timestamp
       ;; `:with-timestamps' only applies to isolated timestamps
       ;; objects, i.e. timestamp objects in a paragraph containing only
       ;; timestamps and whitespaces.
       (when (let ((parent (org-export-get-parent-element datum)))
	           (and (memq (org-element-type parent) '(paragraph verse-block))
		            (not (org-element-map parent
			                 (cons 'plain-text
				                   (remq 'timestamp org-element-all-objects))
			               (lambda (obj)
			                 (or (not (stringp obj)) (org-string-nw-p obj)))
			               options t))))
         (cl-case (plist-get options :with-timestamps)
	       ((nil) t)
	       (active
	        (not (memq (org-element-property :type datum) '(active active-range))))
	       (inactive
	        (not (memq (org-element-property :type datum)
		               '(inactive inactive-range))))))))))
#+end_src


*** ODT-export

***
**** noindent-style for odt paragraphs and spaced paragrahs in lists.
#+begin_src emacs-lisp
(defvar-local aj/org-export-odt-noindent nil
  "Use noindent style for first paragraph after headline in odt export.
Use spaced paragraphs in lists")

(defun aj/org-odt-export-noindent (data backend info)
  (when (and aj/org-export-odt-noindent
             (org-export-derived-backend-p backend 'odt))
    (org-element-map data 'paragraph
      (lambda (p)
        (let ((par (org-element-type (org-export-get-parent p)))
              (prev (org-element-type (org-export-get-previous-element p info))))
          (cond
           ((eq par 'item)
            (org-element-put-property p :style "spaced-paragraph"))
           ((and
             (eq par 'section)
             (member prev '(nil table plain-list)))
            (org-element-put-property p :style "noindent"))
           (t p))))))
  data)

(add-to-list 'org-export-filter-parse-tree-functions #'aj/org-odt-export-noindent)

#+end_src
**** ODT has no problem including a pdf file, let it do that
#+begin_src emacs-lisp
(setq org-odt-inline-image-rules '(("file" . "\\.\\(jpeg\\|jpg\\|png\\|gif\\|svg\\|pdf\\)\\'")))
#+end_src
*** LaTeX-export
**** Risky variable fix for ~org-latex-title-command~
~org-latex-title-command~ is treated as a risky variable since it ends in "-command" (see [[info:elisp#File%20Local%20Variables][info:elisp#File Local Variables]]). This means annoying dialogs in files where it is set (and that appearently can’t be fixed by adding values to ~safe-local-variable-values~ either). This fixes it.
 #+begin_src emacs-lisp
(put 'org-latex-title-command 'safe-local-variable #'stringp)
#+end_src

**** Latex drawers
#+begin_src emacs-lisp
(with-eval-after-load "ox-latex"
  (defun aj/ox-latex-drawers (name contents)
    (pcase (downcase name)
      ("temp" (concat "{\\footnotesize\\color{black!60}" contents "}"))
      (_ contents)))

  (setq org-latex-format-drawer-function #'aj/ox-latex-drawers))
#+end_src

**** latex inlinetask
#+begin_src emacs-lisp
(defun aj/org-latex-inlinetask (todo todotype prio name tags cont info)
  "Export inlinetasks with tags and some other stuff"
  todo todotype prio name tags cont info
  (if (string= "∈" name)
      (aj/org-coding-inlinetask tags)
    (let*
        ((name (unless (or (string= "" name) (string= "∈" name)) name))
         (cont (unless (string= "" cont) cont))
         (taglist (when tags (replace-regexp-in-string
                              "_" "\\textunderscore{}"
                              (format "\\ajtags{%s}" (mapconcat 'identity tags ", "))
                              t t))))
      (concat
       taglist
       (when (or name cont)
         (apply
          #'format "\\begin{anfxnote}{%s}%s\\end{anfxnote}"
          (cond
           ((and name cont)
            (list name cont))
           ((and name (not cont))
            (list "Note" name))
           ((and (not name) cont)
            (list "Note" cont)))))))))

(defun aj/org-coding-inlinetask (tags)
  (format "\\codingtags{%s}"
          (mapconcat (lambda (tag)
                       (let ((case-fold-search nil))
                         (replace-regexp-in-string
                          "_" "\\(\\ni\\)"
                          (downcase
                           (replace-regexp-in-string "\\([a-z]\\)\\([A-Z]\\)" "\\1 \\2" tag t))
                          t t)))
                     tags "; ")))


(setq org-latex-format-inlinetask-function 'aj/org-latex-inlinetask)

(put 'org-latex-format-inlinetask-function 'safe-local-variable
     '(lambda (arg)
        (and (symbolp arg)
             (memq arg '(aj/org-latex-transcript-inlinetask aj/fa-org-latex-inlinetask)))))
#+end_src
**** Use latex headers (adapted from ox-extra)
#+begin_src emacs-lisp
(with-eval-after-load "ox"
  (add-hook 'org-export-before-parsing-hook #'aj/org-latex-header-blocks-filter)

  ;; adapted to a working version from the original in ox-extra
  (defun aj/org-latex-header-blocks-filter (backend)
    (when (org-export-derived-backend-p backend 'latex)
      (let ((positions
	         (org-element-map (org-element-parse-buffer 'greater-element nil)
                 'export-block
	           (lambda (block)
	             (when (and (string= (org-element-property :type block) "LATEX")
			                (string= (org-export-read-attribute
				                      :header block :header)
				                     "yes"))
		           (list (org-element-property :begin block)
		                 (org-element-property :end block)
                         (split-string
				          (nth 2 (org-src--contents-area block))
				          "\n")))))))
        (mapc (lambda (pos)
	            (goto-char (nth 0 pos))
	            (delete-region (nth 0 pos) (nth 1 pos))
		        (dolist (line (nth 2 pos))
		          (insert (concat "#+latex_header: "
				                  (replace-regexp-in-string "\\` *" "" line)
				                  "\n"))))
	          ;; go in reverse, to avoid wrecking the numeric positions
	          ;; earlier in the file
	          (reverse positions))))))




#+end_src
**** Quotes in latex export
***** Use csquotes for smart-quotes
#+begin_src emacs-lisp
(defcustom org-aj-export-smart-quotes-use-csquotes t
  "If non-nil, uses csquotes when exporting smart quotes to latex"
  :type 'boolean
  :group 'org-export
  :safe #'booleanp)

(with-eval-after-load "ox"
  (defvar aj/org-export-smart-quotes-alist-orig org-export-smart-quotes-alist)
  (defvar aj/org-export-smart-quotes-alist-csquotes (copy-tree org-export-smart-quotes-alist))

  ;; add-csquotes-commands in csquotes-list
  (mapc (lambda (el)
          ;;depends on the assumption of correct order of
          ;;primary-opening, primary-closing, secondary-opening, secondary-closing
          (setf (cl-getf (cdr (nth 1 el)) :latex)
                "\\textquote{"
                (cl-getf (cdr (nth 2 el)) :latex)
                "}"
                (cl-getf (cdr (nth 3 el)) :latex)
                "\\textquote*{"
                (cl-getf (cdr (nth 4 el)) :latex)
                "}"))
        aj/org-export-smart-quotes-alist-csquotes)

  (add-to-list 'aj/org-export-smart-quotes-alist-csquotes
               '("en-gb" ;;with american quotes really...
                 (primary-opening :utf-8 "“" :html "&lsquo;" :latex "\\textquote{" :texinfo "`")
                 (primary-closing :utf-8 "”" :html "&rsquo;" :latex "}" :texinfo "'")
                 (secondary-opening :utf-8 "‘" :html "&ldquo;" :latex "\\textquote*{" :texinfo "``")
                 (secondary-closing :utf-8 "’" :html "&rdquo;" :latex "}" :texinfo "''")
                 (apostrophe :utf-8 "’" :html "&rsquo;")))
  (add-to-list 'aj/org-export-smart-quotes-alist-csquotes
               (cons "en-us" (cdr (assoc "en" aj/org-export-smart-quotes-alist-csquotes))))


  (defun aj/org-export-smart-quotes-install-hook (_backend)
    (if org-aj-export-smart-quotes-use-csquotes
        (setq org-export-smart-quotes-alist
              aj/org-export-smart-quotes-alist-csquotes)
      (setq org-export-smart-quotes-alist
            aj/org-export-smart-quotes-alist-orig)))

  (add-hook 'org-export-before-processing-hook
            #'aj/org-export-smart-quotes-install-hook))
#+end_src
***** CSquote-support through interpreting attributes environment and options for quote blocks
#+begin_src emacs-lisp
(with-eval-after-load 'ox-latex
  (defun org-latex-quote-block (quote-block contents info)
    "Transcode a QUOTE-BLOCK element from Org to LaTeX.
CONTENTS holds the contents of the block.  INFO is a plist
holding contextual information."
    (let* ((attr (org-export-read-attribute :attr_latex quote-block))
           ;; Determine environment for the quote: blockcquote etc.
           (env (or (plist-get attr :environment)
                    "quote"))
           (options (or (plist-get attr :options) "")))
      (org-latex--wrap-label
       quote-block
       (format "\\begin{%s}%s\n%s\\end{%s}" env options contents env) info))))
#+end_src

***** enquote-to-quotation marks (for latex imported to org),
When I need to do the reverse of the above
#+begin_src emacs-lisp
(defun aj/org-enquote-to-quote (beg end)
  (interactive "r")
  (if (and (number-or-marker-p beg) (number-or-marker-p end))
      (save-excursion
        (goto-char beg)
        (while (re-search-forward "\\\\enquote{\\([^}]+\\)}" end t)
          (replace-match "\"\\1\"" nil nil)))
    (message "Mark a region to transform")))
#+end_src

***** Translate ~´~ to ~'~
The detection of in-word apostrophes etc. often fails. Always using ~´~ to mean apostrophe is a workaround. I still have this in some old files but nowadays I mostly just insert the correct unicode symbol (RIGHT SINGLE QUOTATION MARK: ~’~) which I have conveniently bound on my keyboard.

#+begin_src emacs-lisp
(defun aj/fa-latex-quote (string backend info)
  (cond
   ((member backend '(latex beamer))
	(replace-regexp-in-string
     "´"
     (cond
      ((member backend '(latex beamer)) "'")
      ((eq backend 'html) "&rsquo;")
      ((eq backend 'ascii) (if (eq (plist-get info :ascii-charset) 'utf-8)
                               "’" "'"))
      (t "’"))
     string))))

(with-eval-after-load "ox"
  (add-to-list 'org-export-filter-final-output-functions
               #'aj/fa-latex-quote))
#+end_src



**** LaTeX classes and support for special documents
***** Configuration for thesis writing :ARCHIVE:
Here it is, finished ☺: http://urn.kb.se/resolve?urn=urn:nbn:se:uu:diva-357341
****** UUthesis, for my thesis
#+begin_src emacs-lisp
(with-eval-after-load "ox-latex"
  (add-to-list 'org-latex-classes
               '("uuthesis"
                 "\\documentclass[final]{UUThesisTemplate}"
                 ("\\chapter{%s}" . "\\chapter*{%s}")
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}"))))
#+end_src

****** Glossaries for thesis
#+begin_src emacs-lisp
(org-link-set-parameters "gls"
                         :follow #'ignore
                         :export #'aj/org-gls-export
                         :complete #'aj/org-gls-complete
                         :face 'bold)

(defun aj/org-gls-export (ref _desc backend)
  (if (org-export-derived-backend-p backend 'latex)
      (let* ((sp (split-string ref ":" t))
             (mod (cadr sp))
             (cmd (cond
                   ((equal mod "inheading") "ajglsinheading")
                   ((equal mod "nolink") "glsentrytext")
                   ((stringp mod) mod)
                   (t "gls"))))
        (if (aj/org-gls-find (car sp))  ;; found in unwidened
            (format "\\%s{%s}" cmd (car sp))
          (format "\\emph{%s}" (car sp))))
    ref))

(defun aj/org-gls-complete (&optional _arg)
  (concat "gls:" (completing-read "Glossary terms " (aj/org-gls-find nil t))))

;;just assume we should use glossaryterms.tex if it exists in default dir.
(defun aj/org-gls-find (&optional ref wide)
  (with-current-buffer (or (and (file-readable-p "glossaryterms.tex")
                                (find-file-noselect "glossaryterms.tex" t))
                           (current-buffer))
    (save-restriction
      (when wide (widen))
      (save-excursion
        (save-match-data
          (goto-char (point-min))
          (if ref
              (search-forward-regexp
               (format "\\(newabbreviation\\|longnewglossaryentry\\|newglossaryentry\\|newacronym\\)\\(?:\[^]]+\]\\)?{%s}" ref) nil t)
            (cl-loop
             while (search-forward-regexp
                    "\\(newabbreviation\\|longnewglossaryentry\\|newglossaryentry\\|newacronym\\)\\(?:\[^]]+\]\\)?{\\([^}]+\\)}"
                    nil t)
             collect (match-string 2))))))))


#+end_src
****** Paper ref for thesis (references to the papers included in the thesis)
#+begin_src emacs-lisp
(org-link-set-parameters "paper"
                         :follow #'aj/org-paperref-show
                         :export #'aj/org-paperref-export
                         :complete #'aj/org-paperref-complete
                         :face 'org-scheduled)

(defun aj/org-paperref-export (refs _desc backend)
  (if (org-export-derived-backend-p backend 'latex)
      (let ((psp (split-string refs "," t "[[:space:]]+")))
        (format
         (if (cl-set-difference psp (aj/org-paperref-find)
                                :test 'string=)
             ;; some label was not found
             "\\textbf{%s}"
           "\\paperref{%s}")
         refs))
    refs))

(defun aj/org-paperref-complete (&optional _arg)
  (concat "paper:"
          (string-join (completing-read-multiple
                        "Paperrefs: "
                        (aj/org-paperref-find nil t))
                       ", ")))

(defun aj/org-paperref-show (refs)
  (message
   (cl-loop for p in (cl-loop for ref in (split-string refs "," t)
                              collect (aj/org-paperref-find ref t))
            concat
            (concat (if p
                        (save-excursion
                          (goto-char p)
                          (buffer-substring-no-properties
                           (point-at-bol) (point-at-eol)))
                      "Not found!") "\n"))))

(defun aj/org-paperref-find (&optional ref wide)
  (save-restriction
    (when wide (widen))
    (save-excursion
      (save-match-data
        (goto-char (point-min))
        (when (search-forward "\\begin{listofpapers}" nil t)
          (let ((limit (save-excursion (search-forward "\\end{listofpapers}" nil t))))
            (if ref
                (search-forward (format "\\label{%s}" ref) limit t)
              (cl-loop
               while (search-forward-regexp "\\\\label{\\([^}]+\\)}" limit t)
               collect (match-string 1)))))))))

#+end_src

****** Latin abbreviations for thesis
#+begin_src emacs-lisp
(dolist (x '(("eg" "\\eg" nil "e.g." "e.g." "e.g." "e.g.")
             ("etal" "\\etal" nil "et al." "et al." "et al." "et al.")
             ("etc" "\\etc" nil "etc." "etc." "etc." "etc.")
             ("ie" "\\ie" nil "i.e." "i.e." "i.e." "i.e.")
             ("cf" "\\cf" nil "cf." "cf." "cf." "cf.")))
  (add-to-list 'org-entities-user x))
#+end_src
****** Lists in thesis
#+begin_src emacs-lisp
(defun aj/org-latex-thesis-lists-data (data backend info)
  "Use thesis environments for plain lists.
Add as a filter in ‘org-export-filter-parse-tree-functions’."
  (when (eq backend 'latex)
    (org-element-map data '(plain-list)
      #'aj/org-latex-thesis-list-set-environment
      info))
  data)

(defun aj/org-latex-thesis-list-set-environment (plain-list)
  (unless (plist-get (org-export-read-attribute :attr_latex plain-list)
                     :environment)
    (org-element-put-property
     plain-list :attr_latex
     (cons (format ":environment %s"
                   (cl-case (org-element-property :type plain-list)
                     ('ordered "numberedlist-aj")
			         ('descriptive "description")
			         (t "bulletlist-aj")))
           (org-element-property :attr_latex plain-list)))))

;; (defun aj/org-latex-thesis-lists (translist backend info)
;;   "Use thesis environments for plain lists.
;; Add as a filter in `org-export-filter-plain-list-functions'"
;;   (if (and (org-export-derived-backend-p backend 'latex)
;;            (string= (plist-get info :latex-class) "uuthesis"))
;;       (replace-regexp-in-string
;;        "{itemize}" "{bulletlist}"
;;        (replace-regexp-in-string "{enumerate}" "{numberedlist}" translist t t))
;;     translist))

#+end_src
****** Convert ref to cref (from cleverref)
#+begin_src emacs-lisp
(defvar aj/org-latex-export-cleverref nil)
(defun aj/org-latex-ref-to-autoref (string backend _info)
  (if (and (org-export-derived-backend-p backend 'latex)
           aj/org-latex-export-cleverref)
      (zotxt-extra--replace-consecutive
       (replace-regexp-in-string "\\\\ref{" "\\cref{" string t t)
       "\\\\cref{\\([^}]+\\)}"
       "[[:space:],]*\\(?:and\\)*[[:space:],]*"
       "\\cref{%s}" ",")
    string))

(add-to-list 'org-export-filter-final-output-functions
             #'aj/org-latex-ref-to-autoref)
#+end_src

****** Replace references
Very specific code for replacing certain references that get exported in a format that biblatex can’t handle correctly from zotero with manually crafted bib-entries (often using workarounds).

#+begin_src emacs-lisp
(autoload 'bibtex-parse-keys "bibtex")

(defun aj/replace-fixed-references (string backend _info)
  (when (and
         (org-export-derived-backend-p backend 'latex)
         (string-match-p "avhandling" default-directory))
    (when-let ((bbuf (find-file-noselect "fixreferenser.bib")))
      (with-current-buffer bbuf
        (xah-replace-pairs-in-string
         string
         (cl-loop for x in (bibtex-parse-keys)
                  collect (list (substring (car x) 0 -4) (car x))))))))

(add-to-list 'org-export-filter-final-output-functions #'aj/replace-fixed-references)
#+end_src

****** Thesischapter, for old thesis :ARCHIVE:
#+begin_src emacs-lisp
(with-eval-after-load "ox-latex"
  (add-to-list 'org-latex-classes
               '("thesischapter"
                 "\\documentclass[11pt]{report}"
                 ("\\chapter{%s}" . "\\chapter*{%s}")
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}"))))
#+end_src
***** Class for ajshort (my own common latex configuration for short texts wrapped up into a package)
#+begin_src emacs-lisp
(with-eval-after-load "ox-latex"
  (setq org-latex-subtitle-separate t
        org-latex-subtitle-format "\\newcommand{\\thesubject}{%s}"
        org-latex-default-class "ajshort")
  ;; (add-to-list 'org-latex-packages-alist '("" "ajcomments"))


  (defun aj/latex-add-style-options (fn header info)
    "Advised to replace \\usepackage{ajshort/ajbeamer} with custom definition if options are needed"
    (when (and (member (plist-get info :latex-class) '("ajshort" "ajbeamer"))
               (string-match "\\\\usepackage{aj\\(short\\|beamer\\)}" header)
               (string-match "\\\\usepackage\\[.+\\]{aj\\(short\\|beamer\\)}" header))
      (let ((wo (match-string 0 header)))
        (setq header (replace-regexp-in-string
                      "\\\\usepackage{aj\\(short\\|beamer\\)}" wo
                      (replace-regexp-in-string
                       "\\\\usepackage\\[.+\\]{aj\\(short\\|beamer\\)}" "" header nil t)
                      nil t))))
    (funcall fn header info))

  (advice-add 'org-latex-guess-babel-language :around #'aj/latex-add-style-options)

  ;;(advice-remove 'org-latex-guess-babel-language #'aj/latex-add-style-options)

  (add-to-list 'org-latex-classes
               '("ajshort"
                 "\\documentclass[a4paper,12pt]{article}
 \\usepackage[AUTO]{inputenc}
 \\usepackage[british,swedish,AUTO]{babel}
 \\usepackage{etoolbox}
 \\usepackage{longtable}
 \\usepackage{float}
 \\usepackage{wrapfig}
 % \\usepackage[normalem]{ulem}
 % \\usepackage{amsmath}
 % \\usepackage{textcomp}
 % \\usepackage{marvosym}
 % \\usepackage{wasysym}
 % \\usepackage{amssymb}
 \\usepackage{authoraftertitle} %före title!
 [PACKAGES]
 [EXTRA]
 [NO-DEFAULT-PACKAGES]
 \\usepackage{ajshort}"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))))
#+end_src

***** iopart class (for Institute of Physics papers)
I wrote this paper with it:
http://iopscience.iop.org/article/10.1088/1361-6404/aa9b42
#+begin_src emacs-lisp
(with-eval-after-load "ox-latex"
  (add-to-list
   'org-latex-classes
   '("iopart" "\\documentclass{iopart}
\\usepackage[AUTO]{inputenc}
\\usepackage[T1]{fontenc}
\\usepackage[AUTO]{babel}
\\usepackage{times}
\\usepackage{hyperref}
[NO-DEFAULT-PACKAGES]
[PACKAGES]
[EXTRA]"
 ("\\section{%s}" . "\\section*{%s}")
 ("\\subsection{%s}" . "\\subsection*{%s}")
 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
 ("\\paragraph{%s}" . "\\paragraph*{%s}")
 ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))


(defun aj/org-export-latex-remove-iopart-title (string backend info)
  (and (eq backend 'latex)
       (string= "iopart" (plist-get info :latex-class))
       (with-temp-buffer
         (insert string)
         (search-backward "\\begin{document}" nil t)
         (when (search-backward-regexp "\\\\title{.+}$" nil t)
           (replace-match ""))
         (buffer-string))))

(add-to-list 'org-export-filter-final-output-functions #'aj/org-export-latex-remove-iopart-title))
#+end_src
***** Revtex-class, adapted from [[https://github.com/jkitchin/jmax/blob/master/ox-manuscript.el][ox-manuscript]]
Used it to write this paper: http://dx.doi.org/10.1119/perc.2016.pr.040
#+begin_src emacs-lisp
(with-eval-after-load "ox-latex"
  (add-to-list 'org-latex-classes
               '("revtex4-1-aj"
                 "\\documentclass{revtex4-1}
\\usepackage[AUTO]{inputenc}
\\usepackage[T1]{fontenc}
[NO-DEFAULT-PACKAGES]
[PACKAGES]
[EXTRA]"
 ("\\section{%s}" . "\\section*{%s}")
 ("\\subsection{%s}" . "\\subsection*{%s}")
 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
 ("\\paragraph{%s}" . "\\paragraph*{%s}")
 ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))))
#+end_src
***** CV, moderncv class
****** cv
#+begin_src emacs-lisp
(with-eval-after-load "ox-latex"
  (add-to-list 'org-latex-classes
               '("ajcv"
                 "\\documentclass[11pt,a4paper]{moderncv}
 \\usepackage[AUTO]{inputenc}
 \\usepackage[T1]{fontenc}
 \\usepackage[AUTO]{babel}
 [PACKAGES]
 [EXTRA]
 [NO-DEFAULT-PACKAGES]
\\usepackage{ajcv}"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")))


  (advice-add 'org-latex-plain-list :around #'aj/org-latex-plain-list-cv)

  (defun aj/org-latex-plain-list-cv (fun plain-list contents info)
    "Hacks lists to cv-entries"
    (let ((type (org-element-property :type plain-list)))
      (cond
       ((and (string= "ajcv" (plist-get info :latex-class))
             (or (eq type 'descriptive)
                 (eq type 'unordered)))
        contents)
       (t (funcall fun plain-list contents info)))))


  (advice-add 'org-latex-item :around #'aj/org-latex-item-cv)

  (defun aj/org-latex-item-cv (fun item contents info)
    (let ((type (org-element-property
                 :type (org-export-get-parent item)))
          (ajcv (string= "ajcv" (plist-get info :latex-class))))
      (cond
       ((and ajcv (eq type 'descriptive))
        (let* ((fields (split-string contents ";" nil  "[: \n]+"))
               (n (length fields))
               (tag (let ((tag (org-element-property :tag item)))
		              (if tag (org-export-data tag info) ""))))
          (cond
           ((eq 1 n) (format "\\cvitem{%s}{%s}" tag (car fields)))
           ((eq 2 n) (format
                      "\\cvitemwithcomment{%s}{%s}{%s}"
                      tag (car fields) (cadr fields)))
           (t (apply #'format
                     "\\cventry{%s}{%s}{%s}{%s}{%s}{%s}"
                     tag
                     (append fields (make-list 5 ""))))))
        )
       ((and ajcv (eq type 'unordered))
        (format "\\cvlistitem{%s}" (org-trim contents)))
       (t (funcall fun item contents info))))))
#+end_src
****** cv letter
#+begin_src emacs-lisp
(with-eval-after-load "ox-latex"
  (add-to-list 'org-latex-classes
               '("ajcv-letter"
                 "\\documentclass[12pt,a4paper]{moderncv}
 \\usepackage[AUTO]{inputenc}
 \\usepackage[T1]{fontenc}
 \\usepackage[AUTO]{babel}
 [PACKAGES]
 [EXTRA]
 [NO-DEFAULT-PACKAGES]
\\usepackage{ajcv-letter}"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}"))))


#+end_src
**** Use latexmk
#+begin_src emacs-lisp
(setq org-latex-pdf-process '("latexmk -g -recorder -pdf %b"))
#+end_src
**** Add command for opening exported pdf in external pdf-viewer
#+begin_src emacs-lisp
(with-eval-after-load 'ox-latex
  (defun aj/latex-export-and-open-externally (a s v b)
    (if a (org-latex-export-to-pdf t s v b)
	  (org-open-file (org-latex-export-to-pdf nil s v b) '(16))))

  (push '(?O "As PDF - open externally" aj/latex-export-and-open-externally)
        (car (last (org-export-backend-menu (org-export-get-backend 'latex))))))
#+end_src

**** Exporting through AUCTeX
It has better error messages and better async running of file. I have also used this for putting together files through latex includes and the concept of AUCTeX master files (then you can easily just process a sub-file, or a region, like with org subtree-export).
#+begin_src emacs-lisp
(with-eval-after-load 'ox-latex
  (org-export-define-derived-backend 'auctex 'latex
    :menu-entry
    '(?a "AUCTeX export"
         ((?a "As PDF (AUCTeX)"
              aj/org-export-tex-auctex)
          (?A "As PDF (AUCTeX) and view"
              aj/org-export-tex-auctex-and-view)
          ;; (?f "As PDF (AUCTeX this file)"
          ;;     aj/org-export-tex-auctex-subfile)
          (?v "View pdf (evince)"
              aj/org-export-tex-auctex-view-evince)
          (?V "View pdf (pdf-tools)"
              aj/org-export-tex-auctex-view-pdf-tools)
          (?l "Show tex process"
              aj/TeX-recenter-output-buffer)))))

(autoload 'TeX-command-sequence "tex-buf")
(autoload 'TeX-recenter-output-buffer "tex-buf")
(autoload 'TeX-strip-extension "tex")

(defun aj/org-export-tex-auctex (_async subtreep visible-only _body-only)
  "Export to pdf with auctex. Ignores async since running tex is
usually what takes time and that is called async through
auctex (and there are so many hacks needed to get my other
hacks working for async)"
  (interactive)
  (org-export-to-file 'latex (org-export-output-file-name ".tex" subtreep)
    nil subtreep visible-only nil nil
    #'aj/org-export-tex-auctex-run-tex))

(defun aj/org-export-tex-auctex-and-view (_async subtreep visible-only _body-only)
  "Export to pdf with auctex and view. Ignores async since running tex is
usually what takes time and that is called async through
auctex (and there are so many hacks needed to get my other
hacks working for async)"
  (interactive)
  (org-export-to-file 'latex (org-export-output-file-name ".tex" subtreep)
    nil subtreep visible-only nil nil
    #'aj/org-export-tex-auctex-run-tex-view))

(autoload #'TeX-command "tex-buf")
(defvar aj/org-export-tex-auctex-curr-file nil)
(defvar TeX-master)

(defun aj/org-export-tex-auctex-run-tex (file)
  (setq aj/org-export-tex-auctex-curr-file file) ; stupid
  (setq TeX-master file)
  (TeX-command-sequence '("latexmk")
                        t #'aj/org-export-tex-auctex-curr-file) file)

(defun aj/org-export-tex-auctex-run-tex-view (file)
  (setq aj/org-export-tex-auctex-curr-file file) ; stupid
  (setq TeX-master file)
  (TeX-command-sequence '("latexmk" "View")
                        t #'aj/org-export-tex-auctex-curr-file) file)

(defvar TeX-view-program-selection) ; avoid byte-compiler warning

(defun aj/org-export-tex-auctex-view-evince (_async subtreep _visible-only _body-only)
  (let ((TeX-view-program-selection '((output-pdf "Evince"))))
    (aj/org-export-tex-auctex-only-view (org-export-output-file-name "" subtreep))))

(defun aj/org-export-tex-auctex-view-pdf-tools (_async subtreep _visible-only _body-only)
  (let ((TeX-view-program-selection '((output-pdf "PDF Tools"))))
    (aj/org-export-tex-auctex-only-view (org-export-output-file-name "" subtreep))))

(defun aj/org-export-tex-auctex-only-view (file)
  (setq aj/org-export-tex-auctex-curr-file file) ; stupid
  (setq TeX-master file)
  (TeX-command-sequence '("View")
                        t #'aj/org-export-tex-auctex-curr-file) file)

(defun aj/org-export-tex-auctex-curr-file (&rest _ignore)
  (TeX-strip-extension aj/org-export-tex-auctex-curr-file nil t))

(defun aj/TeX-recenter-output-buffer (&rest _ignore)
  (interactive)
  (TeX-recenter-output-buffer nil))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Older stuff, not sure if this works:

;; (defun aj/org-export-tex-auctex-subfile (async subtreep visible-only _body-only)
;;   (interactive)
;;   (let ((outfile (org-export-output-file-name ".tex" subtreep))
;;         ;;use with cl-letf
;;         ;; ((symbol-function 'aj/TeX-run-latexmk) #'aj/org-TeX-run-latexmk)
;;         )
;;     (org-export-to-file 'latex outfile
;;       async subtreep visible-only t nil
;;       #'aj/org-export-tex-auctex-run-tex-region)))

;; (autoload #'TeX-master-file "tex")
;; (autoload #'TeX-region-create "tex-buf")
;; (autoload #'TeX-region-file "tex-buf")
;; (defun aj/org-export-tex-auctex-run-tex-region (file)
;;   ;; (require 'tex)
;;   ;; (require 'latex)
;;   ;;TeX-master should be available as local variable in this temp org
;;   ;;buffer (but not neccessarily if we missed to export the local
;;   ;;variables section for some reason (subtree, narrowing, etc))

;;   ;; bind + local seems to work with org-export--generate-copy-script
;;   ;; as it adds the bound ones as local
;;   (hack-local-variables)
;;   (let ((texm (TeX-master-file)))
;;     (with-current-buffer (find-file-noselect file t)
;;       (latex-mode)
;;       (let ((TeX-master texm))
;;         (TeX-region-create (TeX-region-file TeX-default-extension)
;;                            (buffer-string)
;;                            (file-name-nondirectory (buffer-file-name))
;;                            (TeX-current-offset begin)))
;;       (TeX-command "latexmk" #'TeX-region-file -1)))
;;   file)

#+end_src

**** Beamer
***** Don’t interfere with ordinary latex export
#+begin_src emacs-lisp
(with-eval-after-load 'ox-beamer
  (let ((bb (org-export-get-backend 'beamer)))
    (setf (car (org-export-backend-menu bb)) ?b
          (cadr (org-export-backend-menu bb)) "Export to Beamer")
    (org-export-register-backend bb)))
#+end_src

***** Configuration and class loading my beamer customizations
#+begin_src emacs-lisp
(use-package ox-beamer
  :straight nil
  :config
  (add-to-list 'org-beamer-environments-extra '("pnote" "m" "\\pnote{%h" "}"))
  (add-to-list 'org-beamer-environments-extra
               '("plainframe" "-" "\\begin{frame}%a%A[plain]" "\\end{frame}"))
  ;;(add-to-list 'org-beamer-environments-extra '("sectionwithsectionpage" "T" "\\section{%h}\\begin{frame}{}\\sectionpage\\end{frame}" ""))
  (setq org-beamer-theme nil)
  (add-to-list 'org-latex-classes
               '("ajbeamer"
                 "\\documentclass[presentation]{beamer}
 \\usepackage[AUTO]{inputenc}
 \\usepackage[T1]{fontenc}
 \\usepackage[AUTO,shorthands=off]{babel}
 \\usepackage{ajbeamer}
 \\usepackage{textcomp}
 [NO-DEFAULT-PACKAGES]
 [NO-PACKAGES]
 [EXTRA]"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))))
#+end_src

***** New link types for beamer
****** Videoframe
#+begin_src emacs-lisp
(defun org-vframe-export-handler (path desc format)
  (let ((dsplit (split-string desc "::" t "[ \t]*")))
    (if (member format '(beamer latex))
        (format "\\videoframe[%s]{%s}{%s}" (or (nth 1 dsplit) "") path (or (car dsplit) ""))
      (format "VIDEO: %s (%s)" (or (car dsplit) "") path))))

(defun org-vframe-complete-link ()
  (aj/org-complete-link "vframe:"))

(org-link-set-parameters "vframe"
                         :follow #'aj/org-open-file-with-system
                         :export #'org-vframe-export-handler
                         :complete #'org-vframe-complete-link)
#+end_src

****** full-screen image in beamer
#+begin_src emacs-lisp
(autoload 'xah-replace-pairs-in-string "xah-replace-pairs")

(defun org-bfimg-export-handler (path desc format)
  (when (eq format 'beamer)
    (let ((eopt (when desc
                  (xah-replace-pairs-in-string
                   (concat "," (cadr (split-string desc "::")))
                   [["\\{" "{"] ["\\}" "}"]]))))
      (format "\\centering\\makebox[\\textwidth]{\\includegraphics[width=\\paperwidth,height=\\paperheight,keepaspectratio%s]{%s}}"
              (if (or (not eopt) (string= "," eopt)) "" eopt)
              path))))

(defun org-bfimg-complete-link ()
  (aj/org-complete-link "bfimg:"))

(org-link-set-parameters "bfimg"
                         :follow #'aj/org-open-file-with-system
                         :export #'org-bfimg-export-handler
                         :complete #'org-bfimg-complete-link)
#+end_src

***** Compatibility with ox-reveal
I’m trying out ox-reveal, but they have different ways of adding notes (subtrees vs special blocks). This makes sure a file prepared for reveal can also work with beamer
#+begin_src emacs-lisp
(defun aj/org-export-reveal-note-to-beamer-note (string backend _info)
  (when (eq backend 'beamer)
    (replace-regexp-in-string
     "\\\\begin{NOTES}\\(\\(?:.\\|\n\\)+\\)\\\\end{NOTES}"
     "\\\\pnote{\\1}" string
     )))

(add-to-list 'org-export-filter-special-block-functions #'aj/org-export-reveal-note-to-beamer-note)
#+end_src

***** Hydra for templates :ARCHIVE:
#+begin_src emacs-lisp
(with-eval-after-load 'ox-beamer
  (bind-key "C-c C-ö" #'hydra-beamer-templates/body org-beamer-mode-map)
  (autoload #'yas-expand-snippet "yasnippet")
  (autoload #'yas-lookup-snippet "yasnippet")
  (defhydra hydra-beamer-templates (:color blue)
    "Beamer templates"
    ("t" (yas-expand-snippet (yas-lookup-snippet "Beamer title frame")) "Section title frame")
    ("v" (yas-expand-snippet (yas-lookup-snippet "Beamer vframe")) "videoframe")
    ("F" (yas-expand-snippet (yas-lookup-snippet "Beamer fullscreen image")) "Full screen image")
    ("i" (yas-expand-snippet (yas-lookup-snippet "Beamer image")) "Beamer image")
    ("f" (yas-expand-snippet (yas-lookup-snippet "Beamer figure")) "Beamer figure")
    ("b" (insert "#+BEAMER: ") "Beamer:")
    ("p" (insert "#+BEAMER: \\pause") "Pause")
    ("s" (insert "#+BEAMER: \\small") "Small")
    ("+" (aj/org-insert-element-attributes "#+ATTR_BEAMER: :overlay +-") "Overlay +-")
    ("T" (aj/org-insert-element-attributes "#+ATTR_BEAMER: :environment tightitemize") "Tightitemize"))
  )
#+end_src
**** Latex-check
#+begin_src emacs-lisp
(defun aj/org-lacheck (&optional subtreep)
  (interactive "P")
  (let* ((lat (org-export-as 'latex subtreep))
		 (ct (current-time))
		 (fn (format "/tmp/olc/%d%d.tex" (car ct) (nth 2 ct))))
	(find-file fn)
	(insert lat)
	(compile (format "lacheck %s" fn))))
#+end_src

*** Export without headlines (list-outline, h:0)
#+begin_src emacs-lisp
(defun aj/org-export-opt-no-hl (opt _backend)
  (plist-put opt :headline-levels 0))

(defun aj/org-export-no-sections (prefix)
  "Export without headlines (list-outline, h:0)"
  (interactive "P")
  (let ((org-export-filter-options-functions
         (cons 'aj/org-export-opt-no-hl org-export-filter-options-functions)))
	(org-export-dispatch prefix)))

;; (bind-key "C-M-c C-M-e" #'aj/org-export-no-sections org-mode-map)
#+end_src

*** Export parent subtree :ARCHIVE:
:PROPERTIES:
:CUSTOM_ID: parent-subtree
:END:

This needs to be updated using ~org-num~ (check numbering in overlays). Until I need it, disable.

#+begin_src emacs-lisp
;; this one is what I most often want
(defun aj/org-export-parent-subtree-infile (arg)
  "Exports the current file narrowed to subtree with scope ‘org-export-initial-scope’.
If ‘org-export-initial-scope’ is the default 'buffer, no shifting
 of headline levels should, so the export matches what it would
 look like if the complete document was exported. Prefix argument
 as in ‘aj/org-export-parent-subtree’"
  (interactive "P")
  (aj/org-export-parent-subtree arg t))

(bind-key "C-S-c C-S-e" #'aj/org-export-parent-subtree-infile org-mode-map)

(defvar-local aj/org-export-parent-subtree-level nil
  "If non-nil, the level of the parent subtree chosen by
‘aj/org-export-parent-subtree’")
(put 'aj/org-export-parent-subtree-level 'safe-local-variable
     (lambda (x) (or (integerp x) (null x))))

(bind-key "C-M-c C-M-e" #'aj/org-export-parent-subtree org-mode-map)

(defun aj/org-export-parent-subtree (arg &optional narrowed-export)
  "Launch `org-export-dispatch' at a parent subtree.
By default goes to level 1 or to the level defined in local
variable ‘aj/org-export-parent-subtree-level’. Numeric prefix
argument means go to that level. Repeated prefix arguments means
go up that many levels."
  (interactive "P")
  (let ((level (cond ((not arg) (or aj/org-export-parent-subtree-level 1))
                     ((listp arg) (floor (1+ (- (org-current-level)
                                                (log (car arg) 4)))))
                     ((integerp arg) arg)))
        (org-export-initial-scope (if narrowed-export
                                      org-export-initial-scope
                                    'subtree)))
    (if (<= 1 level (org-current-level))
        (save-mark-and-excursion
          (if (equal level (org-current-level))
              (org-back-to-heading)
            (while (let ((current (org-up-heading-safe)))
                     (and current
                          (not (eq current level))))))
          (if narrowed-export
              (progn
                (save-restriction
                  (org-narrow-to-subtree)
                  (cl-letf (((symbol-function 'org-export-output-file-name)
                             #'aj/org-export-unconditionally-return-subtree-filename)
                            (org-export-filter-final-output-functions ; This doesn’t work for async, of course
                             (cons #'aj/org-add-latex-numbering-start
                                   org-export-filter-final-output-functions))
                            (aj/org-latex-numbering-start (aj/org-get-current-hl-numbering)))
                    (org-export-dispatch))))
            (org-export-dispatch)))
      (user-error "Incorrect export level: %d. Current level: %d" level (org-current-level)))))

(defun aj/org-export-unconditionally-return-subtree-filename (ext &rest _rest)
  "Adds a filename derived from the heading name if no filename
is defined the subtree during org subtree export."
  (concat (aj/org-export-headline-filename
           (org-get-heading t t t t))
          ext))

;; stuff for setting the correct numbering. This only really works
;; when exporting top-level trees, since the parsing places the
;; current selected (subtree) at top-level, thus disrupting the
;; numbering totally if exporting say, level 2.4 (which will then
;; start out as chapter 2 in the exported tex-file). So these
;; functions do some unneccesary stuff right now.
;; Perhaps it is possible to change the parsing, but I haven’t found a
;; hack for that now.

(defun aj/org-get-current-hl-numbering ()
  (let ((outline-active org-num-mode))
    (unwind-protect
        (progn
          (org-num-mode 1)
          (when-let ((ov (nth 1 (overlays-in (point) (point-at-eol))))
                     (nh (overlay-get ov 'org-num))
                     (num (overlay-get ov 'display)))
            (split-string num "\\." t "[[:space:]]+")))
      (unless outline-active
        (org-num-mode -1)))))

(defvar aj/org-latex-numbering-start '("1"))

(defun aj/org-add-latex-numbering-start (string backend info)
  (when (org-export-derived-backend-p backend 'latex)
    (when-let ((class (plist-get info :latex-class))
               (classes (plist-get info :latex-classes))
               (secs (cl-subseq (cddr (assoc class classes))
                                0 (length aj/org-latex-numbering-start)))
               (secnames (cl-loop for s in (mapcar #'car secs)
                                  collect
                                  (when (string-match "\\\\\\([^}]+\\){%s}" s)
                                    (match-string 1 s)))))
      (replace-regexp-in-string
       "\\\\begin{document}"
       (concat "\\begin{document}\n"
               (cl-loop for sn in secnames
                        concat
                        (format "\\setcounter{%s}{%d}"
                                sn
                                (1- (string-to-number
                                     (pop aj/org-latex-numbering-start))))))
       string t t))))


#+end_src

*** Export and discard contents of headlines but keep headline (alternative to noexport)
#+begin_src emacs-lisp
(defcustom org-aj-ignore-below-tags nil
  "Tags where the contents of trees should be discarded on export.
Can be set as local variable, but not bound with BIND keyword,
since that is read in to late."
  :group 'aj
  :group 'org-export
  :type '(repeat string)
  :safe #'orgqda--list-of-strings-p)

(defun aj/org-ignore-below-tags (_backend)
  "Clean all contents of trees tagged with any of ‘org-aj-ignore-below-tags’.
Run in `org-export-before-parsing-hook'."
  (org-map-entries 'aj/org-clean-subtree-contents-tag))

(defun aj/org-clean-subtree-contents-tag ()
  "Clean contents of headline if tagged with any of ‘org-aj-ignore-below-tags’."
  (when (cl-intersection org-scanner-tags org-aj-ignore-below-tags :test #'string=)
	(end-of-line)
	(let ((sp (point)))
      (org-end-of-subtree t)
	  (delete-region sp (point)))))

(add-hook 'org-export-before-parsing-hook #'aj/org-ignore-below-tags)

;; This should give the same result but doesn’t:

;; (defun aj/org-ignore-below-tags-pt (tree _backend _info)
;;   (org-element-map tree 'headline
;;     (lambda (hl)
;;       (when (cl-intersection org-aj-ignore-below-tags
;;                              (org-element-property :tags hl)
;;                              :test #'string=)
;;         (org-element-set-contents hl "")))))

;; (add-to-list 'org-export-filter-parse-tree-functions #'aj/org-ignore-below-tags-pt)
#+end_src


*** Export and ignore everyting below a specific level, for some backends
I don’t really use this now, but I keep these variable definitions around since I have them in some old files and don’t want to hear the safe-local-variable complaints
#+begin_src emacs-lisp
(defvar-local aj/org-ignore-below-level nil)
(put 'aj/org-ignore-below-level 'safe-local-variable (lambda (arg) (or (integerp arg) (eq nil arg))))
(defvar-local aj/org-ignore-below-level-backends ())
(put 'aj/org-ignore-below-level-backends 'safe-local-variable
	 (lambda (arg) (and (listp arg)
                   (cl-every 'symbolp arg))))

(defvar aj/org-ignore-level-regexp "")
#+end_src


**** Funktioner :ARCHIVE:
#+begin_src emacs-lisp
(defun aj/org-ignore-below-level (backend)
  "Makes sure to clean all content below level set by
`aj/org-ignore-below-level' if run by
`org-export-before-parsing-hook' and current backend is a member
of `aj/org-ignore-below-level-backends'."
  ;; (when (member backend '(odt);; aj/org-ignore-below-level-backends
  ;; )
  (setq aj/org-ignore-level-regexp
        (format "^\\*\\{1,%d\\} " 4 ;; aj/org-ignore-below-level
                ))
  (org-map-entries 'aj/org-clean-hl-contents))
;; )

(defun aj/org-clean-hl-contents ()
  "Helper function responsible for cleaning contents below specific level, run by `aj/org-ignore-below-level'"
  (when (= (org-current-level) aj/org-ignore-below-level)
	(end-of-line)
	(let ((sp (point)))
	  (when (search-forward-regexp aj/org-ignore-level-regexp nil t)
		(forward-line -1)
		(end-of-line)
		(delete-region sp (point))))))

(add-hook 'org-export-before-parsing-hook 'aj/org-ignore-below-level)
(remove-hook 'org-export-before-parsing-hook 'aj/org-ignore-below-level)


#+end_src
exportera bara manus till odt



*** Ignore headlines (but not content) with tag "ignoreheading" at export
Adapted from: [[http://orgmode.org/cgit.cgi/org-mode.git/plain/contrib/lisp/ox-extra.el][ox-extra.el]] ([[http://stackoverflow.com/a/29588450][Alternative]])

The last parts are some half-successful attempts to solve this for ox-reveal exports

#+begin_src emacs-lisp
(defcustom aj/org-ignoreheading-tags '("ignoreheading")
  "Tags for which the heading should be removed but content kept
  in org export"
  :group 'aj
  :type '(repeat string)
  :safe (lambda (x) (cl-every #'stringp x)))

;; (defcustom aj/org-ignoreheadinglocal-tags '("ignoreheadinglocal")
;;   "Tags for which the heading should be removed after output,
;; but content kept in org export."
;;   :group 'aj
;;   :type '(repeat string)
;;   :safe (lambda (x) (cl-every #'stringp x)))

(defun aj/org-export-ignore-headlines (data backend info)
  (cond
   ((eq backend 'beamer) ; do nothing (maybe should?)
    data)
   (t
    (aj/org-data-remove-headline data backend info))))

(defun aj/org-data-remove-headline (data backend info)
  "Remove headlines tagged \"ignoreheading\" retaining contents and promoting children.
Each headline tagged \"ignoreheading\" will be removed retaining its
contents and promoting any children headlines to the level of the
parent."
  (org-element-map data 'headline
    (lambda (object)
      (when ; this is the difference to the version from ox-extra
          (cl-intersection aj/org-ignoreheading-tags
                           (org-element-property :tags object)
                           :test #'string=)
        (let ((level-top (org-element-property :level object))
              level-diff)

          (dolist (el (org-element-contents object))
            ;; recursively promote all nested headlines
            (org-element-map el 'headline
              (lambda (el)
                (unless level-diff
                  (setq level-diff (- (org-element-property :level el)
                                      level-top)))
                (org-element-put-property el :level
                                          (- (org-element-property :level el)
                                             level-diff))))
            ;; insert everything back into parse tree, except for segments
            ;; (non-headlines) on level 1 (believe that’s the
            ;; pathological case)
            (unless (and (= 1 level-top)
                         (not (equal 'headline (org-element-type el))))
              (org-element-insert-before el object))))
        (org-element-extract-element object)))
    info nil)
  (org-extra--merge-sections data backend info)
  data)

(defun org-extra--merge-sections (data _backend info)
  (org-element-map data 'headline
    (lambda (hl)
      (let ((sections
             (cl-loop
              for el in (org-element-map (org-element-contents hl)
                            '(headline section) #'identity info)
              until (eq (org-element-type el) 'headline)
              collect el)))
        (when (and sections
                   (> (length sections) 1))
          (apply #'org-element-adopt-elements
                 (car sections)
                 (cl-mapcan (lambda (s) (org-element-contents s))
                            (cdr sections)))
          (mapc #'org-element-extract-element (cdr sections)))))
    info))

;; (defun aj/org-mark-headline-to-be-removed (data backend info)
;;   "Mark headline to be removed in post-processing"
;;   (org-element-map data 'headline
;;     (lambda (hl)
;;       (when (cl-intersection aj/org-ignoreheadinglocal-tags
;;                           (org-element-property :tags hl))
;;         (org-element-put-property
;;          hl :title '(("!!!IGNOREHEADING!!!")))))
;;     info nil)
;;   data)

;; (defun aj/org-remove-marked-ignoreheadings (string backend info)
;;   (replace-regexp-in-string "<h2.*!!!IGNOREHEADING!!!.*h2>" ""
;;                             string)
;;   ;; string
;;   )

;; (add-to-list 'org-export-filter-final-output-functions #'aj/org-remove-marked-ignoreheadings)


(add-hook 'org-export-filter-parse-tree-functions #'aj/org-export-ignore-headlines)

#+end_src

*** stripheading, pre-parsing alternative to ignoreheading
Does not promote children so gives a sometimes different effect on the tree.

#+begin_src emacs-lisp
(defun aj/org-export-strip-headings (_backend)
  "Strip lines containing \"stripheadings\" tag."
  (save-excursion
    (flush-lines ":stripheading:" )))

(add-hook 'org-export-before-parsing-hook #'aj/org-export-strip-headings)

#+end_src

*** by-backend, macro for some exports
#+begin_src emacs-lisp
(defmacro org-by-backend (&rest body)
  `(case org-export-current-backend ,@body))
#+end_src

*** Ignore or include trees with backend specific tags
#+begin_src emacs-lisp
(defun aj/ox-sel-excl-by-backend (options backend)
  "Adds noexport_backend and export_backend to :exclude-tags
and :select-tags in org export."
  (let* ((ex (plist-get options :exclude-tags))
         (sel (plist-get options :select-tags))
         (bn (symbol-name backend))
         (par (org-export-backend-parent
               (ignore-errors (org-export-get-backend backend))))
         (par (when par (symbol-name par))))
    (push  (concat "noexport_" bn) ex)
    (push (concat "export_" bn) sel)
    (when par
      (push (concat "noexport_" par)  ex)
      (push (concat "export_" par) sel))
    (plist-put options :exclude-tags ex)
    (plist-put options :select-tags sel)
    options))

(add-to-list 'org-export-filter-options-functions #'aj/ox-sel-excl-by-backend)
#+end_src

** Publishing :org_async:
(projects are in custom.el)
#+begin_src emacs-lisp
(setq ange-ftp-try-passive-mode t) ; needed!
#+end_src

** org-babel
#+begin_src emacs-lisp
(setq org-babel-latex-htlatex-packages
      '("[usenames]{color}" "{tikz}" "{color}" "{listings}" "{amsmath}" "{pgfplots}")
      org-babel-load-languages
      '((awk . t) (latex . t) (emacs-lisp . t) (ditaa . t) (shell . t)))
#+end_src

** Cosmetics, display, faces

*** Org-appear, for showing emphasis-markers etc. when inside :ARCHIVE:
#+begin_src emacs-lisp
(use-package org-appear
  :straight( :host github :repo "awth13/org-appear")
  :hook (org-mode . org-appear-mode)
  :custom (org-appear-delay 0.2))
#+end_src

*** Pretty display of todo keywords :ARCHIVE:
#+begin_src emacs-lisp
;; (add-hook 'org-font-lock-set-keywords-hook #'aj/org-prettify-todos)

;; (defun aj/org-prettify-todos ()
;;   ;; (make-local-variable 'font-lock-extra-managed-props)

;;   ;; bad idea to let font-lock manage display. this makes oc-csl-activate
;;   ;; not work at all.

;;   ;; (add-to-list 'font-lock-extra-managed-props 'display)

;;   (setq org-font-lock-extra-keywords
;;         (append org-font-lock-extra-keywords
;;                 (list
;;                  (list
;;                   (format "^\\(\\*+\\)\\( +%s\\)\\(?: +\\(.*?\\)\\)?[ 	]*$"
;; 			              org-todo-regexp)
;; 		          '(2 (list 'face
;;                             ;; 3 is the group from org-todo-regexp
;;                             (org-get-todo-face 3)
;;                             'display
;;                             (aj/org-prettify-todos-display (match-string 3)))
;;                       prepend))))))

;; (defun aj/org-prettify-todos-display (kw)
;;   (when kw (alist-get kw
;;                       '(("AVFÖRD" . "☒")
;;                         ("VÄNTAR" . "◫")
;;                         ("STARTAD" . "◧")
;;                         ("DONE" . "☑")
;;                         ("TODO" . "☐"))
;;                       kw nil #'equal)))


#+end_src

*** Fontify src blocks natively
#+begin_src emacs-lisp
(setq org-src-fontify-natively t)

;; (defun aj/org-avoid-hooks-in-fontify-block (fun lang beg end)
;;   (let* ((lang-mode (org-src--get-lang-mode lang))
;;          (hook (intern (concat (symbol-name lang-mode) "-hook"))))
;;     (if (and (fboundp lang-mode)
;;              (boundp hook))
;;         (cl-progv (list hook) (list nil)
;;           (funcall fun lang beg end))
;;       (funcall fun lang beg end))))

;; (advice-add 'org-src-font-lock-fontify-block :around
;;             #'aj/org-avoid-hooks-in-fontify-block)
#+end_src


*** Scaling command for org tables
Sometimes a table is too wide for the window width, and becomes unreadable when lines wrap. One workaround is to do some face remapping to scale down the ~org-table~ face. A command for that is defined here.
#+begin_src emacs-lisp
(defvar-local aj/org-table-scale-remapping nil)

(defun aj/org-table-scale-reset ()
  (interactive)
  (face-remap-remove-relative aj/org-table-scale-remapping)
  (setq aj/org-table-scale-remapping nil))

(defun aj/org-table-scale (&optional increase)
  (interactive "P")
  "Decrease the font-size of org tables in current buffer.
With a prefix argument, increase the size, with a double prefix
argument, reset to default."
  (if (equal increase '(16))
      (aj/org-table-scale-reset)
    (let ((current (car (cdr-safe (assq :height aj/org-table-scale-remapping)))))
      (aj/org-table-scale-reset)
      (setq aj/org-table-scale-remapping
            (face-remap-add-relative
             'org-table 'org-table
             (list :height (if current
                               (+ current (if increase 0.1 -0.1))
                             0.8)))))))
#+end_src

*** CHECK Special tag faces and highlighting of special headlines
Add special tag faces, add for file-local select/exclude-tags. Highlight the entire headline for some tags.
#+begin_src emacs-lisp
(defface aj/org-special-tags-face '((t . (:inherit org-tag :underline t)))
  "Face for special tags"
  :group 'aj)

(defface aj/org-select-tags-face
  '((t . (:inherit (hydra-face-teal aj/org-special-tags-face))))
  "Face for select tags"
  :group 'aj)
(defface aj/org-exclude-tags-face
  '((t . (:inherit (hydra-face-red aj/org-special-tags-face))))
  "Face for exclude tags"
  :group 'aj)
(defface aj/org-ignoreheading-tags-face
  '((t . (:inherit (hydra-face-amaranth aj/org-special-tags-face))))
  "Face for ignoreheading tags"
  :group 'aj)

(defface aj/org-select-line-face '((t . (:inherit (bold underline))))
  "Face for selected headlines"
  :group 'aj)
(defface aj/org-exclude-line-face '((t . (:inherit (shadow italic))))
  "Face for excluded headlines"
  :group 'aj)
(defface aj/org-ignoreheading-line-face '((t . (:inherit (shadow))))
  "Face for ignored headlines"
  :group 'aj)

;; set tags, independent of current buffer
(setq org-tag-faces
      `(("noexport" aj/org-exclude-tags-face)
        ("export" aj/org-select-tags-face)
        ("notitle" aj/org-special-tags-face)
        ,@(cl-loop for i in aj/org-ignoreheading-tags
                   collect (list i 'aj/org-ignoreheading-tags-face))
        ("stripheading" aj/org-ignoreheading-tags-face)
        ("read_only" :inherit (aj/org-special-tags-face hydra-face-pink))
        ,@(cl-loop
           for b in org-export-backends
           append
           (let ((s (symbol-name b)))
             `((,(concat "export_" s) aj/org-select-tags-face)
               (,(concat "noexport_" s) aj/org-exclude-tags-face))))))

(org-set-tag-faces 'org-tag-faces org-tag-faces)

;; set tags and headlines, dependent on buffer settings
(defvar aj/org-special-tag-headline-faces
  '(("noexport" nil aj/org-exclude-line-face)
    ("export" nil aj/org-select-line-face)
    ("notitle" nil aj/org-ignoreheading-line-face)
    ("stripheading" nil aj/org-ignoreheading-line-face)))

(defun aj/org-local-special-tag-faces ()
  "Possibly add local SELECT and EXCLUDE tags to
‘org-tag-faces’ in current buffer."
  (let ((extratags
         (append
          (cl-loop for s in (aj/org-get-buffer-defined-tags "SELECT_TAGS")
                   collect (list s 'aj/org-select-tags-face
                                 'aj/org-select-line-face))
          (cl-loop for e in (aj/org-get-buffer-defined-tags "EXCLUDE_TAGS")
                   collect (list e 'aj/org-exclude-tags-face
                                 'aj/org-exclude-line-face))))
        (ignoretags (cl-loop for i in aj/org-ignoreheading-tags
                             collect (list i 'aj/org-ignoreheading-tags-face
                                           'aj/org-ignoreheading-line-face))))
    ;; special tag faces
    (when (or extratags (local-variable-p 'aj/org-ignoreheading-tags))
      (setq-local
       org-tag-faces
       (append org-tag-faces
               (cl-loop for (tag tf _lf) in (append extratags ignoretags)
                        collect (list tag tf))))
      (make-local-variable 'org-tags-face-special-faces-re)
      (org-set-tag-faces 'org-tag-faces org-tag-faces))

    ;; fontify whole line for some of them
    (setq org-font-lock-extra-keywords
          (append org-font-lock-extra-keywords
                  (cl-loop
                   for (tag _tf lf) in
                   (append aj/org-special-tag-headline-faces extratags ignoretags)
                   collect
                   (list
                    (concat
                     "^\\*+"
                     "\\(?: "
                     org-todo-regexp
                     "\\)?" ; optional todo
                     "\\(?: +\\(?:\\[#.\\]\\)\\)?" ; prio
                     "\\(?: +\\(?4:.*?\\)\\)??" ; heading, :4
                     "\\(?::\\([[:alnum:]_@#%:]+\\)\\)?" ; maybe tags before
                     ":" tag ":"
                     "\\(\\(?:[[:alnum:]_@#%:]+\\):\\)?" ; maybe tags after
                     )
                    `(4 ',lf prepend)))))))

;; instead of executing org-export--get-inbuffer-options, a short
;; custom function to get select/exclude-tags in only current buffer.
;; (this ignores if select/exclude tags are defined in a SETUPFILE,
;; for some reason, using get-inbuffer-options was problematic with
;; the repeated activations of org-mode when using a SETUPFILE,
;; instead of debugging it thoroughly, this works ok)
(defun aj/org-get-buffer-defined-tags (tag)
  (let ((re (org-make-options-regexp (list tag))))
    (org-with-wide-buffer
     (goto-char (point-min))
     (cl-loop while (re-search-forward re nil t)
              append
              (let ((element (org-element-at-point)))
                (when (eq (org-element-type element) 'keyword)
                  (split-string (org-element-property :value element))))))))

(add-hook 'org-font-lock-set-keywords-hook #'aj/org-local-special-tag-faces)
#+end_src
*** Cdlatex and pretty entities sub-super don’t work well together.
#+begin_src emacs-lisp
(add-hook 'cdlatex-mode-hook (lambda () (when (eq major-mode 'org-mode)
                                     (setq-local org-pretty-entities-include-sub-superscripts nil))))
#+end_src

*** Alternating bullets for plain lists
#+begin_src emacs-lisp
(setq org-list-demote-modify-bullet '(("+" . "-") ("-" . "+")))
#+end_src

*** Tags column at 0, align tags with display property
I use variable-width fonts, so trying to align tags to the right using spaces is useless.

However, we can also use the display text property to align tags to the right of the window. This is already done in the agenda when setting ~org-agenda-tags-column~ to ~auto~, the default.

#+begin_src emacs-lisp
(setq org-tags-column 0
      org-auto-align-tags nil)

;; avoid unneccesary calculations, I never need it.
(defalias 'org-align-tags #'ignore)

;; Inspired by Ihor Radchenko’s code at: https://orgmode.org/list/87lfh745ch.fsf@localhost/

;; (add-hook 'org-font-lock-set-keywords-hook #'aj/org-set-tag-align-keywords)

(add-hook 'org-modern-mode-hook #'aj/org-set-tag-align-keywords)
(defun aj/org-set-tag-align-keywords ()
  (add-to-list 'font-lock-extra-managed-props 'org-tag-aligned)
  (font-lock-add-keywords nil '((yant/org-align-tags t)) 'append))
;; (defun aj/org-set-tag-align-keywords ()
;;   (add-to-list 'font-lock-extra-managed-props 'org-tag-aligned)
;;   (setq org-font-lock-extra-keywords
;;         (append
;;          org-font-lock-extra-keywords
;;          '((yant/org-align-tags t)))))

;; (defun aj/string-pixel-width (string &optional mode)
;;   "Calculate pixel width of STRING.
;; Optional MODE specifies major mode used for display."
;;   (let ((fra face-remapping-alist))
;;     (with-temp-buffer
;;       (with-silent-modifications
;;         (setf (buffer-string) string))
;;       (when (fboundp mode)
;;         (funcall mode)
;;         (font-lock-ensure))
;;       (setq-local face-remapping-alist fra)
;;       (if (get-buffer-window (current-buffer))
;; 	      (car (window-text-pixel-size nil (line-beginning-position) (point)))
;;         (set-window-buffer nil (current-buffer))
;;         (car (window-text-pixel-size nil (line-beginning-position) (point)))))))


(defun yant/org-align-tags (limit &optional force)
  "Align all the tags in org buffer."
  (save-match-data
    (when (eq major-mode 'org-mode)
      (let (;; (ellw (aj/string-pixel-width org-ellipsis))
            )
	    (while (re-search-forward "^\\*+ \\(.+?\\)\\([ \t]+\\)\\(:\\(?:[^ \n]+:\\)+\\)$" limit t)
	      (when (and (match-string 2)
		             (or force
			             (not (get-text-property (match-beginning 2) 'org-tag-aligned))))
	        (with-silent-modifications
              (put-text-property (match-beginning 2) (match-end 2) 'org-tag-aligned t)
	          (put-text-property
               (if (>= 2 (- (match-end 2) (match-beginning 2)))
				   (match-beginning 2)
			     ;; multiple whitespaces may mean that we are in process of typing
			     (1+ (match-beginning 2)))
			   (match-end 2)
			   'display
			   `(space . (:align-to
                          (- right
						     (,(+ 50 ;; 3 ;; no idea, but otherwise it is sometimes not enough
							      ;; ellw
                                  (if (match-beginning 3)
                                      (car (window-text-pixel-size nil (match-beginning 3) (match-end 3)))
                                    0))))))))))))))
#+end_src

*** org-fold-linebreaks-mode
Experimental mode for folding together paragraphs with one sentence per line (good for version control) to make them look nicer when displaying. Works with an overlay per line, so perhaps not so efficient.

#+begin_src emacs-lisp
(use-package org-fold-linebreaks
  :straight (:host 'gitlab :repo "andersjohansson/org-fold-linebreaks")
  :commands (org-fold-linebreaks org-fold-linebreaks-mode))
#+end_src

*** COMMENT Indent quote-blocks :ARCHIVE:
Trying to answer: https://emacs.stackexchange.com/questions/38570/org-mode-quote-block-indentation-highlighting

This works if ~org-indent-mode~ is not used. But I use it all the time so no use for me yet.
#+begin_src emacs-lisp
(add-hook 'org-font-lock-hook #'aj/org-indent-quotes)

(defun aj/org-indent-quotes (limit)
  (let ((case-fold-search t))
    (while (search-forward-regexp "^[ \t]*#\\+begin_quote" limit t)
      (let ((beg (1+ (match-end 0))))
        ;; on purpose, we look further than LIMTI
        (when (search-forward-regexp "^[ \t]*#\\+end_quote" nil t)
          (let ((end (1- (match-beginning 0)))
                (indent (propertize "    " 'face 'org-hide)))
            (add-text-properties beg end (list 'line-prefix indent
                                               'wrap-prefix indent))))))))

(add-hook 'org-font-lock-hook #'aj/org-indent-quotes)
(remove-hook 'org-font-lock-hook #'aj/org-indent-quotes)

;; (let ((indent
;;        (propertize
;;         (concat (when org-indent-mode
;;                   (get-text-property beg 'line-prefix))
;;                 "    ")
;;         'face 'org-hide))))



;; (defun aj/org-indent-quotes-indent-mode (beg end _)
;;   (when org-indent-mode
;;     (save-excursion
;;       (goto-char beg)
;;       (aj/org-indent-quotes end))))

;; (advice-add 'org-indent-refresh-maybe :after #'aj/org-indent-quotes-indent-mode)

;; (advice-remove 'org-indent-refresh-maybe #'aj/org-indent-quotes-indent-mode)

#+end_src
** org-word-count
https://github.com/tesujimath/org-wc
An ideally flexible org word count would be based on the parser in org-element, where the right stuff could be excluded.
This one is based on regex walking and skipping though. And that is quite fast.
#+begin_src emacs-lisp
(use-package org-wc
  :straight (:depth full :host github :repo "tesujimath/org-wc")
  :commands (org-word-count org-wc-count-subtrees org-wc-display org-wc-remove-overlays)
  :bind (:map org-mode-map
              ("C-c C-=" . org-wc-display)))
#+end_src

** org-num-mode -- overlays for numbering outlines
Org 9.3 introduces a brilliant real-time solution for numbering outlines while editing.

Previous, slow solution:
https://gitlab.com/andersjohansson/org-outline-numbering
#+begin_src emacs-lisp
(use-package org-num
  :straight nil
  :custom (org-num-skip-tags '("ARCHIVE" "noexport"))
  (org-num-skip-unnumbered t)
  (org-num-skip-commented t))
#+end_src

* Provide statement
#+begin_src emacs-lisp
(provide 'aj-org-config)
#+end_src

* Provide statement async :org_async:no_default_tangle:
#+begin_src emacs-lisp
(provide 'aj-org-config-org-async)
#+end_src

* Local variables for lisp :org_async:
#+begin_src emacs-lisp
;; Local Variables:
;; byte-compile-warnings: (not make-local docstrings)
;; End:
#+end_src

* Local Variables :ARCHIVE:

# Local Variables:
# eval: (progn (require 'use-package) (variable-pitch-mode -1))
# aj/inhibit-flyspell: t
# End:
