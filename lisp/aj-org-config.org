#+TITLE: Emacs org-mode config file
#+AUTHOR: Anders Johansson
#+PROPERTY: header-args :tangle yes :comments no :no-expand t
#+TODO: CHECK TODO | DONE

* Lexical-binding
#+BEGIN_SRC emacs-lisp
;; -*- lexical-binding: t -*-
#+END_SRC

* Org-config
** Customize some variables :org_async:
#+begin_src emacs-lisp
(setq
 org-hidden-keywords '(title author date)
 org-refile-allow-creating-parent-nodes 'confirm
 org-special-ctrl-k t
 org-fontify-quote-and-verse-blocks t
 org-fontify-done-headline nil
 org-adapt-indentation nil
 org-yank-adjusted-subtrees t
 org-catch-invisible-edits 'show
 org-footnote-define-inline t
 org-cycle-level-after-item/entry-creation nil
 org-blank-before-new-entry '((heading . auto) (plain-list-item . auto))
 org-cycle-separator-lines 0
 ;; we always want noexport etc. to be offered
 org-tag-persistent-alist '(("noexport") ("outline") ("ignoreheading") ("ignoreheadinglocal") ("read_only"))
 ;; I mostly don’t use fast-tag-selection, perhaps in special files
 ;; with specially defined tags
 org-use-fast-tag-selection 'auto
 ;; then it should be really quick
 org-fast-tag-selection-single-key t
 org-pretty-entities t
 org-pretty-entities-include-sub-superscripts nil
 org-highlight-latex-and-related '(latex script entities)
 org-src-tab-acts-natively t
 org-src-window-setup 'current-window
 org-edit-src-content-indentation 0
 org-edit-src-turn-on-auto-save t
 org-M-RET-may-split-line '((headline . t) (default . t))
 org-agenda-window-setup 'current-window
 ;; org-fontify-whole-heading-line t
 ;; org-level-color-stars-only t
 org-hide-emphasis-markers t
 org-highlight-latex-fragments-and-specials t
 org-startup-folded nil
 org-startup-indented t
 org-indent-indentation-per-level 2
 org-url-hexify-p nil)
#+END_SRC
** MobileOrg
#+begin_src emacs-lisp
(setq org-mobile-files (list org-directory)
      org-mobile-files-exclude-regexp "inbox"
      org-mobile-inbox-for-pull "~/org/inbox.org"
      org-mobile-directory "~/Dropbox/Apps/MobileOrg")
#+end_src
** Save org-files every hour
#+BEGIN_SRC emacs-lisp
;; (run-at-time "00:59" 3600 'org-save-all-org-buffers)
#+END_SRC
** Cosmetics, early definitions
*** Prettify-symbols replacements
**** Use prettify-symbols
Define a variable where symbols can be added for use later and enable prettify-symbols-mode for org
#+BEGIN_SRC emacs-lisp
(defvar aj/org-prettify-symbols nil)

(defun aj/org-enable-prettify ()
  (setq prettify-symbols-alist aj/org-prettify-symbols)
  (prettify-symbols-mode))

(add-hook 'org-mode-hook #'aj/org-enable-prettify)


;; helper macro to replace with longer string
;;from: https://emacs.stackexchange.com/a/34882
(defmacro aj/add-visual-replacement (from to alist)
  "Make `prettify-symbols-mode' replace string FROM with string TO.
Add this to ALIST that is like ‘prettify-symbols-alist’.

Each character of TO is vertically aligned using the baseline,
such that base-left of the character is aligned with base-right
of the preceding character.  Refer to `reference-point-alist'
for more information."
  `(push (cons ,from (let ((composition nil))
                       (dolist (char (string-to-list ,to)
                                     (nreverse (cdr composition)))
                         (push char composition)
                         (push '(Br . Bl) composition))))
         ,alist))


#+END_SRC
**** Prettify quote-blocks
#+begin_src emacs-lisp
;; (aj/add-visual-replacement "#+BEGIN_QUOTE" "▄▁▁▁▁▁▁▁▁▁▁▁▁▁▁" aj/org-prettify-symbols)
;; (aj/add-visual-replacement "#+begin_quote" "▄▁▁▁▁▁▁▁▁▁▁▁▁▁▁" aj/org-prettify-symbols)
;; (aj/add-visual-replacement "#+END_QUOTE"   "▔▔▔▔▔▔▔▔▔▔▔▔▔▔▀" aj/org-prettify-symbols)
;; (aj/add-visual-replacement "#+end_quote"   "▔▔▔▔▔▔▔▔▔▔▔▔▔▔▀" aj/org-prettify-symbols)

(dolist (kw '(("#+BEGIN_QUOTE" . ?❝)
              ("#+begin_quote" . ?❝)
              ("#+END_QUOTE" . ?❞)
              ("#+end_quote" . ?❞)))
  (add-to-list 'aj/org-prettify-symbols kw))


#+end_src
**** Prettify dashes
#+BEGIN_SRC emacs-lisp
(dolist (kw '(("--" . ?–)
              ("---" . ?—)))
  (add-to-list 'aj/org-prettify-symbols kw))
#+END_SRC

** Keybindings and templates
*** Special C-a, C-e
#+begin_src emacs-lisp
(setq org-special-ctrl-a/e t)

;; both org and visual-line-mode remaps ‘move-beginning/end-of-line’
;; and visual-line-modes binding takes precedence. Binding C-a and C-e
;; explicitly in ‘org-mode-map’ overrides this.
(bind-keys :map org-mode-map
           ("C-a" . org-beginning-of-line)
           ("C-e" . org-end-of-line))


#+end_src
*** Disable some disturbing keybindings
Disable keys for org-cycle-agenda-files, org-agenda-file-to-front etc.
I never use this.
#+BEGIN_SRC emacs-lisp
(define-key org-mode-map [(control ?,)] nil)
(define-key org-mode-map [(control ?\')] nil)
(define-key org-mode-map "\C-c[" nil)
(define-key org-mode-map "\C-c]" nil)
#+END_SRC
*** Speed commands on all stars
*** Speed command for "DONE"
#+BEGIN_SRC emacs-lisp
(add-to-list 'org-speed-commands-user
             '("T" . aj/org-done))

(defun aj/org-done ()
  (interactive)
  (org-todo 'done))
#+END_SRC
*** Add extra wrappers for smartparens
By default, ~smartparens-org~ defines wrappers for all the emphasize characters except ~+~.
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'smartparens-org
  (sp-local-pair 'org-mode "\\(" "\\)" :trigger "$$")
  ;; (sp-local-pair 'org-mode  "+" "+" :unless
  ;;                '(sp-point-after-word-p) :post-handlers '(("[d1]" "SPC")))
  )
#+END_SRC

*** Hydra for emphasize functions
An alternative to the smartparens solution.
#+BEGIN_SRC emacs-lisp
(defhydra hydra-org-emphasize (:color pink)
  "
Org emphasize: _b_old  _i_talic _u_nderline _c_ode _v_erbatim _s_trikethrough  _d_elete [_?_] _q_uit"
  ("b" (aj/org-toggle-emphasis "*") nil)
  ("i" (aj/org-toggle-emphasis "/") nil)
  ("u" (aj/org-toggle-emphasis "_") nil)
  ("c" (aj/org-toggle-emphasis "~") nil)
  ("v" (aj/org-toggle-emphasis "=") nil)
  ("s" (aj/org-toggle-emphasis "+") nil)
  ("*" (aj/org-toggle-emphasis "*") nil)
  ("/" (aj/org-toggle-emphasis "/") nil)
  ("_" (aj/org-toggle-emphasis "_") nil)
  ("~" (aj/org-toggle-emphasis "~") nil)
  ("=" (aj/org-toggle-emphasis "=") nil)
  ("+" (aj/org-toggle-emphasis "+") nil)
  ("d" (aj/org-toggle-emphasis "") nil)
  ("?" (org-info "Emphasis and monospace") nil)
  ("q" nil nil :exit t))

(bind-keys :map org-mode-map
           ("C-c u" . hydra-org-emphasize/body)
           ("C-c C-x C-f" . aj/org-toggle-emphasis))

(defun aj/org-toggle-emphasis (&optional wrap)
  (interactive)
  (let ((startpoint (point))
        (wrap (or wrap "/")))
    (if (org-region-active-p)
        (sp-wrap-with-pair wrap)
      (if (get-text-property startpoint 'org-emphasis)
          (let ((emph (plist-get (sp-get-enclosing-sexp) :op)))
            (if (equal emph wrap)
                (sp-unwrap-sexp)
              (sp-rewrap-sexp (cons wrap wrap))))
        (if (eolp)
            (progn (insert wrap wrap)
                   (backward-char))
          (er/expand-region 1)
          (sp-wrap-with-pair wrap))))))
#+END_SRC
*** Template inserting (hydra)
If before headline, insert options template with completion.

Otherwise hydra for template insertion.

#+begin_src emacs-lisp
(defvar aj/org-header-keywords-history nil)
(add-to-list 'savehist-additional-variables 'aj/org-header-keywords-history)
(defun aj/org-insert-header-keyword ()
  (interactive)
  (insert "#+"
          (completing-read "Keyword: "
                           (append org-options-keywords
                                   (mapcar (lambda (x) (concat x ":")) (org-get-export-keywords)))
                           nil t nil
                           aj/org-header-keywords-history)
          " "))

(require 'org-tempo)
(setq org-structure-template-alist
      '(("a" . "export ascii")
        ("c" . "center")
        ("C" . "comment")
        ("e" . "src emacs-lisp")
        ("E" . "example")
        ("h" . "export html")
        ("l" . "export latex")
        ("n" . "notes")
        ("q" . "quote")
        ("s" . "src")
        ("v" . "verse")
        ("x" . "export")))

(defun aj/org-insert-attr (str)
  (insert "#+attr_" str ": "))

(eval `(defhydra aj/hydra-org-template (:hint t :color blue :columns 4)
         "Great stuff"
         ,@(cl-loop for (key . word) in org-tempo-keywords-alist collect
                    (list key `(aj/org-keyword-expand ,key) word))
         ("I" (aj/org-keyword-expand "I") "include")
         ("ö l" (aj/org-insert-attr "latex") "attr_latex")
         ("ö h" (aj/org-insert-attr "html") "attr_html")
         ("ö r" (aj/org-insert-attr "reveal") "attr_reveal")
         ("." (org-insert-structure-template (read-string "Block type: ")) "Custom block type")
         ,@(cl-loop for (key . word) in org-structure-template-alist collect
                    (list key `(org-insert-structure-template ,word) word))))

(autoload 'org-tempo-complete-tag "org-tempo")
(defun aj/org-keyword-expand (str)
  "Expand ‘org-tempo-keywords-alist’ template."
  (insert "<" str)
  (org-tempo-complete-tag))

(defun aj/org-template-completion ()
  (interactive)
  (if (or (region-active-p) (looking-back "^" (point-at-bol)))
      (if (org-before-first-heading-p)
          (aj/org-insert-header-keyword)
        (aj/hydra-org-template/body))
    (self-insert-command 1)))

(bind-key "<" #'aj/org-template-completion org-mode-map)
#+end_src

*** Speed commands at more places?
#+BEGIN_SRC emacs-lisp
(defun aj/org-speed-command-here-p ()
  (and (looking-at org-outline-regexp) (looking-back "^\**" (point-at-bol))))

(setq org-use-speed-commands
      #'aj/org-speed-command-here-p)
#+END_SRC
*** Extra bindings
#+BEGIN_SRC emacs-lisp
(bind-keys :map org-mode-map
           ("C-c S-C-l" . org-store-link))


#+END_SRC
*** Hydra for some not bound commands :ARCHIVE:
#+BEGIN_SRC emacs-lisp
(defhydra hydra-org-commands (:color blue)
  "Org commands"
  ("s" (org-store-link) "store-link")
  ("q" nil "quit"))

(bind-keys :map org-mode-map
           ("C-c C-h" . hydra-org-commands/body)
           ("C-c h" . hydra-org-commands/body))
#+END_SRC
** Agenda, todo, scheduling etc.
*** Todo stuff
**** Todo keywords, Todo states
#+BEGIN_SRC emacs-lisp
(defface aj/org-waiting '((t :inherit org-formula :bold t)) "Face for waiting org-state" :group 'org-faces)
(defface aj/org-started '((t :inherit org-sexp-date :bold t :underline nil)) "Face for started org-state" :group 'org-faces)


;; more visible than default (cyan) in solarized (good for the small ❢)
(defface aj/org-todo '((t :inherit 'font-lock-warning-face :bold t)) "Face for todo org-state" :group 'org-faces)

(setq org-todo-keywords '((sequence "TODO(t)" "STARTAD(s)" "VÄNTAR(v)" "DONE(d)")
                          (sequence "|" "AVFÖRD(a)"))
      org-todo-keyword-faces
      '(("TODO" . aj/org-todo)
        ("STARTAD" . aj/org-started)
        ("VÄNTAR" . aj/org-waiting)
        ("AVFÖRD" . org-done)
        ("DONE" . org-done)))


(dolist (kw '(("TODO" . ?❢)
              ("DONE" . ?✔)
              ("STARTAD" . ?➠)
              ("VÄNTAR" . ?⌛)
              ("AVFÖRD" . ?✘)))
  (add-to-list 'aj/org-prettify-symbols kw))
#+END_SRC
**** Todo tree
I often find it useful to copy in a tree from somewhere (for instance reviewer comments on a scientific paper) and make every heading a TODO. This makes it easy!
#+BEGIN_SRC emacs-lisp
(defvar aj/org-todo-tree-maxlevel 100)

(defun aj/org-todo-tree (&optional maxlevel)
  "Make TODO states of all nodes in current tree and add [/]
A numeric prefix determines the depth where TODO states are created."
  (interactive "P")
  (let ((aj/org-todo-tree-maxlevel
         (if maxlevel (+ (org-current-level) (prefix-numeric-value maxlevel))
           100)))
    (org-map-tree #'aj/org-add-todo-and-cookie)))

(defun aj/org-add-todo-and-cookie ()
  "Add TODO if not in a TODO state and a [/]-cookie if there are children"
  (let ((level (org-current-level)))
    (unless (or (> level aj/org-todo-tree-maxlevel)
                (org-get-todo-state))
      (org-todo "TODO"))
    (when (and
           (not (>= level aj/org-todo-tree-maxlevel))
           (not (re-search-forward
		         "\\(\\[[0-9]*%\\]\\|\\[[0-9]*/[0-9]*\\]\\)"
		         (point-at-eol) t))
           (save-excursion (org-goto-first-child)))
      (let ((org-special-ctrl-a/e t)
            (visual-line-mode nil))
        (org-end-of-line)
        (insert " [/]")))))
#+END_SRC
**** Hierarchical TODO automatization
If you would like a TODO entry to automatically change to DONE when
all children are done, you can use the following setup:
#+begin_src emacs-lisp
(defun aj/org-summary-todo (n-done n-not-done)
  "Switch entry to DONE when all subentries are done, to TODO otherwise."
  (let (org-log-done org-todo-log-states)   ; turn off logging
    (org-todo (cond
               ((= n-not-done 0) "DONE")
               ((and (< 0 n-done) (< 0 n-not-done)
                     (member "STARTAD" org-not-done-keywords))
                "STARTAD")
               ;; I would like to put "STARTAD" if any of the children
               ;; were in a STARTAD state as well. But that would
               ;; require iterating through and checking each of the
               ;; children here, kind of repeating the logic in
               ;; ‘org-update-parent-todo-statistics’ again
               (t "TODO")))))

(add-hook 'org-after-todo-statistics-hook 'aj/org-summary-todo)
#+end_src
*** Agenda
**** Extra keybindings for agenda
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'org-agenda
  (bind-keys :map
             org-agenda-mode-map
             ;; I don’t use diary anyway:
             ("D" . aj/org-agenda-todo-to-done)
             ("C-z" . org-agenda-undo))
  (defun aj/org-agenda-todo-to-done () (interactive) (org-agenda-todo 'done)))
#+END_SRC
**** Agenda configuration variables
#+begin_src emacs-lisp
(setq org-log-into-drawer t
      org-clock-into-drawer t
      org-overriding-columns-format
      "%40ITEM(Task) %TODO %8Effort(Effort){:} %8CLOCKSUM %CLOCKSUM_T %CATEGORY %TAGS %DEADLINE %SCHEDULED %PRIORITY"
      org-habit-show-habits-only-for-today t
      org-habit-graph-column 50
      org-agenda-time-grid '((daily today require-timed)
                             (800 1000 1200 1300 1500 1700)
                             "......"
                             "----------------")
      org-agenda-columns-add-appointments-to-effort-sum t
      org-enforce-todo-dependencies t
      org-agenda-dim-blocked-tasks t
      ;; Don’t display deadlines too often
      org-agenda-skip-deadline-prewarning-if-scheduled t
      org-agenda-skip-deadline-if-done t
      ;; By default, I want a 10 day rolling agenda starting from today:
      org-agenda-span 10
      org-agenda-start-on-weekday nil
      org-agenda-start-day nil)

;; change agenda prefix format, add effort, wider categories
(with-eval-after-load 'org-agenda
  (setf (alist-get 'agenda org-agenda-prefix-format) " %i %-10c%?-12t% s%-4e"))
#+END_SRC
**** Hl-line-mode in agenda
#+begin_src emacs-lisp
(add-hook 'org-agenda-mode-hook #'hl-line-mode)
#+end_src

**** Agenda custom commands
#+BEGIN_SRC emacs-lisp
(setq org-agenda-custom-commands
      '(("n" "Agenda and all TODO's"
         ((agenda "")
          (alltodo "")))
        ("u" "Not scheduled or categorized" alltodo ""
         ((org-agenda-skip-function
           '(and
             ;; include those in the "osorterat" (unsorted) category
             (if (string= (org-get-category) "osorterat") nil (aj/org-return-next-hp))
             ;; If missing either sched, dead, or ts we should also
             ;; include it
             (or (org-agenda-skip-entry-if (quote scheduled) (quote deadline)
                                           (quote timestamp))
                 ;; also if subtasks are not scheduled
                 (aj/org-subscheduled))))
          (org-agenda-overriding-header "Osorterade eller ej schemalagda: ")))
        ("w" "Väntande" todo "VÄNTAR") ; waiting tasks
        ("j" "Bara jobb" agenda "" ((org-agenda-files aj/org-work-agenda-files)))
        ("d" "TODO in this dir" todo "" ((org-agenda-files (aj/org-files-in-project-dir))))))

(defun aj/org-files-in-project-dir ()
  (directory-files-recursively
   (or (locate-dominating-file default-directory ".git")
       default-directory)
   "\\.org$"))

(defun aj/org-return-next-hp (&optional same-level)
  "Return position of next heading, optionally on SAME-LEVEL."
  (save-excursion
	(if same-level
		(org-forward-heading-same-level 1 t)
	  (outline-next-heading))
	(1- (point))))

(defun aj/org-subscheduled ()
  "Skips trees with entire subtrees appropriately scheduled in some way."
  (let (subsc npos)
    (save-excursion
      (let ((level (org-current-level)))
        (org-get-heading t t)
        (while (and (setq npos (outline-next-heading)) (< level (org-current-level)))
          (push (and (org-agenda-skip-entry-if 'todo 'todo)
                     (org-agenda-skip-entry-if 'notscheduled)) subsc))))
    (if (and (not (null subsc)) (cl-every 'null subsc))
        ;; everything ok. skip to next heading of same level.
        (if (number-or-marker-p npos) (1- npos) (aj/org-return-next-hp))
      nil)))
#+END_SRC

**** Agenda categories icons :ARCHIVE:
I don’t use this now, can just put UTF-8, emojis and whatever in category names. Works well


I want to be able to use emojis \etc. But that doesn’t work with the way ~org-agenda-category-icon-alist~, hence the patch below.

#+begin_src emacs-lisp
(el-patch-feature org-agenda)
(with-eval-after-load 'org-agenda
  (el-patch-defun org-agenda-get-category-icon (category)
    "Return an image for CATEGORY according to `org-agenda-category-icon-alist'."
    (cl-dolist (entry org-agenda-category-icon-alist)
      (when (string-match-p (car entry) category)
        (el-patch-swap
          (if (listp (cadr entry))
	          (cl-return (cadr entry))
	        (cl-return (apply #'create-image (cdr entry))))
          (cond
           ((listp (cadr entry))
            (cl-return (cadr entry)))
           ((characterp (cadr entry))
            (cl-return (string (cadr entry))))
           (t
            (cl-return (apply #'create-image (cdr entry))))
           ))))))

(setq org-agenda-category-icon-alist
      '(("^C-.*" ?📅)))
#+end_src

**** External calendars
Currently I need to sync both with my work exchange server (via davmail) and some private google calendars.
***** Functions for syncing some or all external calendars
#+begin_src emacs-lisp
(defmacro aj/org-calendar-sync-external-defun (name probefile time syncform)
  "Defines function aj/org-calendar-sync-NAME for syncing external calendar.

PROBEFILE is a filename whose last modified time should reflect
the status of the sync, TIME is the number of after which a new
sync is expected, UPDATEFORM is the form to evaluate for
syncing."
  (declare (indent 1))
  `(defun ,(intern (concat "aj/org-calendar-sync-" name)) (&optional force)
     ,(concat "Sync external calendar " name ".")
     (interactive "P")
     (let ((mtime (nth 5 (file-attributes ,probefile))))
       (when (or force (not mtime)
                 (< ,(/ 24 time) (time-to-number-of-days (time-subtract (current-time) mtime))))
         ,syncform))))

(aj/org-calendar-sync-external-defun "gcal"
  "~/org/imp/G.org" 8 (call-process "aj-gcal-to-org"))
(aj/org-calendar-sync-external-defun "exchange"
  "~/org/imp/chalmerskalender.org" 3 (org-caldav-sync))

(defun aj/org-calendar-sync-all (&optional force)
  (interactive "P")
  (aj/org-calendar-sync-gcal force)
  (aj/org-calendar-sync-exchange force))

(defun aj/org-calendar-sync-all-redo-agenda ()
  (interactive)
  (aj/org-calendar-sync-all t)
  (org-agenda-redo t))

(add-hook 'org-agenda-finalize-hook #'aj/org-calendar-sync-all)

(with-eval-after-load 'org-agenda
  (bind-key "å" #'aj/org-calendar-sync-all-redo-agenda org-agenda-mode-map))
#+end_src

***** Syncing with org-caldav
Settings for calendars kept in custom.el
#+begin_src emacs-lisp
(use-package org-caldav
  :straight (:host github :repo "dengste/org-caldav")
  :config
  (setq org-icalendar-timezone "Europe/Stockholm"))
#+end_src

***** Syncing google calendar
Downloads and converts ics-files from google calendar (where I keep my appointments) to org. My script ~gcal-to-org~ calls the conversion script from here on all my calendars: http://perlstalker.vuser.org/blog/2014/06/04/importing-ical-into-org-mode/

*** Refile, and agenda refile settings
I want to be able to refile to all other agenda files, excluding files imported from google calendar (under "imp/" subdirectory).
In addition, eligible trees should not include TODO entries without subtasks.
#+BEGIN_SRC emacs-lisp
;; default targets: this file + agenda files
(setq org-refile-targets
      '((nil . (:maxlevel . 4))
        (aj/org-agenda-refile-targetfiles . (:maxlevel . 4))))

;; targets in agenda mode
(add-hook 'org-agenda-mode-hook #'aj/org-agenda-set-refile-targets)

(defun aj/org-agenda-set-refile-targets ()
  (setq-local org-refile-targets
              '((aj/org-agenda-refile-targetfiles . (:maxlevel . 4))))
  (setq-local org-refile-target-verify-function
              #'aj/org-entry-is-not-single-todo-done-p))

(defun aj/org-agenda-refile-targetfiles ()
  (cl-remove-if (apply-partially #'string-match "imp/")
                (org-agenda-files)))

(defun aj/org-entry-is-not-single-todo-done-p ()
  "Skips a heading which is in a TODO state but has no summary-cookie (or is DONE))"
  (let ((ts (org-get-todo-state)))
    (if (or (member ts org-done-keywords)
            (and (member ts org-todo-keywords-1)
                 (not (save-excursion
                        (search-forward-regexp
                         "\\[[0-9]+%\\]\\|\\[[0-9]+/[0-9]+\\]" (point-at-eol) t)))))
        (org-forward-heading-same-level 1 t) ;skip subtree and return nil
      t)))

(defun aj/org-entry-is-not-todo-done-p ()
  "Skips a heading with any TODO state."
  (if (member (org-get-todo-state) org-todo-keywords-1)
      (org-forward-heading-same-level 1 t) ;skip subtree and return nil
    t))

(put 'org-refile-target-verify-function 'safe-local-variable
     '(lambda (arg)
        (member arg '(aj/org-entry-is-not-todo-done-p
                      aj/org-entry-is-not-single-todo-done-p))))

#+END_SRC
**** Agenda evaluation :ARCHIVE:
#+begin_src emacs-lisp
(use-package aj-org-agendautv
  :load-path "~/kodat/elisp/org-weektree/"
  :commands (aj/org-agenda-weekplan-to-utv
             aj/org-agenda-morningplan aj/org-agenda-days-to-utv))
#+end_src
*** Times and clocking
**** Enable Swedish for parsing of names of weekdays and months
The date input prompt uses functionality from ~parse-time~. I want it to be able to guess from Swedish names for months and weekdays as well as English. This just means adding a few elements to the relevant lists (some of the names or abbreviations are identical in English and Swedish, e.g. "April").
#+BEGIN_SRC emacs-lisp
(with-eval-after-load "parse-time"
  (setq parse-time-months
        '(("jan" . 1) ("feb" . 2) ("mar" . 3) ("apr" . 4) ("may" . 5) ("jun" . 6)
          ("jul" . 7) ("aug" . 8) ("sep" . 9) ("oct" . 10) ("nov" . 11)
          ("dec" . 12) ("january" . 1) ("february" . 2) ("march" . 3)
          ("april" . 4) ("june" . 6) ("july" . 7) ("august" . 8) ("september" . 9)
          ("october" . 10) ("november" . 11) ("december" . 12) ("maj" . 5)
          ("okt" . 10) ("januari" . 1) ("februari" . 2) ("mars" . 3) ("juni" . 6)
          ("juli" . 7) ("augusti" . 8) ("oktober" . 10)))

  (setq parse-time-weekdays
        '(("sun" . 0) ("mon" . 1) ("tue" . 2) ("wed" . 3) ("thu" . 4) ("fri" . 5)
          ("sat" . 6) ("sunday" . 0) ("monday" . 1) ("tuesday" . 2)
          ("wednesday" . 3) ("thursday" . 4) ("friday" . 5) ("saturday" . 6)
          ("sön" . 0) ("mån" . 1) ("tis" . 2) ("ons" . 3) ("tor" . 4) ("fre" . 5)
          ("lör" . 6) ("söndag" . 0) ("måndag" . 1) ("tisdag" . 2) ("onsdag" . 3)
          ("torsdag" . 4) ("fredag" . 5) ("lördag" . 6))))
#+END_SRC

**** Calendar view, show iso-week (we often use week numbers in Sweden)
#+BEGIN_SRC emacs-lisp
(copy-face font-lock-constant-face 'calendar-iso-week-face)
(set-face-attribute 'calendar-iso-week-face nil
                    :height .7)
(setq calendar-intermonth-text
      '(propertize
        (format "%2d"
                (car
                 (calendar-iso-from-absolute
                  (calendar-absolute-from-gregorian (list month day year)))))
        'font-lock-face 'calendar-iso-week-face))

;; Title for week number
;; (copy-face 'default 'calendar-iso-week-header-face)
;; (set-face-attribute 'calendar-iso-week-header-face nil
;;                     :height 0.7)
;; (setq calendar-intermonth-header
;;       (propertize "Wk" ; or e.g. "KW" in Germany
;;                   'font-lock-face 'calendar-iso-week-header-face))
#+END_SRC
**** Auto deadline
#+BEGIN_SRC emacs-lisp
(defun aj/org-add-auto-deadline (force)
  "Inserts deadline based on scheduled time and effort."
  (interactive "P")
  (let* ((st (org-get-scheduled-time (point)))
         (dt (org-get-deadline-time (point)))
         (eff (org-entry-get nil org-effort-property))
         ;; (effs (* 60 (org-duration-string-to-minutes eff)))
         )
    (when (and
           (or force (not dt))
           st eff)
      (org--deadline-or-schedule nil 'deadline st)
      (org--deadline-or-schedule
       nil 'deadline
       (concat "++" eff)))))

(bind-key "C-c C-x C-d" #'aj/org-add-auto-deadline org-mode-map)
#+END_SRC


**** Clocking
***** Standard variables
#+begin_src emacs-lisp
(setq org-clock-persist 'history
      org-clock-history-length 10
      org-clock-x11idle-program-name "xprintidle"
      org-clock-idle-time 10
      org-clock-string-limit 25
      org-clock-in-switch-to-state "STARTAD")

(org-clock-persistence-insinuate)

;; don’t want unsafe variable complaints about this
(put 'org-clock-in-switch-to-state 'safe-local-variable 'stringp)
#+END_SRC

***** Only clock in items in a TODO state.
Add a function to ~org-clock-in-prepare-hook~, run in ~org-clock-in~, where we can throw ~abort~, to abort the clock-in.
#+begin_src emacs-lisp
(defun aj/org-only-clock-in-todos ()
  (unless (member (org-get-todo-state) org-not-done-keywords)
    (message "Not a todo item!")
    (throw 'abort nil)))

(add-hook 'org-clock-in-prepare-hook #'aj/org-only-clock-in-todos)
#+end_src

***** org-pomodoro
#+BEGIN_SRC emacs-lisp
(use-package org-pomodoro
  :init (let ((samesound
               "/usr/share/sounds/freedesktop/stereo/complete.oga"))
          (setq
           org-pomodoro-audio-player "paplay"
           org-pomodoro-finished-sound samesound
           org-pomodoro-long-break-sound samesound
           org-pomodoro-short-break-sound samesound
           org-pomodoro-overtime-sound samesound
           org-pomodoro-time-format "%.2m"
           org-pomodoro-format "P~%s"
           org-pomodoro-keep-killed-pomodoro-time t
           org-pomodoro-manual-break t))
  :config
  (alert-add-rule
   :category "org-pomodoro"
   :style 'libnotify
   :continue nil))
#+end_src

**** Clocksum variables, duration units, effort global properties
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'org-duration
  (setq org-duration-units
        `(("min" . 1)
          ("p" . 25) ; time of a pomodoro!
          ("h" . 60)
          ("d" . ,(* 60 8)) ; 8 hour work day
          ("w" . ,(* 60 8 5)) ; 5 days a week
          ("m" . ,(* 60 8 21)) ; 21 working days per month
          ("y" . ,(round (* 60 8 21 10.5))))
        ;; 10.5 such working months (because I have 31 days of
        ;; vacation. 🙌 Swedish working agreements)
        org-duration-format
        '(("m") ("w") ("d") ("h") (special . h:mm)))

  (org-duration-set-regexps))

;; :ETC makes these the values offered for completion, but won’t require a match
(add-to-list
 'org-global-properties
 '("Effort_ALL" . "0:15 1p 2p 3p 4p 1h 2h 3h 4h 6h 1d 2d 3d 4d 1w 2w 3w :ETC"))
#+END_SRC

**** Org clock with helm
#+BEGIN_SRC emacs-lisp
(advice-add 'org-clock-select-task :override #'aj/helm-org-clock-select-task)

(defun aj/helm-org-clock-select-task (&optional _prompt)
  "Select a task that was recently associated with clocking."
  (interactive)
  (let ((aj/helm-org-candidates-todo-only t)
        (helm-org-headings-actions '(("Clock in" . identity))))
    (or
     (helm :sources
           (append
            (list (aj/helm-org-clock-history))
            (helm-org-build-sources (org-agenda-files)))
           :candidate-number-limit 99999
           :buffer "*Helm org clock*")
     (user-error "No clock in task chosen"))))


;; TODO add sources for
;; org-clock-default task, interrupted-task, current clocking task
;; (when (marker-buffer org-clock-default-task)
;;   (insert (org-add-props "Default Task\n" nil 'face 'bold))
;;   (setq s (org-clock-insert-selection-line ?d org-clock-default-task))
;;   (push s sel-list))
;; (when (marker-buffer org-clock-interrupted-task)
;;   (insert (org-add-props "The task interrupted by starting the last one\n" nil 'face 'bold))
;;   (setq s (org-clock-insert-selection-line ?i org-clock-interrupted-task))
;;   (push s sel-list))
;; (when (org-clocking-p)
;;   (insert (org-add-props "Current Clocking Task\n" nil 'face 'bold))
;;   (setq s (org-clock-insert-selection-line ?c org-clock-marker))
;;   (push s sel-list))


(defun aj/helm-org-clock-history ()
  (let (och)
    ;; Remove successive dups from the clock history to consider
    (dolist (c org-clock-history)
      (unless (equal c (car och))
        (push c och)))
    (helm-build-sync-source "Recently clocked"
      :candidates
      (cl-loop for m in (reverse och)
               when (marker-buffer m)
               collect (aj/helm-org-clock-candidate m)))))

(defun aj/helm-org-clock-candidate (marker)
  (with-temp-buffer
    (let ((cm (org-clock-insert-selection-line 0 marker)))
      (goto-char (point-min))
      (cons (buffer-substring 4 (point-at-eol)) (cdr cm)))))

#+END_SRC

** org-id, add id's in this file! And for all org files in a directory.
#+begin_src emacs-lisp
(defun aj/org-id-update-id-locations-from-file ()
  (interactive)
  (when-let (fn (buffer-file-name))
    (org-id-update-id-locations (list fn))))

(defun aj/org-id-update-id-locations-recursive (dir)
  (interactive "D")
  (org-id-update-id-locations
   (directory-files-recursively dir ".*\\.org$" nil t t)))
#+end_src

** Visibility, folding, display etc.
*** Make visibility property "folded" behave as if subtree was archived, i.e. always hidden after visibility cycling
This is based on ~org-cycle-hide-archived-trees~.
#+BEGIN_SRC emacs-lisp
(add-hook 'org-cycle-hook #'aj/org-cycle-hide-folded-trees)

(defun aj/org-cycle-hide-folded-trees (state)
  "Re-hide all trees with visibility folded after a visibility state change.
STATE should be one of the symbols listed in the docstring of
`org-cycle-hook'."
  (when (not (or org-cycle-open-archived-trees ; just re-use this
                 (memq state '(overview folded))))
    (save-excursion
      (let* ((globalp (memq state '(contents all)))
             (beg (if globalp (point-min) (point)))
             (end (if globalp (point-max) (org-end-of-subtree t))))
        (aj/org-hide-folded-trees beg end)
        (goto-char beg)
        (when (equal "folded" (org-entry-get (point) "visibility"))
          (message "%s" (substitute-command-keys
                         "Subtree has VISIBILITY: folded, and stays closed.  Use \
`\\[org-force-cycle-archived]' to cycle it anyway.")))))))

(defun aj/org-hide-folded-trees (beg end)
  "Re-hide all subtrees with visibility folded after a visibility state change."
  (org-with-wide-buffer
   (let ((case-fold-search nil)
         (re ":VISIBILITY: folded"))
     (goto-char beg)
     (beginning-of-line) ; Include headline point is currently on.
     (while (and (< (point) end) (search-forward re end t))
       (org-set-visibility-according-to-property)))))
#+END_SRC

*** Read-only-trees
Trees can be defined as read only with tag ~read_only~
From: http://kitchingroup.cheme.cmu.edu/blog/2014/09/13/Make-some-org-sections-read-only/
#+BEGIN_SRC emacs-lisp
(defface aj/org-readonly-face '((t . (:inherit fringe)))
  "Face for read-only-sections"
  :group 'aj)

(defun aj/org-mark-readonly (&rest _ignore)
  (interactive)
  (unless (eq 0 (buffer-size))
    (org-map-entries
     (lambda ()
       (let* ((element (org-element-at-point))
              (begin (org-element-property :begin element))
              (end (org-element-property :end element)))
         (add-text-properties begin (- end 1)
                              '(read-only t font-lock-face aj/org-readonly-face))))
     "read_only" 'file)))

(defun aj/org-remove-readonly (&rest _ignore)
  (interactive)
  (org-map-entries
   (lambda ()
     (let* ((element (org-element-at-point))
            (begin (org-element-property :begin element))
            (end (org-element-property :end element))
            (inhibit-read-only t))
       (remove-text-properties begin (- end 1) '(read-only t font-lock-face aj/org-readonly-face))))
   "read_only" 'file))

(add-hook 'org-mode-hook #'aj/org-mark-readonly)

;; make tags editable
(advice-add 'org-set-tags-command :before #'aj/org-remove-readonly)
(advice-add 'org-set-tags-command :after #'aj/org-mark-readonly)
(advice-add 'orgqda-helm-tags-set-tags :before #'aj/org-remove-readonly)
(advice-add 'orgqda-helm-tags-set-tags :after #'aj/org-mark-readonly)
#+END_SRC

*** Version of ~org-tree-to-indirect-buffer~ that works as I want it to
That is, always create a new buffer. (Is there anything more changed?)
#+BEGIN_SRC emacs-lisp
(defun aj/org-tree-to-indirect-buffer ()
  "My own simple version of `org-tree-to-indirect-buffer'"
  (interactive)
  (let ((cbuf (current-buffer))
        (cwin (selected-window))
        (pos (point))
        beg end heading ibuf)
    (save-excursion
      (org-back-to-heading t)
      (setq beg (point)
            heading (org-get-heading 'no-tags))
      (org-end-of-subtree t t)
      (when (org-at-heading-p) (backward-char 1))
      (setq end (point)))
    (setq ibuf (org-get-indirect-buffer cbuf heading)
          org-last-indirect-buffer ibuf)
    (pop-to-buffer ibuf)
    (narrow-to-region beg end)
    (outline-show-all)
    (goto-char pos)
    (run-hook-with-args 'org-cycle-hook 'all)
    (and (window-live-p cwin) (select-window cwin))))

(bind-key "C-c C-x b" #'aj/org-tree-to-indirect-buffer org-mode-map)
#+END_SRC

** COMMENT Linking, link-types
*** COMMENT org-pdfview
#+begin_src emacs-lisp
(with-eval-after-load 'org-pdfview
  ;; (advice-add 'org-pdfview-open :override #'aj/org-pdfview-open)

  ;; (defun aj/org-pdfview-open (link)
  ;;   "Open LINK in pdf-view-mode."
  ;;   (cond ((string-match "\\(.*\\)::\\([0-9]+\\)\\+\\+\\([[0-9]\\.*[0-9]*\\)"  link)
  ;;          (let* ((path (match-string 1 link))
  ;;                 (page (match-string 2 link))
  ;;                 (height (string-to-number (match-string 3 link))))
  ;;            (org-open-file path 1)
  ;;            (pdf-view-goto-label page)
  ;;            (image-set-window-vscroll
  ;;             (round (/ (* height (cdr (pdf-view-image-size))) (frame-char-height))))))
  ;;         ((string-match "\\(.*\\)::\\([0-9]+\\)$"  link)
  ;;          (let* ((path (match-string 1 link))
  ;;                 (page (string-to-number (match-string 2 link))))
  ;;            (org-open-file path 1)
  ;;            (pdf-view-goto-page page)))
  ;;         (t
  ;;          (org-open-file link 1))
  ;;         ))
  )

#+end_src
** org-download
#+BEGIN_SRC emacs-lisp
(use-package org-download
  :init (org-download-enable)
  :commands (org-download-enable)
  :config
  (setq org-download-backend 'curl)
  (setq-default org-download-heading-lvl nil
                org-download-image-dir "./bilder"))

#+END_SRC
** File-associations, opening links externally :org_async:
#+BEGIN_SRC emacs-lisp
(add-to-list 'org-file-apps '("\\.pdf\\'" . emacs)) ; open pdfs in emacs
;;use xdg-open instead of mailcap
;; this won’t work in a real console, but I won’t open files from org in a real console
(setq org-file-apps-defaults-gnu '((remote . emacs) (system . "aj-open %s") (t . "aj-open %s")))

;; disassociates started processes so they wont get killed if emacs is killed.
(advice-add 'org-open-file :around  #'aj/org-open-file-around-advice)
(defun aj/org-open-file-around-advice (fn &rest args)
  "Set `process-connection-type' to nil"
  (let ((process-connection-type nil))
    (apply fn args)))

(defun aj/org-open-file-with-system (path)
  (org-open-file path 'system))
#+END_SRC
** Local variables headings
A local variables comment block that is placed at the end of the file may be lost or moved if the last subtree (under which it is viewed as being filed) is removed or moved. We don’t want that! Instead, automatically place local variables under their own top-level heading. By default I put the ~ARCHIVE~ tag on this heading, to hide it away a bit and avoid exporting it.
#+BEGIN_SRC emacs-lisp
(defun aj/org-insert-local-variable-heading (&rest _args)
  "Insert a heading under which local variables can be stored, if not already present"
  (when (eq major-mode 'org-mode)
    (push-mark)
    (save-excursion
      (save-restriction
        (widen)
        (goto-char (point-max))
        ;;this is maybe done in a more stable way in `modify-file-local-variable'
        (unless (search-backward-regexp "^\\* \\(COMMENT \\)?Local [Vv]ariables\\( :ARCHIVE:\\)?"
                                        (max (- (point-max) 3000) (point-min)) t)
          (if (search-backward-regexp "^\\# Local [Vv]ariables:" nil t)
              (open-line 1)
            (newline))
          (insert "\n* Local Variables :ARCHIVE:\n"))))))

(advice-add 'add-file-local-variable :before #'aj/org-insert-local-variable-heading)
#+END_SRC

** COMMENT org-db
#+begin_src emacs-lisp
(use-package org-db
  :load-path "~/kodat/elisp/org-db"

  )

(aj/org-db-find-tag)
(defun aj/org-db-find-tag ()
  (interactive)
  (let ((tag
         (helm :sources
               (helm-build-sync-source "Tags"
                 :candidates (cl-loop for (id name) in (emacsql org-db [:select * :from tags])
                                      collect (list name name id))
                 :fuzzy-match t))))


    (helm :sources
          (helm-build-sync-source (format "Tagged: %s" (car tag))
            :fuzzy-match t
            :candidates
            (cl-loop
             for (file hl beg) in
             (emacsql org-db [:select :distinct [files:filename headlines:title headlines:begin]
                                      :from headlines
                                      :inner :join headline-tags :on (= headlines:rowid headline-tags:headline-id)
                                      :inner :join files :on (= headlines:filename-id files:rowid)
                                      :where (= headline-tags:tag-id $s1)]
                      (cadr tag))
             collect (list (format "%s:%s" file hl) file beg))
            :action '(("Open" . (lambda (x)
                                  (find-file (car x))
                                  (goto-char (cadr x))
                                  (org-show-entry))))))))
#+end_src

** Navigation etc. (helm-org)
*** helm-org
#+BEGIN_SRC emacs-lisp
(use-package helm-org
  :custom (helm-org-format-outline-path t)
  :commands helm-org-goto-marker
  :bind (:map org-mode-map
              ("<f2>" . helm-org-in-buffer-headings)
              :map helm-org-headings-map
              ("C-c C-x b" . helm-org-run-open-heading-in-indirect-buffer))
  :config
  (advice-add 'helm-org-insert-link-to-heading-at-marker :override
              #'aj/helm-org-insert-link-to-heading-at-marker)

  (defun aj/helm-org-insert-link-to-heading-at-marker (_c)
    "Alternative to `helm-org-insert-link-to-heading-at-marker'
Uses CUSTOM_ID or `org-store-link' for linking."
    (dolist (marker (helm-marked-candidates))
      (let (link)
        (with-current-buffer (marker-buffer marker)
          (save-excursion
            (goto-char (marker-position marker))
            (let ((custom-id (org-entry-get nil "CUSTOM_ID"))
                  (id (org-entry-get nil "ID"))
                  (file-name (buffer-file-name)))
              (setq link
                    (cond
                     (custom-id
                      (org-link-make-string
                       (if (string= (with-helm-current-buffer
                                      (buffer-file-name))
                                    file-name)
                           (concat "#" custom-id)
                         (concat "file:" (abbreviate-file-name
                                          file-name) "::#" custom-id))))
                     (id
                      (org-id-store-link))
                     (t (org-store-link nil nil))))))
          (with-helm-current-buffer
            (insert link " "))))))

  (advice-add 'helm-org--open-heading-in-indirect-buffer :override
              #'aj/helm-org--open-heading-in-indirect-buffer)

  (defun aj/helm-org--open-heading-in-indirect-buffer (marker)
    (save-excursion (helm-org-goto-marker marker)
                    (aj/org-tree-to-indirect-buffer))))
#+END_SRC

*** Redefine ~helm-org--get-candidates-in-file~
Use ~org-scan-tags~ to get some exclusion tools. Note that also ~org-agenda-skip-archived-trees~, ~org-agenda-skip-comment~, and ~org-agenda-skip-function~ can be let-bound to have effects here.

Should check if it’s less efficient doing this than the homegrown mapping in helm-org. Right now it actually feels snappier, maybe because it excludes unneeded headings.

#+BEGIN_SRC emacs-lisp
(defvar aj/helm-org-candidates-matcher t)
(defvar aj/helm-org-candidates-todo-only nil)

(advice-add 'helm-org--get-candidates-in-file :around
            #'aj/helm-org--get-candidates-in-file)

(defun aj/helm-org--get-candidates-in-file (fun filename &optional fontify nofname parents matcher _force-refresh)
  (if parents ;; won’t handle that special case
      (funcall fun filename fontify nofname parents)
    (with-current-buffer (pcase filename
                           ((pred bufferp) filename)
                           ((pred stringp) (find-file-noselect filename t)))
      (org-agenda-prepare-buffers (list filename))
      (let ((match-fn (if fontify
                          #'match-string
                        #'match-string-no-properties))
            (matcher (or matcher aj/helm-org-candidates-matcher))
            (file (unless nofname
                    (concat (helm-basename filename) ":")))
            (width (window-width (helm-window))))
        (save-excursion
          (save-restriction
            (unless (and (bufferp filename)
                         (buffer-base-buffer filename))
              ;; Only widen direct buffers, not indirect ones.
              (widen))
            ;; clear cache for new version of org-get-outline-path
            (and (boundp 'org-outline-path-cache)
                 (setq org-outline-path-cache nil))
            (cl-remove-if
             #'null
             (org-scan-tags
              (lambda ()
                (goto-char (point-at-bol))
                (when (looking-at org-complex-heading-regexp)
                  (let ((beg (point-at-bol))
                        (end (point-at-eol))
                        (level (length (match-string-no-properties 1)))
                        (heading (funcall match-fn 4)))
                    (when (and fontify
                               (null (text-property-any
                                      beg end 'fontified t)))
                      (jit-lock-fontify-now beg end))
                    (when (and (>= level helm-org-headings-min-depth)
                               (<= level helm-org-headings-max-depth))
                      (propertize
                       (if helm-org-format-outline-path
                           (org-format-outline-path
                            (org-get-outline-path t t) width file)
                         (if file
                             (concat file (funcall match-fn 0))
                           (funcall match-fn 0)))
                       'helm-real-display heading
                       'helm-realvalue
                       (set-marker (make-marker) (point-at-eol)))))))
              matcher aj/helm-org-candidates-todo-only))))))))

;; (defun aj/helm-org--get-candidates-in-file (fun filename &optional fontify nofname parents matcher force-refresh)
;;   (if parents ;; won’t handle that special case
;;       (funcall fun filename fontify nofname parents)
;;     (with-current-buffer (pcase filename
;;                            ((pred bufferp) filename)
;;                            ((pred stringp) (find-file-noselect filename t)))
;;       (let ((tick (buffer-chars-modified-tick)))
;;         (if (and helm-org--buffer-tick
;;                  (= tick helm-org--buffer-tick)
;;                  (null force-refresh))
;;             helm-org--headers-cache
;;           (set (make-local-variable 'helm-org--buffer-tick) tick)
;;           (org-agenda-prepare-buffers (list filename))
;;           (prog1
;;               (setq-local
;;                helm-org--headers-cache
;;                (let ((match-fn (if fontify
;;                                    #'match-string
;;                                  #'match-string-no-properties))
;;                      (matcher (or matcher aj/helm-org-candidates-matcher))
;;                      (file (unless nofname
;;                              (concat (helm-basename filename) ":")))
;;                      (width (window-width (helm-window))))
;;                  (save-excursion
;;                    (save-restriction
;;                      (unless (and (bufferp filename)
;;                                   (buffer-base-buffer filename))
;;                        ;; Only widen direct buffers, not indirect ones.
;;                        (widen))
;;                      ;; (unless parents (goto-char (point-min)))
;;                      ;; clear cache for new version of org-get-outline-path
;;                      (and (boundp 'org-outline-path-cache)
;;                           (setq org-outline-path-cache nil))
;;                      (cl-remove-if
;;                       #'null
;;                       (org-scan-tags
;;                        (lambda ()
;;                          (goto-char (point-at-bol))
;;                          (when (looking-at org-complex-heading-regexp)
;;                            (let ((beg (point-at-bol))
;;                                  (end (point-at-eol))
;;                                  (level (length (match-string-no-properties 1)))
;;                                  (heading (funcall match-fn 4)))
;;                              (when (and fontify
;;                                         (null (text-property-any
;;                                                beg end 'fontified t)))
;;                                (jit-lock-fontify-now beg end))
;;                              (when (and (>= level helm-org-headings-min-depth)
;;                                         (<= level helm-org-headings-max-depth))
;;                                (propertize
;;                                 (if helm-org-format-outline-path
;;                                     (org-format-outline-path
;;                                      (org-get-outline-path t t) width file)
;;                                   (if file
;;                                       (concat file (funcall match-fn 0))
;;                                     (funcall match-fn 0)))
;;                                 'helm-real-display heading
;;                                 'helm-realvalue
;;                                 (set-marker (make-marker) (point-at-eol)))))))
;;                        matcher aj/helm-org-candidates-todo-only))))))))))))
#+END_SRC

**** Some tests for this  :ARCHIVE:
#+BEGIN_SRC emacs-lisp
(defun aj/measure-helm-org-cands (times name)
  "Measure the time it takes to evaluate BODY."
  (let ((time (current-time)))
    (dotimes (i times)
      (setq helm-org--headers-cache nil)
      (helm-org--get-candidates-in-file (buffer-file-name)))
    (format "%s: %.06f" name (float-time (time-since time)))))

(defun aj/helm-org-test (times)
  (interactive "p")
  (let ((times (or (and (< 1 times) times) 100))
        listan)
    (advice-remove 'helm-org--get-candidates-in-file
                   #'aj/helm-org--get-candidates-in-file)
    (push (aj/measure-helm-org-cands times "Old") listan)
    (advice-add 'helm-org--get-candidates-in-file :around
                #'aj/helm-org--get-candidates-in-file)
    (push (aj/measure-helm-org-cands times "New with exclusions") listan)
    (let ((org-agenda-skip-archived-trees nil) (org-agenda-skip-comment-trees nil))
      (push (aj/measure-helm-org-cands times "New with archived etc.") listan))
    (message (mapconcat #'identity listan "\n"))))
#+END_SRC

*** Redefine ~helm-org-in-buffer-preselect~
This works better for my purposes.
#+BEGIN_SRC emacs-lisp
(defun aj/helm-org-in-buffer-preselect ()
  (condition-case nil
      (concat (org-get-heading t t t t) "$")
    (error nil)))

(advice-add 'helm-org-in-buffer-preselect :override #'aj/helm-org-in-buffer-preselect)
#+END_SRC
*** helm-org-rifle
Similar in aim to ~helm-org-in-buffer-headings~, but for searching inside entries.
#+BEGIN_SRC emacs-lisp
(use-package helm-org-rifle
  :commands helm-org-rifle helm-org-rifle-current-buffer
  :init (bind-keys :map org-mode-map
                   ("C-<f2>" . helm-org-rifle-current-buffer)
                   ("S-<f2>" . helm-org-rifle))
  (setq helm-org-rifle-show-path t
        helm-org-rifle-show-tags t))
#+END_SRC

*** helm-org + helm-org-rifle: Make display of headings focus on first and last
#+BEGIN_SRC emacs-lisp
(defun aj/override-org-format-outline-path (fn &rest rest)
  (cl-letf (((symbol-function 'org-format-outline-path)
             #'aj/org-format-outline-path))
    (apply fn rest)))

(advice-add 'helm-org--get-candidates-in-file
            :around
            #'aj/override-org-format-outline-path)
(advice-add 'helm-org-rifle--get-candidates-in-buffer
            :around
            #'aj/override-org-format-outline-path)


;; This function has kind of involved and not very smart logic really.
;; It gives a reasonable result though
(defun aj/org-format-outline-path (path &optional width prefix separator)
  (let* ((width (or width (window-width (helm-window)) 70))
         ;; (width (round (* width 1.25))) ;; var-width font gives more room
         (path (delq nil path))
         (separator (or separator "/"))
         (org-odd-levels-only nil)
         (fontified
          (cl-loop for head in path
                   for n from 0
                   collect
                   (replace-regexp-in-string
                    "[ \t]+\\'"
                    ""
                    (org-add-props
                        head nil 'face
                        (nth (% n org-n-level-faces) org-level-faces)))))
         (first (car fontified))
         (last (when (< 1 (length fontified))
                 (car (last fontified))))
         (fwidth (length first))
         (lwidth (length last))
         (middle
          (when (< 2 (length fontified))
            (mapconcat #'identity (cl-subseq fontified 1 -1) separator)))
         (rwidth (- width (length prefix) (* 2 (length separator) 2))) ; possible width for only first+last
         (diff (- rwidth fwidth lwidth))
         fpath)
    (if (< diff 0)
        (if (null last)
            (setq fpath (car (last fontified)))
          (cond
           ((< (* 1.5 rwidth) (+ fwidth lwidth))
            (setq last (substring last 0 (floor (min (length last) (* .6 rwidth)))))
            (setq first (substring first 0 (floor (min (length first) (* .3 rwidth))))))
           ((< lwidth (* .25 rwidth))
            (setq first (substring first 0 diff)))
           ((< fwidth (* .25 rwidth))
            (setq last (substring last 0 diff)))
           (t
            (let* ((lastrem (max (floor (/ (- lwidth) 2)) (floor (* 0.3 diff))))
                   (firstrem (- diff lastrem)))
              (setq last (substring last 0 lastrem))
              (unless (> 0 firstrem) ; 0 means don’t remove! <0 is a problem
                (setq first (substring first 0 firstrem))))))
          (setq fpath (concat
                       prefix (and prefix separator)
                       first separator ".." separator last)))
      (if (< 2 (length fontified))
          (let* ((remains (- width fwidth lwidth
                             (* 2 (length separator)) (length prefix) 4)))
            (when (> (length middle) remains)
              (setq middle (concat (substring middle 0 remains) "..")))
            (setq fpath (concat
                         prefix (and prefix path separator)
                         first separator middle separator last)))
        (setq fpath (concat
                     prefix (and prefix path separator)
                     first (and last separator) last))))
    fpath))

;; (defun aj/test-op ()
;;   (interactive)
;;   (message
;;    (aj/org-format-outline-path
;;     (org-get-outline-path t t)
;;     (window-width)
;;     nil "/")))
#+END_SRC


*** Refile with helm
Present a nicer-looking helm buffer for ~org-refile~
#+begin_src emacs-lisp
(setq org-refile-use-outline-path t
      org-outline-path-complete-in-steps nil)

(add-to-list 'helm-completing-read-handlers-alist
             '(org-refile . helm-aj/org-refile-handler))

(defun helm-aj/org-refile-handler (prompt collection test
                                          _require-match init hist
                                          default _iim name buffer)

  (let ((helm-truncate-lines nil))
    (helm-comp-read prompt (mapcar #'car collection)
                    :test test :initial-input init :default default
                    :history hist :multiline nil :nomark t
                    :fc-transformer #'aj/helm-org-hl-transformer
                    :name name :buffer buffer)))

(defun aj/helm-org-hl-transformer (tbl _s)
  (mapcar #'aj/org-outline-propertize tbl))

;; perhaps not the most efficient way of doing this:
(defun aj/org-outline-propertize (outline-path)
  (cl-loop with n = (length org-level-faces)
           with i = -1
           for p in (split-string outline-path "/")
           do (cl-incf i)
           collect (propertize p 'face (nth (mod i n) org-level-faces)) into l
           finally return (mapconcat #'identity l "/")))


#+end_src
** Redefine ~org-paste-special~ to choose from kill-ring (with helm)
If we have inadvertantly killed something between the special kill and yank we intended, we are then given an opportunity to easily choose the right thing to yank.
#+BEGIN_SRC emacs-lisp
(defalias 'org-paste-special 'aj/org-paste-special)

(defun aj/org-paste-special (arg)
  "Paste rectangular region into table, or paste subtree relative to level.
Calls `org-table-paste-rectangle' or `aj/org-paste-subtree', depending on context.
See the individual commands for more information."
  (interactive "P")
  (if (org-at-table-p)
      (org-table-paste-rectangle)
    (aj/org-paste-subtree arg)))

(defun aj/org-paste-subtree (arg)
  (interactive "P")
  (let ((tree (and kill-ring (current-kill 0))))
    (unless (org-kill-is-subtree-p tree)
      (setq tree (aj/helm-choose-kill-ring)))
    (org-paste-subtree arg)))


;; all this is reimplemented here since the normal actions and stuff
;; for `helm-show-kill-ring' doesn’t match the intended usage (just
;; return the value) here.
(defun aj/helm-choose-kill-ring ()
  "Helm for choosing an element in `kill-ring' and moving it to head"
  (interactive)
  (let ((enable-recursive-minibuffers t))
    (helm :sources aj/helm-source-kill-ring-choose
          :buffer "*helm kill ring choose*"
          :resume 'noresume
          :allow-nest t)))

(defvar aj/helm-source-kill-ring-choose
  (helm-build-sync-source "Kill Ring"
    :nomark t
    :candidates #'helm-kill-ring-candidates
    :filtered-candidate-transformer #'helm-kill-ring-transformer
    :action '(("Return + front" . aj/helm-kill-ring-choose-action))
    :multiline t)
  "Source for browsing the kill-ring and returning an entry which
  is placed first in the ring")

(defun aj/helm-kill-ring-choose-action (_candidate)
  "Return selected helm candidate and move it to head of `kill-ring'"
  (let ((str (helm-get-selection nil 'withprop)))
    (with-helm-current-buffer
      (setq kill-ring (delete str kill-ring))
      (kill-new str)
      str)))

(dolist (fn '(helm-kill-ring-candidates helm-kill-ring-transformer))
  (autoload fn "helm-ring"))
#+END_SRC

** Extra org-entities :org_async:
#+begin_src emacs-lisp
(add-to-list 'org-entities-user '("slash" "\\slash{}" nil "/" "/" "/" "/"))
(add-to-list 'org-entities-user '("textelp" "\\textelp{}" nil "[…]" "[...]" "[...]" "[…]"))
#+end_src

** Archiving hierarchically
I want my archive files to retain some structure, placing archived entries in a copy of the branches above.

Adapted from code by Florian Adamsky, now here:
https://gitlab.com/andersjohansson/org-archive-hierarchically
#+BEGIN_SRC emacs-lisp
  (use-package org-archive-hierarchically
	:straight nil ; TODO fix
	:load-path "~/kodat/elisp/org-archive-hierarchically"
	:commands org-archive-hierarchically
	:init (setq org-archive-default-command #'org-archive-hierarchically))
#+END_SRC

** Org capture
*** Capture templates
(private and kept in custom.el)
#+begin_src emacs-lisp
(setq org-default-notes-file (expand-file-name "notes.org" org-directory))
#+end_src
*** Ensure line break in captured section
I often mess up and remove the last line-break in the capture buffer. This can inadvertantly include the [[file:~/.emacs.d/lisp/aj-org-config.org::*Local%20variables%20headings][Local variables heading]] that is below the last captured headline under this headline.
This function run with ~org-capture-prepare-finalize-hook~ avoids this problem by always making sure we have at least one linebreak at the end of the capture buffer.

#+BEGIN_SRC emacs-lisp
(defun aj/ensure-linebreak-at-eob ()
  (unless (progn (goto-char (point-max))
                 (looking-back "
" 1))
    (insert "\n")))

(add-hook 'org-capture-prepare-finalize-hook #'aj/ensure-linebreak-at-eob)
#+END_SRC

*** Capture help functions
**** Use a datetree only down to month
This function can be used for ~file+function~ targets in capture templates
#+begin_src emacs-lisp
(require 'org-datetree)

(defun aj/org-datetree-find-month-create (&optional d)
  "Find or create an entry for date D, up to month"
  (unless d (setq d (org-date-to-gregorian (org-read-date))))
  (setq-local org-datetree-base-level 1)
  (save-restriction
    (widen)
    ;; Support the old way of tree placement, using a property
    (let ((prop (org-find-property "DATE_TREE")))
      (when prop
        (goto-char prop)
        (setq-local org-datetree-base-level
                    (org-get-valid-level (org-current-level) 1))
        (org-narrow-to-subtree)))
    (goto-char (point-min))
    (let ((year (calendar-extract-year d))
          (month (calendar-extract-month d)))
      (org-datetree--find-create
       "^\\*+[ \t]+\\([12][0-9]\\{3\\}\\)\\(\\s-*?\
\\([ \t]:[[:alnum:]:_@#%%]+:\\)?\\s-*$\\)"
       year)
      (org-datetree--find-create
       "^\\*+[ \t]+%d-\\([01][0-9]\\) \\w+$"
       year month)
      ;; no day ...
      )))
#+end_src

**** Add ID to some notes
Currently those entered with "a", could of course be generalized.
#+begin_src emacs-lisp
(with-eval-after-load 'org-capture
  (defun aj/org-capture-maybe-add-id ()
    (when (equal "a" (org-capture-get :key t))
      (org-id-get-create)))

  (add-hook 'org-capture-prepare-finalize-hook #'aj/org-capture-maybe-add-id))
#+end_src

**** Insert weektree CUSTOM_ID
#+BEGIN_SRC emacs-lisp
(advice-add 'org-datetree--find-create :after #'aj/insert-datetree-custom-id)

(defun aj/insert-datetree-custom-id (&rest _args)
  "Gives each week in a week-tree a custom id"
  (let ((ch (org-get-heading t t)))
    (when (and (not (org-entry-get (point) "CUSTOM_ID"))
               (string-match-p "^[12][0-9]\\{3\\}-W[0-5][0-9]$" ch))
      (org-entry-put
       (point)
       "CUSTOM_ID" ch
       ;; (replace-regexp-in-string "[^a-zåäöA-ZÅÄÖ0-9]+" "-" ch)
       ))))
#+END_SRC

**** For journal with writing log :ARCHIVE:
Don’t really use this now. Unsure if it works
#+BEGIN_SRC emacs-lisp
(defun aj/org-skrivande-journal-template ()
  (format
   (concat
    "* Skrivet %%u :skrivlogg:\n"
    ":PROPERTIES:\n"
    ":textmängd: %s\n"
    ":PROPERTIES:\n"
    "CLOCK: => %s\n"
    "%%?")
   (read-from-minibuffer "Textmängd (antal w, p, pp, s):")
   (with-current-buffer
       (find-file-noselect
        (expand-file-name "jobbplanering.org" org-directory))
     (aj/org-skrivande-senaste nil))))

(defun aj/org-skrivande-senaste (choose)
  "Returns"
  (interactive "P")
  (let ((period
         (cond
          ((equal choose '(4))
           (intern
            (completing-read "Period"
                             '(today yesterday thisweek lastweek
                                     thismonth lastmonth thisyear lastyear)
                             nil t 'today)))
          ((equal choose '(16)) 'interactive)
          (t 'today))))
    (message (aj/org-get-tagged-clocked-in-file "skrivande" period))))

(defun aj/org-get-tagged-clocked-in-file (tag period)
  "Period can be a symbol recognized by `org-clock-special-range'
or a list with start and end date (in days) as first and last
element"
  (let* ((tste
          (if (symbolp period)
              (let ((pp (butlast (org-clock-special-range period))))
                (mapcar #'time-to-days pp));; TODO, kolla att det blev rätt
            period)))
    (org-duration-from-minutes
     (cadr
      (org-clock-get-table-data
       (buffer-file-name)
       `(:maxlevel 15 :tags ,tag :tstart ,(car tste) :tend ,(cadr tste)))))))

#+END_SRC

Att få dagens klockade tid för specifikt item är inte så svårt:
#+BEGIN_SRC emacs-lisp
(defun aj/org-clock-sum-current-item-today (&optional headline-filter)
  "Return time, clocked on current item today."
  (save-excursion
    (save-restriction
      (let ((range (org-clock-special-range 'today)))
        (org-narrow-to-subtree)
        (org-clock-sum (car range) (cadr range) headline-filter :org-clock-minutes-today)
        org-clock-file-total-minutes))))
#+END_SRC
**** For fieldnotes :ARCHIVE:
Don’t use it now
#+BEGIN_SRC emacs-lisp
(defun aj/org-fieldnote-capture ()
  (let
      ((typ (completing-read "Typ: " '("Observation" "Reflektion" "Forskningsdagbok") nil t nil nil "Observation"))
       (titel (read-from-minibuffer "Titel: " nil nil nil nil "Observation av")))
    (org-set-property "TYP" typ)
    (org-set-property "EXPORT_DATE" (format-time-string "%Y-%m-%d" (org-capture-get :default-time)))
    (save-excursion (move-end-of-line nil) (insert " :" typ ":"))
    titel))

(add-hook 'org-capture-after-finalize-hook #'aj/org-fieldnote-commit-after-capture)
(defun aj/org-fieldnote-commit-after-capture ()
  (when (equal "f" (org-capture-get :key))
    (let* ((file (cadr (org-capture-get :target)))
           (filend (file-name-nondirectory file))
           (dir (file-name-directory file)))
      (when (y-or-n-p "Committa filen?")
        ;;(save-buffer)
        ;;(shell-command (format "git add %s" file))
        (magit-status dir)
        (magit-stage-file filend)
        (aj/org-fieldnote-commit-template dir)
        (call-interactively #'magit-commit-popup)))))


(defun aj/org-fieldnote-commit-template (basedir)
  (save-window-excursion
    (aj/write-string-to-file
     (let ((tmp ""))
       (with-temp-buffer
         (cd basedir)
         (insert (shell-command-to-string "git diff --cached"))
         (goto-char (point-min))
         (while (re-search-forward
                 "^+\\*\\*\\*\\*\\(?: +\\)?\\(?: +\\(?:\\[#.\\]\\)\\)?\\(?: +\\(.*?\\)\\)??\\(?:[   ]+\\(:[[:alnum:]_@#%:]+:\\)\\)?[    ]*$"
                 nil t)
           (setq tmp (concat tmp (match-string-no-properties 1) "\n"))))
       tmp)
     (expand-file-name ".git/info/commit-template.txt" basedir))))
#+end_src


**** Return zotxt-references.
#+BEGIN_SRC emacs-lisp
(defun aj/org-return-org-zotxt-ref ()
  "Fetch an org-zotxt link and return it as a string"
  (let ((zotxt--debug-sync t))
    (with-temp-buffer
      (org-zotxt-insert-reference-link nil)
      (buffer-string))))
#+END_SRC

**** Capture in new frame.
Useful for launching a small capture frame from window manager with a call like:
~emacsclient --eval "(aj/org-capture-new-frame \"$1\" $2)"~
#+begin_src emacs-lisp
(defun aj/org-capture-new-frame (key &optional height)
  (let ((ocframe (make-frame `((width . 100)
                               (height . ,(or height 20))
                               (name . "org-capture")
                               (window-system . x)
                               (fullscreen . nil)))))
    (select-frame-set-input-focus ocframe)
    (aj/center-frame)
    (org-capture nil key)
    (delete-other-windows)
    (add-hook 'org-capture-after-finalize-hook #'delete-frame)))

;; if we don’t run capture with new frame
(add-hook 'org-capture-mode-hook
          (lambda () (remove-hook 'org-capture-after-finalize-hook #'delete-frame)))
#+end_src


** org-protocol-capture-html: Capture web pages from browser
#+begin_src emacs-lisp
(use-package org-protocol-capture-html
  :straight (org-protocol-capture-html :repo "alphapapa/org-protocol-capture-html" :host github :files ("org-protocol-capture-html.el")))
#+end_src
** org-protocol for linking into org files
I keep some notes for papers in org-mode, but sort my papers in Zotero. With this I can easily add a link to the specific note from Zotero, which is launched and resolved through org-protocol.
#+BEGIN_SRC emacs-lisp
(use-package org-protocol
  :straight nil ;; included with org
  :config
  (add-to-list 'org-protocol-protocol-alist
               '(link
                 :protocol "link"
                 :function aj/org-resolve-link))

  (defun aj/org-resolve-link (plist)
    (org-link-open-from-string
     (org-link-make-string (plist-get plist :link))))

  (defun aj/get-org-protocol-link ()
    (format "org-protocol://link?link=id:%s" (org-id-get-create)))

  (defun aj/org-make-unique-link-clipoard ()
    (interactive)
    (gui-set-selection 'CLIPBOARD (aj/get-org-protocol-link)))

  (defalias 'aj/org-id-org-protocol-link-copy 'aj/org-make-unique-link-clipoard))

(with-eval-after-load "zotxt"
  (defun aj/add-zotero-link-to-headline ()
    (interactive)
    (if-let ((link (aj/get-org-protocol-link))
             (id (or
                  (org-zotxt-extract-link-id-at-point)
                  (save-excursion
                    (org-back-to-heading)
                    (when (search-forward "[[" (point-at-eol) t)
                      (org-zotxt-extract-link-id-at-point))))))
        (request
          (format "%s/inserturl" zotxt-url-base)
          :params
          `(("key" . ,id)
            ("url" . ,link)
            ("title" . "org")))
      (user-error "Couldn’t create link")))
  (with-eval-after-load 'org-zotxt
    (bind-key "C-c \" l" #'aj/add-zotero-link-to-headline org-zotxt-mode-map)))
#+END_SRC

** Special commands for org-babel-tangle
#+begin_src emacs-lisp
(defun aj/org-babel-tangle-tagged (tag)
  (interactive (list (completing-read "tag: " (org-get-buffer-tags) nil t)))
  (org-scan-tags
   (lambda () (save-restriction
           (org-narrow-to-subtree)
           (org-babel-tangle)))
   (org-make-tags-matcher tag)
   nil))


(defun aj/org-tangle-computer-config ()
  "Tangle config tagged with current ‘system-name’"
  (interactive)
  (aj/org-babel-tangle-tagged (system-name)))
#+end_src
** Copy region as html or ascii
#+begin_src emacs-lisp
(defun aj/org-export-copy-region-as (&optional backend)
  "Places selected region in kill ring as html or ascii with prefix arg.
Can be passed any ox BACKEND in a non-interactive call"
  (interactive "P")
  (let* ((backend (cond
                   ((and backend (symbolp backend)) backend)
                   (backend 'html)
                   (t 'thinascii)))
         (epl (org-export--get-inbuffer-options backend)))
    (kill-new (org-export-string-as
               (buffer-substring (region-beginning) (region-end))
               backend t epl))))
(bind-key "M-W" #'aj/org-export-copy-region-as org-mode-map)

(defun aj/second-identity (_first second &rest _args)
  second)

(autoload 'org-export-define-derived-backend "ox")
(org-export-define-derived-backend 'thinascii 'ascii
  :translate-alist '((bold . aj/second-identity)
                     (italic . aj/second-identity)
                     (underline . aj/second-identity))
  :options-alist '((:ascii-charset nil nil 'utf-8)
                   (:ascii-text-width nil nil 3000)))
#+end_src

** Org-annotate :org_async:
#+BEGIN_SRC emacs-lisp
(use-package org-annotate
  :straight (:host github :repo "girzel/org-annotate"
                   :fork (:host github :repo "andersjohansson/org-annotate" :branch "org9.3"))
  :bind (:map org-mode-map
              ("C-c C-ä" . org-annotate-add-note)
              ("C-c C-Ä" . org-annotate-delete-note)
              ("C-c C-x C-ä" . org-annotate-display-notes))
  :demand t
  :custom
  (org-annotate-special-brackets '("{" ":" "}"))
  ;; functions defined below
  (org-annotate-latex-export-function #'aj/org-annotate-export-latex-fixme-and-inline)
  (org-annotate-odt-export-function #'aj/org-annotate-export-odt-annotation-or-inline)

  :config
  (set-face-attribute 'org-annotate-bracket-face nil :inherit 'font-lock-variable-name-face :weight 'bold)
  (set-face-attribute 'org-annotate-face nil :height 0.7
                      :weight 'unspecified :underline nil :inherit '(default))


  (defun aj/org-annotate-extract-author (note)
    (if (string-match "{\\([^}]+\\)} *" note)
        (list (match-string 1 note)
              (replace-match "" t t note))
      (list nil note)))

  (defun aj/org-annotate-export-latex-fixme-and-inline (path desc)
    (let ((optstring "")
          opt)
      (when (string-match "^inline:\\(.+\\)" path)
        (setq opt '("inline" "notodonotesbw" "nomargin"))
        (setq path (match-string 1 path)))
      (cl-destructuring-bind
          (author path) (aj/org-annotate-extract-author path)
        (setq path (org-export-data-with-backend path 'latex nil))
        (when author (push (concat "author=" author) opt))
        (when opt (setq optstring (concat "[" (mapconcat #'identity opt ",") "]")))
        (if desc
            (format "\\fxnote*%s{%s}{%s}" optstring path
                    (org-export-data-with-backend desc 'latex nil))
          (format "\\fxnote%s{%s}" optstring path)))))

  (defun aj/org-annotate-export-odt-annotation-or-inline (path desc)
    "Let notes prefixed with \"inline:\" just be set in italics.
    Otherwise export as odt annotation"
    (setq path (org-export-data-with-backend path 'odt nil)
          desc (when desc (org-export-data-with-backend desc 'odt nil)))
    (cl-destructuring-bind
        (author path) (aj/org-annotate-extract-author path)
      (let
          ((author (or author (user-full-name)))
           (date (let ((ct (current-time)))
                   (concat (format-time-string "%FT%T." ct) (number-to-string (nth 2 ct))))))
        (if (string-match "^inline:\\(.+\\)" path)
            (format "<text:span text:style-name=\"Emphasis\">%s</text:span> %s"
                    (match-string 1 path) (or desc "<text:line-break/>"))
          (if desc
              (let ((an-name (concat "__Annot_" (number-to-string (random)))))
                (format "<office:annotation office:name=\"%s\"><dc:creator>%s</dc:creator><dc:date>%s</dc:date><text:list><text:list-item><text:p>%s</text:p></text:list-item></text:list></office:annotation>%s<office:annotation-end office:name=\"%s\"/>"
                        an-name author date path desc an-name))
            (format "<office:annotation><dc:creator>%s</dc:creator><dc:date>%s</dc:date><text:list><text:list-item><text:p>%s</text:p></text:list-item></text:list></office:annotation>"
                    author date path))))))

  ;; some notes are more private and don’t need to go with the export
  (defcustom aj/org-annotate-ignored-prefixes '("noexport")
    "Prefixes for avoiding export of org-annotate-notes.
List of prefix strings or regex."
    :group 'aj
    :type '(choice (repeat string)
                   regexp)
    :safe (lambda (x) (or (stringp x) (cl-every #'stringp x))))

  (defun aj/org-annotate-maybe-ignore (oldfun path desc format)
    (let ((re
           (cl-typecase aj/org-annotate-ignored-prefixes
             (string aj/org-annotate-ignored-prefixes)
             ((and list (not null))
              (format "^%s:" (regexp-opt aj/org-annotate-ignored-prefixes))))))
      (if (and re (string-match-p re path))
          (or desc "")
        (funcall oldfun path desc format))))

  (advice-add 'org-annotate-export-note :around #'aj/org-annotate-maybe-ignore)

  ;; I wan’t my text-mode abbreviations to work when I enter a note,
  (defun aj/org-annotate-add-note-advice (fun &rest args)
    (let ((minibuffer-setup-hook
           (cons 'abbrev-mode minibuffer-setup-hook))
          (global-abbrev-table text-mode-abbrev-table)
          (minibuffer-local-map
           (let ((map (make-sparse-keymap)))
             (set-keymap-parent map minibuffer-local-map)
             (define-key map (kbd "C-ö") #'aj/org-annotate-name)
             map)))
      (apply fun args)))

  (advice-add 'org-annotate-add-note :around #'aj/org-annotate-add-note-advice)

  (org-link-set-parameters "note" :follow #'org-insert-link ; following should just edit!
                           :activate-func #'aj/org-annotate-activate-note ; highlight author as well
                           )

  ;; ascii-export
  (defvar org-annotate-ascii-export-function #'aj/org-annotate-export-ascii)

  (defun aj/org-annotate-export-ascii (path desc)
    (let ((path (org-export-data-with-backend path 'ascii nil)))
      (if desc
          (format "❰%s❱%s" path
                  (org-export-data-with-backend desc 'ascii nil))
        (format "❰%s❱" path))))

  ;; add name
  (defvar aj/org-annotate-name-history nil)
  (with-eval-after-load "savehist" (add-to-list 'savehist-additional-variables 'aj/org-annotate-name-history))

  (defun aj/org-annotate-name (&optional name)
    (interactive
     (let ((enable-recursive-minibuffers t))
       (list (helm :sources '(aj/org-annotate-names-source
                              aj/org-annotate-names-fallback-source)
                   :buffer "*aj helm choose oic-names*"
                   :resume 'noresume
                   :history 'aj/org-annotate-name-history))))
    (save-excursion
      (beginning-of-line)
      (insert (concat "{" name "} "))))

  (defvar aj/org-annotate-names-source
    (helm-build-sync-source "Inline comment names"
      :candidates 'aj/org-annotate-name-history
      :fuzzy-match t
      :action (helm-make-actions "Insert" 'identity "Delete" 'aj/org-annotate-remove-name)
      :persistent-action 'aj/org-annotate-remove-name)
    "Source for inline comment names")

  (defvar aj/org-annotate-names-fallback-source
    '((name . "Insert")
      (dummy)
      (action . (("insert" . identity)))))

  (defun aj/org-annotate-remove-name (_cand)
    (let ((marked (helm-marked-candidates)))
      (dolist (el marked)
        (setq aj/org-annotate-name-history
              (delete el aj/org-annotate-name-history))))
    (helm-force-update))


  ;;; NOTES IN MARGINS!!
  (add-hook 'org-mode-hook #'aj/org-annotate-maybe-add-right-margin)
  (defun aj/org-annotate-maybe-add-right-margin ()
    (org-with-wide-buffer
     (goto-char (point-min))
     (when (search-forward "[[note:" nil t)
       (aj/org-annotate-add-right-margin))))

  (defun aj/org-annotate-add-right-margin (&rest _ignore)
    (when (< (or (cdr (window-margins)) 0) 50)
      (set-window-margins (selected-window) nil 50)))

  (advice-add 'org-annotate-add-note :after #'aj/org-annotate-add-right-margin)

  (defun aj/org-annotate-activate-note (start end _path _bracketp)
    "Add text properties to display annotation links in a special way"
    (save-match-data
      (save-excursion
        (goto-char start)
        (when (looking-at org-link-bracket-re)
          (add-text-properties start (1+ start) ;;first bracket
                               '(invisible nil face org-annotate-bracket-face display "/"))

          (add-text-properties (1- (match-beginning 1)) (match-beginning 1) ;; note bracket start
                               '(invisible t))

          (add-text-properties (match-beginning 1) (match-end 1) ; note
                               `(invisible nil face org-annotate-face
                                           display ((margin right-margin)
                                                    ,(concat "·" (buffer-substring-no-properties
                                                                  (+ 5 (match-beginning 1)) (match-end 1))))))

          (add-text-properties (match-end 1) (1+ (match-end 1)) ;; note bracket end
                               '(invisible t))

          (add-text-properties (1- end) end ; end bracket
                               '(invisible nil face org-annotate-bracket-face display "/"))

          (when (match-end 2) ; make desc visible
            (add-text-properties (1- (match-beginning 2)) (match-beginning 2)
                                 '(invisible nil face org-annotate-bracket-face display "·")) ;; start bracket
            (add-text-properties (match-beginning 2) (match-end 2)
                                 '(invisible nil face org-annotate-text-face))
            (add-text-properties (match-end 2) (1+ (match-end 2))
                                 '(invisible nil face org-annotate-bracket-face display "·")) ;; start bracket
            )))))

  ;; med author
  ;; (defun aj/org-annotate-activate-note (start end _path _bracketp)
  ;;   "Add text properties to display annotation links in a special way"
  ;;   (save-match-data
  ;;     (save-excursion
  ;;       (goto-char start)
  ;;       (when (looking-at org-link-bracket-re)
  ;;         (let ((url-beg (match-beginning 1))
  ;;               (url-end (match-end 1))
  ;;               (desc-beg (match-beginning 2))
  ;;               (desc-end (match-end 2)))
  ;;           (goto-char url-beg)
  ;;           (when (looking-at "\\(note:\\)\\({[^}]+}\\)?")
  ;;             (add-text-properties start (+ 2 start) ; start bracket
  ;;                                  `(invisible nil
  ;;                                              face org-annotate-bracket-face
  ;;                                              display ,(nth 0 org-annotate-special-brackets)))
  ;;             (add-text-properties (- end 2) end ; end bracket
  ;;                                  `(invisible nil
  ;;                                              face org-annotate-bracket-face
  ;;                                              display ,(nth 2 org-annotate-special-brackets)))
  ;;             (add-text-properties (match-beginning 1) (match-end 1) ; hide "note:"
  ;;                                  '(invisible t))
  ;;             (when (match-end 2) ;; fontify author
  ;;               (add-text-properties (match-beginning 2) (1+ (match-beginning 2)) ; hide first {
  ;;                                    '(invisible t))
  ;;               (add-text-properties (1+ (match-beginning 2)) (match-end 2) ; bold author
  ;;                                    '(face bold invisible nil))
  ;;               (add-text-properties (1- (match-end 2)) (match-end 2) ; display } as :
  ;;                                    '(display ":")))

  ;;             (add-text-properties (match-end 0) url-end ; note
  ;;                                  '(invisible nil face org-annotate-face))
  ;;             (when desc-end ; with desc
  ;;               (add-text-properties desc-beg desc-end
  ;;                                    '(invisible nil face org-annotate-text-face))
  ;;               (add-text-properties url-end desc-beg ; middle bracket
  ;;                                    `(invisible nil
  ;;                                                face org-annotate-bracket-face
  ;;                                                display ,(nth 1 org-annotate-special-brackets))))))))))
  )

#+END_SRC


** Zotxt
For using Zotero reference management in plain text.
https://gitlab.com/egh/zotxt
https://gitlab.com/egh/zotxt-emacs
https://gitlab.com/egh/org-pdcite/

But see also:
https://gitlab.com/andersjohansson/zotxt
https://gitlab.com/andersjohansson/zotxt-emacs
https://gitlab.com/andersjohansson/org-pdcite/

And my custom stuff in
https://gitlab.com/andersjohansson/emacs-zotxt-extra

*** Zotxt configuration :org_async:
#+begin_src emacs-lisp
(use-package zotxt
  :straight (zotxt :host gitlab :repo "egh/zotxt-emacs" :depth 'full
                   ;; :local-repo "zotxt"
                   :fork (:host gitlab :repo "andersjohansson/zotxt-emacs" :branch "ajfixes"))
  :custom (zotxt-default-bibliography-style "apa")
  :config
  (defconst zotxt-url-base
	"http://127.0.0.1:23200/zotxt"
	"Base URL to contact.")
  :commands zotxt--json-read)

(use-package org-pdcite
  :straight nil
  :load-path "~/kodat/elisp/org-pdcite"
  :commands 'org-pdcite-full-cite-parser)

(use-package zotxt-extra
  :straight nil
  :load-path "~/kodat/elisp/zotxt-extra"
  :after zotxt
  :demand t
  :commands zotxt-extra-maybe-edit-description
  zotxt-extra-link-parse-desc zotxt-extra--replace-consecutive
  :config (zotxt-extra-complete-citation-help-echo-activate))

(defvar-local zotxt-helm-citation-files nil)
(put 'zotxt-helm-citation-files 'safe-local-variable
	 #'orgqda--string-or-list-of-strings-p)
(use-package zotxt-helm
  :straight nil
  :after zotxt
  :demand t
  :init (setq zotxt-helm-method 'async)
  :commands zotxt-helm-link-to-disp-real
  :config
  ;; this could be added to zotxt-helm, but it’s depending so much on
  ;; orgqda and I don’t want to require or copy that to zotxt-helm
  (require 'orgqda)

  (defun zotxt-helm-get-current-refs ()
	(let* ((orgqda-tag-files zotxt-helm-citation-files)
		   (manyfiles (and zotxt-helm-citation-files
						   (orgqda-tag-files))))
	  (cl-remove-duplicates
	   (if manyfiles
		   (cl-loop for file in manyfiles
					append
					(orgqda--inhibit-org-startups
					 (with-current-buffer (find-file-noselect file)
					   (zotxt-helm-get-current-refs-in-buffer))))
		 (zotxt-helm-get-current-refs-in-buffer))
	   :test 'equal)))

  (defun zotxt-helm-get-current-refs-in-buffer ()
	(org-element-map
		(if zotxt-helm-current-refs-in-widened-buffer
			(save-restriction
			  (widen)
			  (org-element-parse-buffer))
		  (org-element-parse-buffer))
		'link #'zotxt-helm-link-to-disp-real))

  (setf (alist-get 'persistent-action zotxt-helm-current-refs-source)
        #'aj/zotxt-helm-current-show-full-ref)

  ;; Display full ref for "current" refs
  (defun aj/zotxt-helm-current-show-full-ref (cand)
    "Display complete citation of selected ref in helm"
    (interactive)
    (when-let
        ((key (with-temp-buffer (insert cand) (org-zotxt-extract-link-id-at-point))))
      (deferred:$
        (zotxt-get-item-bibliography-deferred (list :key key))
        (deferred:nextc it
          (lambda (item)
            (save-window-excursion
              (select-window (active-minibuffer-window))
              (when-let ((ov (car-safe (overlays-at 1))))
                (overlay-put ov 'display (plist-get item :citation))
                (overlay-put ov 'face 'default))
              ))))))
  )

(use-package org-zotxt
  :straight nil ;; already installed with zotxt-emacs above
  :hook (org-mode . org-zotxt-mode)
  :demand t
  :init (setq org-zotxt-link-description-style :betterbibtexkey)
  :commands org-zotxt-extract-link-id-at-point org-zotxt-choose-path
  :custom (org-zotxt-default-search-method :title-creator-year)
  :config
  ;;prompt to add page references in quotes
  (advice-add 'org-zotxt-insert-reference-link-to-item
			  :after #'zotxt-extra-maybe-edit-description)

  ;; Special fontification, I often manipulate rows of references,
  ;; and then it’s useful to display the outer brackets, for easy
  ;; killing and yanking.
  (org-link-set-parameters "zotero"
						   :face 'org-scheduled-today
						   :activate-func #'aj/org-zotxt-activate)

  (defun aj/org-zotxt-activate (start end _path bracketp)
	"Add text properties to display zotxt citation links in a good way"
	(when bracketp
	  (save-match-data
		(save-excursion
		  (goto-char start)
		  (when (and (looking-at org-link-bracket-re)
					 (match-end 2))
			(let ((bracket '(invisible nil))
				  (inv '(invisible t)))
			  (add-text-properties start (1+ start) bracket)
			  (add-text-properties end (1- end) bracket)
			  (add-text-properties (1+ start) (match-beginning 2) inv)
			  (add-text-properties (1- end) (- end 2) inv))))))))
#+end_src

*** My own view attachment which parses page numbers and jumps to page
Also a function to get all annotations in a pdf file
#+BEGIN_SRC emacs-lisp
(with-eval-after-load "org-zotxt"
  (autoload 'pdf-zotxt-quote-acquire-variables "pdf-zotxt-quote")
  (autoload 'pdf-zotxt-quote-goto-page "pdf-zotxt-quote")

  (defun aj/org-zotxt-open-attachment ()
    "Open attachment of Zotero items linked at point."
    (interactive)
    (let* ((item-id (org-zotxt-extract-link-id-at-point))
           (page (plist-get (zotxt-extra-link-parse-desc
                             (aj/org-zotxt-extract-link-desc-at-point))
                            :locator))
           (pagenum (if page (string-to-number page) 1)))
      (deferred:$
        (aj/get-zotxt-item-path-deferred item-id)
        (deferred:nextc it
          (lambda (path)
            (org-open-file path 1)
            ;; Maybe the pagenumber is logical, hopefully it’s stored
            ;; with pdf-zotxt-quote:
            (if (pdf-zotxt-quote-acquire-variables)
                (pdf-zotxt-quote-goto-page page)
              (pdf-view-goto-page pagenum))))
        (if zotxt--debug-sync (deferred:sync! it)))))


  (bind-key "C-c \" a" #'aj/org-zotxt-open-attachment org-zotxt-mode-map)

  (defun aj/org-zotxt-extract-link-desc-at-point ()
    "Extract the Zotero key of the link at point."
    (let ((ct (org-element-context)))
      (if (eq 'link (org-element-type ct))
          (buffer-substring-no-properties (org-element-property :contents-begin ct)
                                          (org-element-property :contents-end ct))
        nil)))

  (autoload 'pdf-zotxt-quote-get-all-annots-in-buffer-or-file "pdf-zotxt-quote")

  (defun aj/get-zotxt-pdf-annotations ()
    (interactive)
    (let ((item-id (org-zotxt-extract-link-id-at-point)))
      (deferred:$
        (aj/get-zotxt-item-path-deferred item-id)
        (deferred:nextc it
          (lambda (path)
            (pdf-zotxt-quote-get-all-annots-in-buffer-or-file path)))
        (deferred:sync! it))))

  (defun aj/get-zotxt-item-path-deferred (item-id)
    (let ((d (deferred:new)))
      (request
       (format "%s/items" zotxt-url-base)
       :params `(("key" . ,item-id) ("format" . "paths"))
       :parser #'zotxt--json-read
       :success (cl-function
                 (lambda (&key data &allow-other-keys)
                   (deferred:callback-post
                     d (org-zotxt-choose-path
                        (cdr (assq 'paths (elt data 0))))))))
      d))
  )
#+END_SRC

*** Converting back from latex
Some hackish functions
#+BEGIN_SRC emacs-lisp
(use-package biblatex-to-zotxt
  :straight nil
  :load-path "~/kodat/elisp/biblatex-to-zotxt/"
  :commands biblatex-to-zotxt)
#+END_SRC
** Export :org_async:
*** Some more or less general export settings
#+begin_src emacs-lisp
(setq org-export-async-init-file (expand-file-name "init-org-async" user-emacs-directory)
      org-odt-styles-file "~/.emacs.d/orgtemp.ott"
      org-export-with-archived-trees nil
      org-export-allow-bind-keywords t
      org-export-with-section-numbers nil ; most commonly
      org-export-with-statistics-cookies nil ; irrelevant for exported "documents"
      org-export-with-smart-quotes t
      org-export-with-toc nil ; I seldom want toc
      org-export-with-tags nil ; tags are mostly internal for me
      org-export-with-timestamps nil
      org-export-with-todo-keywords nil ; mostly don’t want this

      org-export-time-stamp-file nil
      org-export-with-creator nil
      org-html-doctype "html5"
      org-html-html5-fancy t
      org-html-validation-link ""
      org-export-exclude-tags '("noexport" "outline")
      org-ditaa-eps-jar-path "~/lib/DitaaEps.jar"
      org-ditaa-jar-path "/usr/share/ditaa/ditaa.jar"
      org-export-dispatch-use-expert-ui t)
#+end_src
*** New link types for special exports
**** Video
Mostly for html and reveal
#+BEGIN_SRC emacs-lisp
(org-link-set-parameters "video"
                         :export #'aj/org-video-export
                         :complete #'aj/org-video-complete-link
                         :follow #'aj/org-open-file-with-system)

(defun aj/org-video-export (path desc backend)
  (let ((sources (split-string path "::" t)))
    (cond
     ((org-export-derived-backend-p backend 'html)
      (format "<video title=\"%s\" class=\"stretch\">\n%s\n</video>"
              desc
              (cl-loop for source in sources
                       concat (format "<source src=\"%s\" type=\"%s\">"
                                      (if (or (string-match-p "://" source)
                                              (not (file-name-absolute-p source)))
                                          source
                                        (concat "file://" source))
                                      (mailcap-extension-to-mime
                                       (file-name-extension source))))))
     (t (format "Video: %s" path)))))

(defun aj/org-video-complete-link ()
  (aj/org-complete-link "video:"))
#+END_SRC
*** ox-ascii, don’t fill paragraphs
#+begin_src emacs-lisp
(setq org-ascii-inner-margin 0
      org-ascii-text-width 3000
      org-ascii-charset 'utf-8)

;; Fix title? (doesn’t work)
;; (advice-add 'org-ascii-template--document-title :filter-args #'aj/ox-ascii-fix-title)
;; (defun aj/ox-ascii-fix-title (info)
;;   (plist-put (copy-tree info) :ascii-text-width 80)))
#+end_src

*** org-re-reveal, reveal.js
**** Loading
#+begin_src emacs-lisp
(use-package org-re-reveal
  :straight (org-re-reveal
             :depth nil
             :fork (:host gitlab :repo "andersjohansson/org-re-reveal" :branch "ajfixes"))
  :demand t)
#+end_src
**** Settings
#+BEGIN_SRC emacs-lisp
(defvar aj/path-to-revealjs "~/lib/reveal.js/")

;; loaded with org in init.org
(with-eval-after-load 'org-re-reveal
  (setq
   org-re-reveal-root "../"
   org-re-reveal-script-files '("js/reveal.js")
   org-re-reveal-mathjax-url "https://cdnjs.cloudflare.com/ajax/libs/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
   org-re-reveal-plugins '(classList zoom notes)
   org-re-reveal-theme "white"
   org-re-reveal-transition "slide"
   org-re-reveal-transition-speed "fast"
   org-re-reveal-default-frag-style "appear"
   org-re-reveal-center nil
   org-re-reveal-progress nil
   org-re-reveal-history nil
   org-re-reveal-control nil
   org-re-reveal-rolling-links nil
   org-re-reveal-keyboard t
   org-re-reveal-overview nil
   org-re-reveal-hlevel 2
   org-re-reveal-hashonebasedindex t
   org-re-reveal-extra-options "hash: true, navigationMode: 'linear'"
   ;; org-re-reveal-extra-js "{src: '../assets/aj-fixes.js'}"
   org-re-reveal-external-plugins '((aj-fixes . "{src: '../assets/aj-fixes.js', async: true}"))))
#+END_SRC

**** reveal - org-annotate-style
#+BEGIN_SRC emacs-lisp
(with-eval-after-load "org-re-reveal"
  (defvar org-annotate-reveal-export-function
    #'aj/org-annotate-export-html-tooltip
    "The reveal export style for Org notes, as a symbol.")

  (defun aj/org-annotate-export-html-tooltip (path desc)
    (format "<span style=\"font-size:.5em;font-style:italic;color:#a00\">[%s]</span> %s" path (or desc ""))))
#+END_SRC

**** reveaL: Commands for exporting, starting server, and displaying presentations via server
#+BEGIN_SRC emacs-lisp
(org-export-define-derived-backend
    'reveallink 're-reveal
  :menu-entry
  '(?v 2
       ((?x "As file linked to server"
            aj/org-reveal-export-to-html-link)
        (?c "As linked file and browse"
            aj/org-reveal-export-to-html-link-and-browse))))

(defconst aj/revealjs-base-url "http://localhost:8000/")

(defun aj/org-reveal-export-to-html-link
	(&optional async subtreep visible-only body-only ext-plist)
  "Export current buffer to a reveal.js and link the folder to server dir."
  (interactive)
  (let* ((fn (expand-file-name (org-re-reveal-export-to-html async subtreep visible-only body-only ext-plist)))
		 (fnnd (file-name-nondirectory fn))
		 (dir (file-name-directory fn))
		 (linkeddir (concat aj/path-to-revealjs
							(file-name-nondirectory
							 (directory-file-name dir))))
		 (newfile (concat linkeddir "/" fnnd)))
	(make-symbolic-link dir linkeddir t)
	newfile))

(defvar aj/org-reveal-current-url nil)
(defvar aj/org-reveal-last-url nil)
(with-eval-after-load "savehist" (add-to-list 'savehist-additional-variables 'aj/org-reveal-last-url))
(defvar aj/org-reveal-current-file nil)
(defvar aj/org-reveal-current-slide-id nil)
(defvar-local aj/org-reveal-url-parameters "")
(put 'aj/org-reveal-url-parameters 'safe-local-variable #'stringp)

(defun aj/org-reveal-export-to-html-link-and-browse (&optional async subtreep visible-only body-only ext-plist)
  "Export current buffer to a reveal.js, launch server and browse file"
  (interactive)
  (let (created-id)
    (unwind-protect
        (progn
          (setq ;; aj/org-reveal-current-url nil
           aj/org-reveal-current-slide-id
           (unless (org-before-first-heading-p)
             (or (org-entry-get (point) "custom_id")
                 (org-entry-get (point) "id")
                 (progn (setq created-id t) (org-id-get-create))))
           aj/org-reveal-current-file
           (expand-file-name
            ;;export:
            (aj/org-reveal-export-to-html-link async subtreep visible-only body-only ext-plist))
           ;; form url:
           aj/org-reveal-current-url
           (concat aj/revealjs-base-url (file-name-nondirectory (directory-file-name (file-name-directory aj/org-reveal-current-file)))
                   "/" (file-name-nondirectory aj/org-reveal-current-file)
                   aj/org-reveal-url-parameters
                   (when aj/org-reveal-current-slide-id
                     (concat "#slide-" aj/org-reveal-current-slide-id)))
           aj/org-reveal-last-url aj/org-reveal-current-url)
          ;; browse:
          (aj/org-reveal-try-server-browse-url aj/org-reveal-current-url))
      (setq aj/org-reveal-current-slide-id nil
            ;; aj/org-reveal-current-url nil
            )
      (when created-id (org-entry-delete (point) "id")))))

(defun aj/org-reveal-try-server-browse-url (&optional url server-running)
  (setq aj/org-reveal-current-url ; used in callback function below
        (or url aj/org-reveal-current-url))
  (if server-running
      (request aj/org-reveal-current-url
               :success #'aj/org-reveal-browse-current-url
               :error #'aj/org-reveal-browse-current-file) ; useful?
    (request aj/revealjs-base-url
             :success #'aj/org-reveal-browse-current-url
             :error #'aj/org-reveal-try-server-start)))

(cl-defun aj/org-reveal-browse-current-url (&key _data &allow-other-keys)
  (browse-url
   aj/org-reveal-current-url)
  (setq aj/org-reveal-current-url nil))

(cl-defun aj/org-reveal-browse-current-file (&key _data &allow-other-keys)
  (browse-url-of-file
   aj/org-reveal-current-file))

(cl-defun aj/org-reveal-try-server-start (&key _data &allow-other-keys)
  (let ((proc
         (start-process "revealserver"
                        (generate-new-buffer "revealserver")
                        "aj-startreveal")))
    ;; (sleep-for 3)
    (set-process-filter
     proc
     (lambda (process output)
       (when (string-match-p "Waiting..." output)
         (aj/org-reveal-try-server-browse-url aj/org-reveal-current-url t)
         (set-process-filter process nil))))
    (accept-process-output proc 5)))

(defun aj/org-reveal-start-server ()
  (interactive)
  (setq aj/org-reveal-current-url aj/org-reveal-last-url)
  (aj/org-reveal-try-server-start :data nil))

(setq aj/org-reveal-last-url "http://localhost:8000/2019-05-avhandling-l%C3%A4ngre/avhandlingspresentation.html")
#+END_SRC

**** Mode and hydra for help with input
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'org-re-reveal
  (define-minor-mode aj/org-reveal-mode
    "Minor mode with some custom keybindings for help in creating org-reveal presentations"
    :keymap `((,(kbd "C-c C-ö") . aj/hydra-org-reveal-templates/body)))

  (defvar aj/org-reveal-classes
    '(("stretch" . "stretch")
      ("fillheight" . "fillheight")
      ("large" . "large")
      ("Large" . "Large")
      ("LARGE" . "LARGE")
      ("huge" . "huge")
      ("small" . "small")
      ("footnotesize" . "footnotesize")
      ("tiny" . "tiny")
      ("larger" . "larger")
      ("much-larger" . "much-larger")
      ("very-much-larger" . "very-much-larger")
      ("smaller" . "smaller")
      ("much-smaller" . "much-smaller")
      ("attrib (picture attributions)" . "attrib")
      ("whiteoverlay (overlay over background)" . "whiteoverlay")
      ("pic-row (for pictures in row)" . "pic-row")
      ("shadow (box shadow)" . "shadow")
      ("shapeshadow (shadow for complex shapes)" . "shapeshadow")
      ("columns (wrapper for flexing elements)" . "columns")
      ("vertical-center" . "vertical-center")
      ("center-emphasize" . "center-emphasize")
      ("bottom-note" . "bottom-note")
      ("random-container" . "random-container")
      ("absolute-random (elements inside random-container)" . "absolute-random"))
    "Classes for elements in reveal.js presentations")

  (defhydra aj/hydra-org-reveal-templates (:color blue :columns 4)
    "Reveal templates"
    ("+" (aj/org-insert-element-attributes "#+attr_reveal: :frag (t)") "Piecewise list")
    ("f" (aj/org-insert-element-attributes "#+attr_reveal: :frag t") "Appear (frag)")
    ("n" (aj/org-keyword-expand "n") "Notes")
    ("i" (aj/org-insert-element-attributes (format "#+attr_reveal: :frag t :frag_idx !!" )) "Frag id")
    ("s" (insert "#+reveal: split") "Split frame")
    ("c" (aj/org-insert-element-attributes
          (concat "#+attr_html: :class "
                  (helm :prompt "Class: "
                        :sources
                        (list (helm-build-sync-source "Reveal classes"
                                :candidates aj/org-reveal-classes)
                              (helm-build-dummy-source "Custom class")))))
     "Insert html class for element")
    ("C" (org-set-property "reveal_data_state" "centered-headline") "Centered headline")
    ("F" (insert (completing-read "Frag style" '(grow shrink roll-in fade-out highlight-red highlight-green highlight-blue appear))) "Frag style")
    ("H" (insert "#+reveal_html: ") "HTML")
    ("b" (org-set-property "reveal_background"
                           (file-relative-name
                            (read-file-name "Background image: "
                                            nil nil nil nil)))
     "Background image")
    ("B" (org-set-property "reveal_background_trans"
                           (completing-read "Transition: "
                                            '("none" "fade" "slide" "convex" "concave" "zoom")))
     "Background image-transition")
    ("s" (aj/org-insert-element-attributes "#+attr_html: :style font-size: 0.9em;") "Style element etc.")
    ("p" (insert (format
                  "#+attr_html: :class stretch\n%s"
                  (with-temp-buffer (org-insert-link '(4) nil "") (buffer-string))))
     "Picture with stretch")
    ("z" (insert "#+html: <div id=\"zotxtbibliography\"></div>") "Bibliography")
    ("N" (org-toggle-tag "notitle") "No title headline")
    ("q" nil)))
#+END_SRC

**** Empty headline
#+BEGIN_SRC emacs-lisp
(add-hook 'org-export-filter-parse-tree-functions #'aj/org-reveal-empty-headline-title)

(defun aj/org-reveal-empty-headline-title (data _backend info)
  (org-element-map data 'headline
    (lambda (h)
      (when (member "notitle" (org-element-property :tags h))
        (org-element-put-property h :title nil)
        (org-element-put-property
         h :tags (delete "notitle" (org-element-property :tags h)))))
    info nil)
  data)

(add-hook 'org-export-filter-final-output-functions #'aj/org-reveal-prune-empty-headlines)

(defun aj/org-reveal-prune-empty-headlines (string backend _info)
  (if (eq backend 're-reveal)
      (replace-regexp-in-string "<h2[^>]+></h2>" "" string)
    string))
#+END_SRC

**** Use ~data-src~ instead of ~src~ for images etc.
#+BEGIN_SRC emacs-lisp
(defun aj/org-reveal-lazy-load-links (string backend info)
  (when (and (org-export-derived-backend-p backend 'reveal 're-reveal)
             (not (plist-get info :reveal-single-file))
             (string-match-p "^<\\(img\\|video\\|iframe\\)" string))
    (replace-regexp-in-string "src=" "data-src=" string nil t)))

(add-to-list 'org-export-filter-link-functions #'aj/org-reveal-lazy-load-links)
#+END_SRC

**** Fix blockquotes
Actually, the tree filtering in ~org-re-reveal~ takes care of frag attributes. No need for a custom (weaker) ~org-re-reveal-quote-block~
#+begin_src emacs-lisp
(advice-add 'org-re-reveal-quote-block :override #'org-html-quote-block)
#+end_src
*** Ignored drawers
#+begin_src emacs-lisp
(with-eval-after-load 'ox
  (setq org-export-with-drawers '(not "LOGBOOK" "IGNORE")))
#+end_src

*** Give exported subtrees automatic file names from headline if not present
Advice which will add a generated EXPORT_FILE_NAME if it does not exist.
There are two mechanisms for getting filenames, ~org-export--get-subtree-options~ and ~org-export-output-file-name~. I’m unsure if the former is meaningful, as the latter is used for most calls to ~org-export-to-file~, where the filename is really used, in the exporters.
#+BEGIN_SRC emacs-lisp
;; (advice-add 'org-export--get-subtree-options :filter-return #'aj/org-export-add-subtree-filename)

;; (defun aj/org-export-add-subtree-filename (plist)
;;   "Adds a filename derived from the heading name if no filename
;; is defined the subtree during org subtree export."
;;   (unless (plist-get plist :export-file-name)
;;     (plist-put plist :export-file-name
;;                (aj/org-export-headline-filename
;;                 (car (plist-get plist :title))))))

(advice-add 'org-export-output-file-name
            :around #'aj/org-export-return-subtree-filename)

(defun aj/org-export-return-subtree-filename (fun ext &optional subtreep pub-dir)
  "Adds a filename derived from the heading name if no filename
is defined for the subtree during org subtree export."
  (if (and (not pub-dir) subtreep (not (org-entry-get nil "EXPORT_FILE_NAME")))
      (concat (aj/org-export-headline-filename
               (org-get-heading t t t t))
              ext)
    (funcall fun ext subtreep pub-dir)))


(defvar reftex-derive-label-parameters)
(autoload 'reftex-string-to-label "reftex-ref")
(defun aj/org-export-headline-filename (headline)
  (let ((reftex-derive-label-parameters
         '(5 30 nil 'maybeshorten "-"
             ("the" "on" "in" "off" "a" "for" "by" "of" "and" "is" "to")
             t)))
    (concat "./" (reftex-string-to-label headline))))

#+END_SRC
*** Helper functions
**** For inserting list attributes
#+BEGIN_SRC emacs-lisp
(defun aj/org-insert-element-attributes (attr)
  (save-excursion
    (if-let ((p (org-in-item-p))
             (tp (org-list-get-top-point (org-list-struct))))
        (progn
          (goto-char tp)
          (open-line 1)
          (insert attr))
      (unless (looking-at-p "^$")
        (org-backward-paragraph)
        (open-line 1))
      (insert attr))))
#+END_SRC

**** CHECK For special completion in custom link types
#+BEGIN_SRC emacs-lisp
(defun aj/org-complete-link (rep)
  "Helper function to enable correct handling of relative/absolute
paths also for links of special types."
  (let ((link (org-link-complete-file)))
    (when (string-match "^\\(file:\\)\\(.*\\)" link)
      (let* ((type (match-string 1 link))
             (origpath (match-string 2 link))
             (path (aj/org-filename-possibly-relative origpath)))
        (setq link (concat type path))))
    (replace-regexp-in-string "file:" rep link)))

(defun aj/org-filename-possibly-relative (path)
  "Copy of parts of org-insert-link to determine whether a filename
should be relativized or not. Returns the possibly relativized filename"
  (let ((case-fold-search nil))
    (cond
     ((eq org-link-file-path-type 'absolute)
      (abbreviate-file-name (expand-file-name path)))
     ((eq org-link-file-path-type 'noabbrev)
      (expand-file-name path))
     ((eq org-link-file-path-type 'relative)
      (file-relative-name path))
     (t
      (save-match-data
        (if (string-match (concat "^" (regexp-quote
                                       (expand-file-name
                                        (file-name-as-directory
                                         default-directory))))
                          (expand-file-name path))
            ;; We are linking a file with relative path name.
            (substring (expand-file-name path)
                       (match-end 0))
          (expand-file-name path)))))))
#+END_SRC

*** My inlinecomments , Inlinekommentarer: ❰❙❱ till kommentar :ARCHIVE:
**** Exporting
#+BEGIN_SRC emacs-lisp
(add-hook 'org-export-before-parsing-hook #'aj/ox-inline-comment)

(defun aj/ox-inline-comment (backend)
  (when (member backend '(latex odt))
    (save-excursion
      (goto-char (point-min))
      (while (search-forward-regexp
              "❰\\(?3:\\[[^\]]+\\] \\)?\\(?1:[^❱❙]+\\)\\(?:❙\\(?3:\\[[^\]]+\\] \\)?\\(?2:[^❱]+\\)\\)?❱"
              nil t)
        (replace-match
         (cond
          ((eq 'latex backend)
           (let ((author (if (match-string 3)
                             (format "[author=%s]" (substring (match-string 3) 1 -2))
                           "")))
             (if (match-string 2)
                 (format "@@latex:\\fxnote*%s{%s}{%s}@@"
                         author (match-string 2) (match-string 1))
               (format "@@latex:\\fxnote%s{%s}@@" author (match-string 1)))))
          ((eq 'odt backend)
           (format (if (match-string 2)
                       (let ((an-name (concat "__Annot_" (number-to-string (random)))))
                         (format "@@odt:<office:annotation office:name=\"%s\"><dc:creator>%%s</dc:creator><dc:date>%%s</dc:date><text:list><text:list-item><text:p>%s</text:p></text:list-item></text:list></office:annotation>%s<office:annotation-end office:name=\"%s\"/>@@"
                                 an-name
                                 (match-string 2)
                                 (match-string 1)
                                 an-name))
                     (format "@@odt:<office:annotation><dc:creator>%%s</dc:creator><dc:date>%%s</dc:date><text:list><text:list-item><text:p>%s</text:p></text:list-item></text:list></office:annotation>@@"
                             (match-string 1)))
                   (if (match-string 3) (substring (match-string 3) 1 -2) (user-full-name))
                   (aj/odt-timestamp))))
         nil t)))))
#+END_SRC

**** Inserting :org_async_exclude:
#+BEGIN_SRC emacs-lisp
(bind-key "C-c C-ä" #'aj/org-insert-inline-comment org-mode-map)
(defun aj/org-insert-inline-comment (arg)
  (interactive "P")
  (if (use-region-p)
      (let ((beg (min (point) (mark)))
            (end (max (point) (mark))))
        (goto-char beg)
        (insert "❰")
        (goto-char (1+ end))
        (insert (concat"❙"
                       (when arg (aj/org-inline-comment-name))
                       "❱"))
        (backward-char))
    (insert (concat "❰"
                    (when arg (aj/org-inline-comment-name))
                    "❱"))
    (backward-char)))

(defvar aj/org-inline-comment-name-history nil)

(defun aj/org-inline-comment-name ()
  (concat
   "["
   (helm :sources '(aj/org-inline-comment-names-source
                    aj/org-inline-comment-names-fallback-source)
         :buffer "*aj helm choose oic-names*"
         :resume 'noresume
         :history 'aj/org-inline-comment-name-history)
   ;; (helm-comp-read
   ;;  "Författare: "
   ;;  aj/org-insert-inline-comment-name-history
   ;;  :input-history 'aj/org-insert-inline-comment-name-history
   ;;  :name "Comment name" :buffer "*oic-helm*")
   "] "))


(defvar aj/org-inline-comment-names-source
  (helm-build-sync-source "Inline comment names"
    :candidates 'aj/org-inline-comment-name-history
    :fuzzy-match t
    :action (helm-make-actions "Insert" 'identity "Delete" 'aj/org-inline-comment-remove-name)
    :persistent-action 'aj/org-inline-comment-remove-name
    :multiline t)
  "Source for inline comment names")

(defvar aj/org-inline-comment-names-fallback-source
  '((name . "Insert")
    (dummy)
    (action . (("insert" . identity)))))

(defun aj/org-inline-comment-remove-name (_cand)
  (let ((marked (helm-marked-candidates)))
    (dolist (el marked)
      (setq aj/org-inline-comment-name-history
            (delete el aj/org-inline-comment-name-history))))
  (helm-force-update))

(font-lock-add-keywords 'org-mode '(("❰\\(\\[[^\]]+\\] \\)?\\([^❱❙]+\\)❱"
                                     (1 'bold prepend t)
                                     (2 'helm-buffer-process prepend))
                                    ("❰\\([^❱❙]+\\)❙\\(\\[[^\]]+\\] \\)?\\([^❱]+\\)❱"
                                     (1 'org-target prepend)
                                     (2 'bold prepend t)
                                     (3 'helm-buffer-process prepend))))
#+END_SRC
*** ODT-export
**** ODT has no problem including a pdf file, let it do that
#+BEGIN_SRC emacs-lisp
(setq org-odt-inline-image-rules '(("file" . "\\.\\(jpeg\\|jpg\\|png\\|gif\\|svg\\|pdf\\)\\'")))
#+END_SRC
*** LaTeX-export
**** Risky variable fix for ~org-latex-title-command~
~org-latex-title-command~ is treated as a risky variable since it ends in "-command" (see [[info:elisp#File%20Local%20Variables][info:elisp#File Local Variables]]). This means annoying dialogs in files where it is set (and that appearently can’t be fixed by adding values to ~safe-local-variable-values~ either). This fixes it.
 #+BEGIN_SRC emacs-lisp
(put 'org-latex-title-command 'safe-local-variable #'stringp)
#+END_SRC

**** Latex drawers
#+BEGIN_SRC emacs-lisp
(with-eval-after-load "ox-latex"
  (defun aj/ox-latex-drawers (name contents)
    (pcase (downcase name)
      ("temp" (concat "{\\footnotesize\\color{black!60}" contents "}"))
      (_ contents)))

  (setq org-latex-format-drawer-function #'aj/ox-latex-drawers))
#+END_SRC
**** latex inlinetask
#+begin_src emacs-lisp
(defun aj/org-latex-inlinetask (todo todotype prio name tags cont info)
  "Export inlinetasks with tags and some other stuff"
  todo todotype prio name tags cont info
  (if (string= "∈" name)
      (aj/org-coding-inlinetask tags)
    (let*
        ((name (unless (or (string= "" name) (string= "∈" name)) name))
         (cont (unless (string= "" cont) cont))
         (taglist (when tags (replace-regexp-in-string
                              "_" "\\textunderscore{}"
                              (format "\\ajtags{%s}" (mapconcat 'identity tags ", "))
                              t t))))
      (concat
       taglist
       (when (or name cont)
         (apply
          #'format "\\begin{anfxnote}{%s}%s\\end{anfxnote}"
          (cond
           ((and name cont)
            (list name cont))
           ((and name (not cont))
            (list "Note" name))
           ((and (not name) cont)
            (list "Note" cont)))))))))

(defun aj/org-coding-inlinetask (tags)
  (format "\\codingtags{%s}"
          (mapconcat (lambda (tag)
                       (let ((case-fold-search nil))
                         (replace-regexp-in-string
                          "_" "\\(\\ni\\)"
                          (downcase
                           (replace-regexp-in-string "\\([a-z]\\)\\([A-Z]\\)" "\\1 \\2" tag t))
                          t t)))
                     tags "; ")))


(setq org-latex-format-inlinetask-function 'aj/org-latex-inlinetask)

(put 'org-latex-format-inlinetask-function 'safe-local-variable
     '(lambda (arg)
        (and (symbolp arg)
             (memq arg '(aj/org-latex-transcript-inlinetask aj/fa-org-latex-inlinetask)))))
#+end_src
**** Use latex headers (adapted from ox-extra)
#+begin_src emacs-lisp
(with-eval-after-load "ox"
  (add-hook 'org-export-before-parsing-hook #'aj/org-latex-header-blocks-filter)

  ;; adapted to a working version from the original in ox-extra
  (defun aj/org-latex-header-blocks-filter (backend)
    (when (org-export-derived-backend-p backend 'latex)
      (let ((positions
	         (org-element-map (org-element-parse-buffer 'greater-element nil)
                 'export-block
	           (lambda (block)
	             (when (and (string= (org-element-property :type block) "LATEX")
			                (string= (org-export-read-attribute
				                      :header block :header)
				                     "yes"))
		           (list (org-element-property :begin block)
		                 (org-element-property :end block)
                         (split-string
				          (nth 2 (org-src--contents-area block))
				          "\n")))))))
        (mapc (lambda (pos)
	            (goto-char (nth 0 pos))
	            (delete-region (nth 0 pos) (nth 1 pos))
		        (dolist (line (nth 2 pos))
		          (insert (concat "#+latex_header: "
				                  (replace-regexp-in-string "\\` *" "" line)
				                  "\n"))))
	          ;; go in reverse, to avoid wrecking the numeric positions
	          ;; earlier in the file
	          (reverse positions))))))




#+end_src
**** Quotes in latex export
***** Use csquotes for smart-quotes
#+begin_src emacs-lisp
(defcustom aj/org-export-smart-quotes-use-csquotes t
  "If non-nil, uses csquotes when exporting smart quotes to latex"
  :type 'boolean
  :group 'org-export
  :safe #'booleanp)

(with-eval-after-load "ox"
  (defvar aj/org-export-smart-quotes-alist-orig org-export-smart-quotes-alist)
  (defvar aj/org-export-smart-quotes-alist-csquotes (copy-tree org-export-smart-quotes-alist))

  ;; add-csquotes-commands in csquotes-list
  (mapc (lambda (el)
          ;;depends on the assumption of correct order of
          ;;primary-opening, primary-closing, secondary-opening, secondary-closing
          (setf (cl-getf (cdr (nth 1 el)) :latex)
                "\\textquote{"
                (cl-getf (cdr (nth 2 el)) :latex)
                "}"
                (cl-getf (cdr (nth 3 el)) :latex)
                "\\textquote*{"
                (cl-getf (cdr (nth 4 el)) :latex)
                "}"))
        aj/org-export-smart-quotes-alist-csquotes)

  (add-to-list 'aj/org-export-smart-quotes-alist-csquotes
               '("en-gb" ;;with american quotes really...
                 (primary-opening :utf-8 "‘" :html "&lsquo;" :latex "\\textquote{" :texinfo "`")
                 (primary-closing :utf-8 "’" :html "&rsquo;" :latex "}" :texinfo "'")
                 (secondary-opening :utf-8 "“" :html "&ldquo;" :latex "\\textquote*{" :texinfo "``")
                 (secondary-closing :utf-8 "”" :html "&rdquo;" :latex "}" :texinfo "''")
                 (apostrophe :utf-8 "’" :html "&rsquo;")))
  (add-to-list 'aj/org-export-smart-quotes-alist-csquotes
               (cons "en-us" (cdr (assoc "en" aj/org-export-smart-quotes-alist-csquotes))))


  (defun aj/org-export-smart-quotes-install-hook (_backend)
    (if aj/org-export-smart-quotes-use-csquotes
        (setq org-export-smart-quotes-alist
              aj/org-export-smart-quotes-alist-csquotes)
      (setq org-export-smart-quotes-alist
            aj/org-export-smart-quotes-alist-orig)))

  (add-hook 'org-export-before-processing-hook
            #'aj/org-export-smart-quotes-install-hook))
#+END_SRC
***** CSquote-support through interpreting attributes environment and options for quote blocks
#+begin_src emacs-lisp
(with-eval-after-load 'ox-latex
  (defun org-latex-quote-block (quote-block contents info)
    "Transcode a QUOTE-BLOCK element from Org to LaTeX.
CONTENTS holds the contents of the block.  INFO is a plist
holding contextual information."
    (let* ((attr (org-export-read-attribute :attr_latex quote-block))
           ;; Determine environment for the quote: blockcquote etc.
           (env (or (plist-get attr :environment)
                    "quote"))
           (options (or (plist-get attr :options) "")))
      (org-latex--wrap-label
       quote-block
       (format "\\begin{%s}%s\n%s\\end{%s}" env options contents env) info))))
#+end_src

***** enquote-to-quotation marks (for latex imported to org),
When I need to do the reverse of the above
#+begin_src emacs-lisp
(defun aj/org-enquote-to-quote (beg end)
  (interactive "r")
  (if (and (number-or-marker-p beg) (number-or-marker-p end))
      (save-excursion
        (goto-char beg)
        (while (re-search-forward "\\\\enquote{\\([^}]+\\)}" end t)
          (replace-match "\"\\1\"" nil nil)))
    (message "Mark a region to transform")))
#+end_src

***** Translate ~´~ to ~'~
The detection of in-word apostrophes etc. often fails. Always using ~´~ to mean apostrophe is a workaround. I still have this in some old files but nowadays I mostly just insert the correct unicode symbol (RIGHT SINGLE QUOTATION MARK: ~’~) which I have conveniently bound on my keyboard.

#+begin_src emacs-lisp
(defun aj/fa-latex-quote (string backend info)
  (cond
   ((member backend '(latex beamer))
	(replace-regexp-in-string
     "´"
     (cond
      ((member backend '(latex beamer)) "'")
      ((eq backend 'html) "&rsquo;")
      ((eq backend 'ascii) (if (eq (plist-get info :ascii-charset) 'utf-8)
                               "’" "'"))
      (t "’"))
     string))))

(with-eval-after-load "ox"
  (add-to-list 'org-export-filter-final-output-functions
               #'aj/fa-latex-quote))
#+end_src



**** LaTeX classes and support for special documents
***** Configuration for thesis writing
Here it is, finished ☺: http://urn.kb.se/resolve?urn=urn:nbn:se:uu:diva-357341
****** UUthesis, for my thesis
#+BEGIN_SRC emacs-lisp
(with-eval-after-load "ox-latex"
  (add-to-list 'org-latex-classes
               '("uuthesis"
                 "\\documentclass[final]{UUThesisTemplate}"
                 ("\\chapter{%s}" . "\\chapter*{%s}")
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}"))))
#+END_SRC

****** Glossaries for thesis
#+BEGIN_SRC emacs-lisp
(org-link-set-parameters "gls"
                         :follow #'ignore
                         :export #'aj/org-gls-export
                         :complete #'aj/org-gls-complete
                         :face 'bold)

(defun aj/org-gls-export (ref _desc backend)
  (if (org-export-derived-backend-p backend 'latex)
      (let* ((sp (split-string ref ":" t))
             (mod (cadr sp))
             (cmd (cond
                   ((equal mod "inheading") "ajglsinheading")
                   ((equal mod "nolink") "glsentrytext")
                   ((stringp mod) mod)
                   (t "gls"))))
        (if (aj/org-gls-find (car sp))  ;; found in unwidened
            (format "\\%s{%s}" cmd (car sp))
          (format "\\emph{%s}" (car sp))))
    ref))

(defun aj/org-gls-complete (&optional _arg)
  (concat "gls:" (helm-comp-read "Glossary terms " (aj/org-gls-find nil t))))

;;just assume we should use glossaryterms.tex if it exists in default dir.
(defun aj/org-gls-find (&optional ref wide)
  (with-current-buffer (or (and (file-readable-p "glossaryterms.tex")
                                (find-file-noselect "glossaryterms.tex" t))
                           (current-buffer))
    (save-restriction
      (when wide (widen))
      (save-excursion
        (save-match-data
          (goto-char (point-min))
          (if ref
              (search-forward-regexp
               (format "\\(newabbreviation\\|longnewglossaryentry\\|newglossaryentry\\|newacronym\\)\\(?:\[^]]+\]\\)?{%s}" ref) nil t)
            (cl-loop
             while (search-forward-regexp
                    "\\(newabbreviation\\|longnewglossaryentry\\|newglossaryentry\\|newacronym\\)\\(?:\[^]]+\]\\)?{\\([^}]+\\)}"
                    nil t)
             collect (match-string 2))))))))


#+END_SRC
****** Paper ref for thesis (references to the papers included in the thesis)
#+BEGIN_SRC emacs-lisp
(org-link-set-parameters "paper"
                         :follow #'aj/org-paperref-show
                         :export #'aj/org-paperref-export
                         :complete #'aj/org-paperref-complete
                         :face 'org-scheduled)

(defun aj/org-paperref-export (refs _desc backend)
  (if (org-export-derived-backend-p backend 'latex)
      (let ((psp (split-string refs "," t "[[:space:]]+")))
        (format
         (if (cl-set-difference psp (aj/org-paperref-find)
                                :test 'string=)
             ;; some label was not found
             "\\textbf{%s}"
           "\\paperref{%s}")
         refs))
    refs))

(defun aj/org-paperref-complete (&optional _arg)
  (concat "paper:"
          (mapconcat #'identity (helm-comp-read
                                 "Paperrefs: "
                                 (aj/org-paperref-find nil t)
                                 :marked-candidates t)
                     ", ")))

(defun aj/org-paperref-show (refs)
  (message
   (cl-loop for p in (cl-loop for ref in (split-string refs "," t)
                              collect (aj/org-paperref-find ref t))
            concat
            (concat (if p
                        (save-excursion
                          (goto-char p)
                          (buffer-substring-no-properties
                           (point-at-bol) (point-at-eol)))
                      "Not found!") "\n"))))

(defun aj/org-paperref-find (&optional ref wide)
  (save-restriction
    (when wide (widen))
    (save-excursion
      (save-match-data
        (goto-char (point-min))
        (when (search-forward "\\begin{listofpapers}" nil t)
          (let ((limit (save-excursion (search-forward "\\end{listofpapers}" nil t))))
            (if ref
                (search-forward (format "\\label{%s}" ref) limit t)
              (cl-loop
               while (search-forward-regexp "\\\\label{\\([^}]+\\)}" limit t)
               collect (match-string 1)))))))))

#+END_SRC

****** Latin abbreviations for thesis
#+BEGIN_SRC emacs-lisp
(dolist (x '(("eg" "\\eg" nil "e.g." "e.g." "e.g." "e.g.")
             ("etal" "\\etal" nil "et al." "et al." "et al." "et al.")
             ("etc" "\\etc" nil "etc." "etc." "etc." "etc.")
             ("ie" "\\ie" nil "i.e." "i.e." "i.e." "i.e.")
             ("cf" "\\cf" nil "cf." "cf." "cf." "cf.")))
  (add-to-list 'org-entities-user x))
#+END_SRC
****** Lists in thesis
#+BEGIN_SRC emacs-lisp
(defun aj/org-latex-thesis-lists-data (data backend info)
  "Use thesis environments for plain lists.
Add as a filter in ‘org-export-filter-parse-tree-functions’."
  (when (eq backend 'latex)
    (org-element-map data '(plain-list)
      #'aj/org-latex-thesis-list-set-environment
      info))
  data)

(defun aj/org-latex-thesis-list-set-environment (plain-list)
  (unless (plist-get (org-export-read-attribute :attr_latex plain-list)
                     :environment)
    (org-element-put-property
     plain-list :attr_latex
     (cons (format ":environment %s"
                   (cl-case (org-element-property :type plain-list)
                     ('ordered "numberedlist-aj")
			         ('descriptive "description")
			         (t "bulletlist-aj")))
           (org-element-property :attr_latex plain-list)))))

;; (defun aj/org-latex-thesis-lists (translist backend info)
;;   "Use thesis environments for plain lists.
;; Add as a filter in `org-export-filter-plain-list-functions'"
;;   (if (and (org-export-derived-backend-p backend 'latex)
;;            (string= (plist-get info :latex-class) "uuthesis"))
;;       (replace-regexp-in-string
;;        "{itemize}" "{bulletlist}"
;;        (replace-regexp-in-string "{enumerate}" "{numberedlist}" translist t t))
;;     translist))

#+END_SRC
****** Convert ref to cref (from cleverref)
#+BEGIN_SRC emacs-lisp
(defun aj/org-latex-ref-to-autoref (string backend _info)
  (if (and
       (org-export-derived-backend-p backend 'latex)
       (string-match-p "avhandling" default-directory))
      (zotxt-extra--replace-consecutive
       (replace-regexp-in-string "\\\\ref{" "\\cref{" string t t)
       "\\\\cref{\\([^}]+\\)}"
       "[[:space:],]*\\(?:and\\)*[[:space:],]*"
       "\\cref{%s}" ",")
    string))

(add-to-list 'org-export-filter-final-output-functions
             #'aj/org-latex-ref-to-autoref)
#+END_SRC

****** Replace references
Very specific code for replacing certain references that get exported in a format that biblatex can’t handle correctly from zotero with manually crafted bib-entries (often using workarounds).

#+BEGIN_SRC emacs-lisp
(autoload 'bibtex-parse-keys "bibtex")

(defun aj/replace-fixed-references (string backend _info)
  (when (and
         (org-export-derived-backend-p backend 'latex)
         (string-match-p "avhandling" default-directory))
    (when-let ((bbuf (find-file-noselect "fixreferenser.bib")))
      (with-current-buffer bbuf
        (xah-replace-pairs-in-string
         string
         (cl-loop for x in (bibtex-parse-keys)
                  collect (list (substring (car x) 0 -4) (car x))))))))

(add-to-list 'org-export-filter-final-output-functions #'aj/replace-fixed-references)
#+END_SRC

****** Thesischapter, for old thesis :ARCHIVE:
#+BEGIN_SRC emacs-lisp
(with-eval-after-load "ox-latex"
  (add-to-list 'org-latex-classes
               '("thesischapter"
                 "\\documentclass[11pt]{report}"
                 ("\\chapter{%s}" . "\\chapter*{%s}")
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}"))))
#+END_SRC
***** Class for ajshort (my own common latex configuration for short texts wrapped up into a package)
#+begin_src emacs-lisp
(with-eval-after-load "ox-latex"
  (setq org-latex-subtitle-separate t
        org-latex-subtitle-format "\\newcommand{\\thesubject}{%s}"
        org-latex-default-class "ajshort")
  ;; (add-to-list 'org-latex-packages-alist '("" "ajcomments"))


  (defun aj/latex-add-style-options (fn header info)
    "Advised to replace \\usepackage{ajshort/ajbeamer} with custom definition if options are needed"
    (when (and (member (plist-get info :latex-class) '("ajshort" "ajbeamer"))
               (string-match "\\\\usepackage{aj\\(short\\|beamer\\)}" header)
               (string-match "\\\\usepackage\\[.+\\]{aj\\(short\\|beamer\\)}" header))
      (let ((wo (match-string 0 header)))
        (setq header (replace-regexp-in-string
                      "\\\\usepackage{aj\\(short\\|beamer\\)}" wo
                      (replace-regexp-in-string
                       "\\\\usepackage\\[.+\\]{aj\\(short\\|beamer\\)}" "" header nil t)
                      nil t))))
    (funcall fn header info))

  (advice-add 'org-latex-guess-babel-language :around #'aj/latex-add-style-options)

  ;;(advice-remove 'org-latex-guess-babel-language #'aj/latex-add-style-options)

  (add-to-list 'org-latex-classes
               '("ajshort"
                 "\\documentclass[a4paper,12pt]{article}
 \\usepackage[AUTO]{inputenc}
 \\usepackage[T1]{fontenc}
 \\usepackage[british,swedish,AUTO]{babel}
 \\usepackage{etoolbox}
 \\usepackage{longtable}
 \\usepackage{float}
 \\usepackage{wrapfig}
 \\usepackage[normalem]{ulem}
 \\usepackage{amsmath}
 \\usepackage{textcomp}
 \\usepackage{marvosym}
 \\usepackage{wasysym}
 \\usepackage{amssymb}
 \\usepackage{authoraftertitle} %före title!
 [PACKAGES]
 [EXTRA]
 [NO-DEFAULT-PACKAGES]
 \\usepackage{ajshort}"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))))
#+end_src

***** iopart class (for Institute of Physics papers)
I wrote this paper with it:
http://iopscience.iop.org/article/10.1088/1361-6404/aa9b42
#+BEGIN_SRC emacs-lisp
(with-eval-after-load "ox-latex"
  (add-to-list
   'org-latex-classes
   '("iopart" "\\documentclass{iopart}
\\usepackage[AUTO]{inputenc}
\\usepackage[T1]{fontenc}
\\usepackage[AUTO]{babel}
\\usepackage{times}
\\usepackage{hyperref}
[NO-DEFAULT-PACKAGES]
[PACKAGES]
[EXTRA]"
 ("\\section{%s}" . "\\section*{%s}")
 ("\\subsection{%s}" . "\\subsection*{%s}")
 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
 ("\\paragraph{%s}" . "\\paragraph*{%s}")
 ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))


(defun aj/org-export-latex-remove-iopart-title (string backend info)
  (and (eq backend 'latex)
       (string= "iopart" (plist-get info :latex-class))
       (with-temp-buffer
         (insert string)
         (search-backward "\\begin{document}" nil t)
         (when (search-backward-regexp "\\\\title{.+}$" nil t)
           (replace-match ""))
         (buffer-string))))

(add-to-list 'org-export-filter-final-output-functions #'aj/org-export-latex-remove-iopart-title))
#+END_SRC
***** Revtex-class, adapted from [[https://github.com/jkitchin/jmax/blob/master/ox-manuscript.el][ox-manuscript]]
Used it to write this paper: http://dx.doi.org/10.1119/perc.2016.pr.040
#+BEGIN_SRC emacs-lisp
(with-eval-after-load "ox-latex"
  (add-to-list 'org-latex-classes
               '("revtex4-1-aj"
                 "\\documentclass{revtex4-1}
\\usepackage[AUTO]{inputenc}
\\usepackage[T1]{fontenc}
[NO-DEFAULT-PACKAGES]
[PACKAGES]
[EXTRA]"
 ("\\section{%s}" . "\\section*{%s}")
 ("\\subsection{%s}" . "\\subsection*{%s}")
 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
 ("\\paragraph{%s}" . "\\paragraph*{%s}")
 ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))))
#+END_SRC
***** CV, moderncv class
****** cv
#+begin_src emacs-lisp
(with-eval-after-load "ox-latex"
  (add-to-list 'org-latex-classes
               '("ajcv"
                 "\\documentclass[11pt,a4paper]{moderncv}
 \\usepackage[AUTO]{inputenc}
 \\usepackage[T1]{fontenc}
 \\usepackage[AUTO]{babel}
 [PACKAGES]
 [EXTRA]
 [NO-DEFAULT-PACKAGES]
\\usepackage{ajcv}"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")))


  (advice-add 'org-latex-plain-list :around #'aj/org-latex-plain-list-cv)

  (defun aj/org-latex-plain-list-cv (fun plain-list contents info)
    "Hacks lists to cv-entries"
    (let ((type (org-element-property :type plain-list)))
      (cond
       ((and (string= "ajcv" (plist-get info :latex-class))
             (or (eq type 'descriptive)
                 (eq type 'unordered)))
        contents)
       (t (funcall fun plain-list contents info)))))


  (advice-add 'org-latex-item :around #'aj/org-latex-item-cv)

  (defun aj/org-latex-item-cv (fun item contents info)
    (let ((type (org-element-property
                 :type (org-export-get-parent item)))
          (ajcv (string= "ajcv" (plist-get info :latex-class))))
      (cond
       ((and ajcv (eq type 'descriptive))
        (let* ((fields (split-string contents ";" nil  "[: \n]+"))
               (n (length fields))
               (tag (let ((tag (org-element-property :tag item)))
		              (if tag (org-export-data tag info) ""))))
          (cond
           ((eq 1 n) (format "\\cvitem{%s}{%s}" tag (car fields)))
           ((eq 2 n) (format
                      "\\cvitemwithcomment{%s}{%s}{%s}"
                      tag (car fields) (cadr fields)))
           (t (apply #'format
                     "\\cventry{%s}{%s}{%s}{%s}{%s}{%s}"
                     tag
                     (append fields (make-list 5 ""))))))
        )
       ((and ajcv (eq type 'unordered))
        (format "\\cvlistitem{%s}" (org-trim contents)))
       (t (funcall fun item contents info))))))
#+end_src
****** cv letter
#+begin_src emacs-lisp
(with-eval-after-load "ox-latex"
  (add-to-list 'org-latex-classes
               '("ajcv-letter"
                 "\\documentclass[12pt,a4paper]{moderncv}
 \\usepackage[AUTO]{inputenc}
 \\usepackage[T1]{fontenc}
 \\usepackage[AUTO]{babel}
 [PACKAGES]
 [EXTRA]
 [NO-DEFAULT-PACKAGES]
\\usepackage{ajcv-letter}"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}"))))


#+end_src
**** Use latexmk
#+begin_src emacs-lisp
(setq org-latex-pdf-process '("latexmk -g -recorder -pdf %b"))
#+end_src

**** Exporting through AUCTeX
It has better error messages and better async running of file. I have also used this for putting together files through latex includes and the concept of AUCTeX master files (then you can easily just process a sub-file, or a region, like with org subtree-export).
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'ox-latex
  (org-export-define-derived-backend 'auctex 'latex
    :menu-entry
    '(?a "AUCTeX export"
         ((?a "As PDF (AUCTeX)"
              aj/org-export-tex-auctex)
          (?A "As PDF (AUCTeX) and view"
              aj/org-export-tex-auctex-and-view)
          ;; (?f "As PDF (AUCTeX this file)"
          ;;     aj/org-export-tex-auctex-subfile)
          (?v "View pdf (evince)"
              aj/org-export-tex-auctex-view-evince)
          (?V "View pdf (pdf-tools)"
              aj/org-export-tex-auctex-view-pdf-tools)
          (?l "Show tex process"
              aj/TeX-recenter-output-buffer)))))

(autoload 'TeX-command-sequence "tex-buf")
(autoload 'TeX-recenter-output-buffer "tex-buf")
(autoload 'TeX-strip-extension "tex")

(defun aj/org-export-tex-auctex (_async subtreep visible-only _body-only)
  "Export to pdf with auctex. Ignores async since running tex is
usually what takes time and that is called async through
auctex (and there are so many hacks needed to get my other
hacks working for async)"
  (interactive)
  (org-export-to-file 'latex (org-export-output-file-name ".tex" subtreep)
    nil subtreep visible-only nil nil
    #'aj/org-export-tex-auctex-run-tex))

(defun aj/org-export-tex-auctex-and-view (_async subtreep visible-only _body-only)
  "Export to pdf with auctex and view. Ignores async since running tex is
usually what takes time and that is called async through
auctex (and there are so many hacks needed to get my other
hacks working for async)"
  (interactive)
  (org-export-to-file 'latex (org-export-output-file-name ".tex" subtreep)
    nil subtreep visible-only nil nil
    #'aj/org-export-tex-auctex-run-tex-view))

(autoload #'TeX-command "tex-buf")
(defvar aj/org-export-tex-auctex-curr-file nil)
(defvar TeX-master)

(defun aj/org-export-tex-auctex-run-tex (file)
  (setq aj/org-export-tex-auctex-curr-file file) ; stupid
  (setq TeX-master file)
  (TeX-command-sequence '("latexmk")
                        t #'aj/org-export-tex-auctex-curr-file) file)

(defun aj/org-export-tex-auctex-run-tex-view (file)
  (setq aj/org-export-tex-auctex-curr-file file) ; stupid
  (setq TeX-master file)
  (TeX-command-sequence '("latexmk" "View")
                        t #'aj/org-export-tex-auctex-curr-file) file)

(defvar TeX-view-program-selection) ; avoid byte-compiler warning

(defun aj/org-export-tex-auctex-view-evince (_async subtreep _visible-only _body-only)
  (let ((TeX-view-program-selection '((output-pdf "Evince"))))
    (aj/org-export-tex-auctex-only-view (org-export-output-file-name "" subtreep))))

(defun aj/org-export-tex-auctex-view-pdf-tools (_async subtreep _visible-only _body-only)
  (let ((TeX-view-program-selection '((output-pdf "PDF Tools"))))
    (aj/org-export-tex-auctex-only-view (org-export-output-file-name "" subtreep))))

(defun aj/org-export-tex-auctex-only-view (file)
  (setq aj/org-export-tex-auctex-curr-file file) ; stupid
  (setq TeX-master file)
  (TeX-command-sequence '("View")
                        t #'aj/org-export-tex-auctex-curr-file) file)

(defun aj/org-export-tex-auctex-curr-file (&rest _ignore)
  (TeX-strip-extension aj/org-export-tex-auctex-curr-file nil t))

(defun aj/TeX-recenter-output-buffer (&rest _ignore)
  (interactive)
  (TeX-recenter-output-buffer nil))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Older stuff, not sure if this works:

;; (defun aj/org-export-tex-auctex-subfile (async subtreep visible-only _body-only)
;;   (interactive)
;;   (let ((outfile (org-export-output-file-name ".tex" subtreep))
;;         ;;use with cl-letf
;;         ;; ((symbol-function 'aj/TeX-run-latexmk) #'aj/org-TeX-run-latexmk)
;;         )
;;     (org-export-to-file 'latex outfile
;;       async subtreep visible-only t nil
;;       #'aj/org-export-tex-auctex-run-tex-region)))

;; (autoload #'TeX-master-file "tex")
;; (autoload #'TeX-region-create "tex-buf")
;; (autoload #'TeX-region-file "tex-buf")
;; (defun aj/org-export-tex-auctex-run-tex-region (file)
;;   ;; (require 'tex)
;;   ;; (require 'latex)
;;   ;;TeX-master should be available as local variable in this temp org
;;   ;;buffer (but not neccessarily if we missed to export the local
;;   ;;variables section for some reason (subtree, narrowing, etc))

;;   ;; bind + local seems to work with org-export--generate-copy-script
;;   ;; as it adds the bound ones as local
;;   (hack-local-variables)
;;   (let ((texm (TeX-master-file)))
;;     (with-current-buffer (find-file-noselect file t)
;;       (latex-mode)
;;       (let ((TeX-master texm))
;;         (TeX-region-create (TeX-region-file TeX-default-extension)
;;                            (buffer-string)
;;                            (file-name-nondirectory (buffer-file-name))
;;                            (TeX-current-offset begin)))
;;       (TeX-command "latexmk" #'TeX-region-file -1)))
;;   file)

#+END_SRC


**** Beamer
***** Configuration and class loading my beamer customizations
#+begin_src emacs-lisp
(with-eval-after-load "ox-beamer"
  (add-to-list 'org-beamer-environments-extra '("pnote" "m" "\\pnote{%h" "}"))
  (add-to-list 'org-beamer-environments-extra
               '("plainframe" "-" "\\begin{frame}%a%A[plain]" "\\end{frame}"))
  ;;(add-to-list 'org-beamer-environments-extra '("sectionwithsectionpage" "T" "\\section{%h}\\begin{frame}{}\\sectionpage\\end{frame}" ""))
  (setq org-beamer-theme nil)
  (add-to-list 'org-latex-classes
               '("ajbeamer"
                 "\\documentclass[presentation]{beamer}
 \\usepackage[AUTO]{inputenc}
 \\usepackage[T1]{fontenc}
 \\usepackage[AUTO,shorthands=off]{babel}
 \\usepackage{ajbeamer}
 \\usepackage{textcomp}
 [NO-DEFAULT-PACKAGES]
 [NO-PACKAGES]
 [EXTRA]"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))))
#+end_src

***** New link types for beamer
****** Videoframe
#+begin_src emacs-lisp
(defun org-vframe-export-handler (path desc format)
  (let ((dsplit (split-string desc "::" t "[ \t]*")))
    (if (member format '(beamer latex))
        (format "\\videoframe[%s]{%s}{%s}" (or (nth 1 dsplit) "") path (or (car dsplit) ""))
      (format "VIDEO: %s (%s)" (or (car dsplit) "") path))))

(defun org-vframe-complete-link ()
  (aj/org-complete-link "vframe:"))

(org-link-set-parameters "vframe"
                         :follow #'aj/org-open-file-with-system
                         :export #'org-vframe-export-handler
                         :complete #'org-vframe-complete-link)
#+end_src

****** full-screen image in beamer
#+begin_src emacs-lisp
(autoload 'xah-replace-pairs-in-string "xah-replace-pairs")

(defun org-bfimg-export-handler (path desc format)
  (when (eq format 'beamer)
    (let ((eopt (when desc
                  (xah-replace-pairs-in-string
                   (concat "," (cadr (split-string desc "::")))
                   [["\\{" "{"] ["\\}" "}"]]))))
      (format "\\centering\\makebox[\\textwidth]{\\includegraphics[width=\\paperwidth,height=\\paperheight,keepaspectratio%s]{%s}}"
              (if (or (not eopt) (string= "," eopt)) "" eopt)
              path))))

(defun org-bfimg-complete-link ()
  (aj/org-complete-link "bfimg:"))

(org-link-set-parameters "bfimg"
                         :follow #'aj/org-open-file-with-system
                         :export #'org-bfimg-export-handler
                         :complete #'org-bfimg-complete-link)
#+end_src

***** Compatibility with ox-reveal
I’m trying out ox-reveal, but they have different ways of adding notes (subtrees vs special blocks). This makes sure a file prepared for reveal can also work with beamer
#+BEGIN_SRC emacs-lisp
(defun aj/org-export-reveal-note-to-beamer-note (string backend _info)
  (when (eq backend 'beamer)
    (replace-regexp-in-string
     "\\\\begin{NOTES}\\(\\(?:.\\|\n\\)+\\)\\\\end{NOTES}"
     "\\\\pnote{\\1}" string
     )))

(add-to-list 'org-export-filter-special-block-functions #'aj/org-export-reveal-note-to-beamer-note)
#+END_SRC

***** Hydra for templates
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'ox-beamer
  (bind-key "C-c C-ö" #'hydra-beamer-templates/body org-beamer-mode-map)
  (autoload #'yas-expand-snippet "yasnippet")
  (autoload #'yas-lookup-snippet "yasnippet")
  (defhydra hydra-beamer-templates (:color blue)
    "Beamer templates"
    ("t" (yas-expand-snippet (yas-lookup-snippet "Beamer title frame")) "Section title frame")
    ("v" (yas-expand-snippet (yas-lookup-snippet "Beamer vframe")) "videoframe")
    ("F" (yas-expand-snippet (yas-lookup-snippet "Beamer fullscreen image")) "Full screen image")
    ("i" (yas-expand-snippet (yas-lookup-snippet "Beamer image")) "Beamer image")
    ("f" (yas-expand-snippet (yas-lookup-snippet "Beamer figure")) "Beamer figure")
    ("b" (insert "#+BEAMER: ") "Beamer:")
    ("p" (insert "#+BEAMER: \\pause") "Pause")
    ("s" (insert "#+BEAMER: \\small") "Small")
    ("+" (aj/org-insert-element-attributes "#+ATTR_BEAMER: :overlay +-") "Overlay +-")
    ("T" (aj/org-insert-element-attributes "#+ATTR_BEAMER: :environment tightitemize") "Tightitemize"))
  )
#+END_SRC
**** Latex-check
#+begin_src emacs-lisp
(defun aj/org-lacheck (&optional subtreep)
  (interactive "P")
  (let* ((lat (org-export-as 'latex subtreep))
		 (ct (current-time))
		 (fn (format "/tmp/olc/%d%d.tex" (car ct) (nth 2 ct))))
	(find-file fn)
	(insert lat)
	(compile (format "lacheck %s" fn))))
#+end_src

*** Export without headlines (list-outline, h:0)
#+begin_src emacs-lisp
(defun aj/org-export-opt-no-hl (opt _backend)
  (plist-put opt :headline-levels 0))

(defun aj/org-export-no-sections (prefix)
  "Export without headlines (list-outline, h:0)"
  (interactive "P")
  (let ((org-export-filter-options-functions
         (cons 'aj/org-export-opt-no-hl org-export-filter-options-functions)))
	(org-export-dispatch prefix)))

;; (bind-key "C-M-c C-M-e" #'aj/org-export-no-sections org-mode-map)
#+end_src

*** TODO Export parent subtree :ARCHIVE:
:PROPERTIES:
:CUSTOM_ID: parent-subtree
:END:

This needs to be updated using ~org-num~ (check numbering in overlays). Until I need it, disable.

#+BEGIN_SRC emacs-lisp
;; this one is what I most often want
(defun aj/org-export-parent-subtree-infile (arg)
  "Exports the current file narrowed to subtree with scope ‘org-export-initial-scope’.
If ‘org-export-initial-scope’ is the default 'buffer, no shifting
 of headline levels should, so the export matches what it would
 look like if the complete document was exported. Prefix argument
 as in ‘aj/org-export-parent-subtree’"
  (interactive "P")
  (aj/org-export-parent-subtree arg t))

(bind-key "C-S-c C-S-e" #'aj/org-export-parent-subtree-infile org-mode-map)

(defvar-local aj/org-export-parent-subtree-level nil
  "If non-nil, the level of the parent subtree chosen by
‘aj/org-export-parent-subtree’")
(put 'aj/org-export-parent-subtree-level 'safe-local-variable
     (lambda (x) (or (integerp x) (null x))))

(bind-key "C-M-c C-M-e" #'aj/org-export-parent-subtree org-mode-map)

(defun aj/org-export-parent-subtree (arg &optional narrowed-export)
  "Launch `org-export-dispatch' at a parent subtree.
By default goes to level 1 or to the level defined in local
variable ‘aj/org-export-parent-subtree-level’. Numeric prefix
argument means go to that level. Repeated prefix arguments means
go up that many levels."
  (interactive "P")
  (let ((level (cond ((not arg) (or aj/org-export-parent-subtree-level 1))
                     ((listp arg) (floor (1+ (- (org-current-level)
                                                (log (car arg) 4)))))
                     ((integerp arg) arg)))
        (org-export-initial-scope (if narrowed-export
                                      org-export-initial-scope
                                    'subtree)))
    (if (<= 1 level (org-current-level))
        (save-mark-and-excursion
          (if (equal level (org-current-level))
              (org-back-to-heading)
            (while (let ((current (org-up-heading-safe)))
                     (and current
                          (not (eq current level))))))
          (if narrowed-export
              (progn
                (save-restriction
                  (org-narrow-to-subtree)
                  (cl-letf (((symbol-function 'org-export-output-file-name)
                             #'aj/org-export-unconditionally-return-subtree-filename)
                            (org-export-filter-final-output-functions ; This doesn’t work for async, of course
                             (cons #'aj/org-add-latex-numbering-start
                                   org-export-filter-final-output-functions))
                            (aj/org-latex-numbering-start (aj/org-get-current-hl-numbering)))
                    (org-export-dispatch))))
            (org-export-dispatch)))
      (user-error "Incorrect export level: %d. Current level: %d" level (org-current-level)))))

(defun aj/org-export-unconditionally-return-subtree-filename (ext &rest _rest)
  "Adds a filename derived from the heading name if no filename
is defined the subtree during org subtree export."
  (concat (aj/org-export-headline-filename
           (org-get-heading t t t t))
          ext))

;; stuff for setting the correct numbering. This only really works
;; when exporting top-level trees, since the parsing places the
;; current selected (subtree) at top-level, thus disrupting the
;; numbering totally if exporting say, level 2.4 (which will then
;; start out as chapter 2 in the exported tex-file). So these
;; functions do some unneccesary stuff right now.
;; Perhaps it is possible to change the parsing, but I haven’t found a
;; hack for that now.

(defun aj/org-get-current-hl-numbering ()
  (let ((outline-active org-num-mode))
    (unwind-protect
        (progn
          (org-num-mode 1)
          (when-let ((ov (nth 1 (overlays-in (point) (point-at-eol))))
                     (nh (overlay-get ov 'org-num))
                     (num (overlay-get ov 'display)))
            (split-string num "\\." t "[[:space:]]+")))
      (unless outline-active
        (org-num-mode -1)))))

(defvar aj/org-latex-numbering-start '("1"))

(defun aj/org-add-latex-numbering-start (string backend info)
  (when (org-export-derived-backend-p backend 'latex)
    (when-let ((class (plist-get info :latex-class))
               (classes (plist-get info :latex-classes))
               (secs (cl-subseq (cddr (assoc class classes))
                                0 (length aj/org-latex-numbering-start)))
               (secnames (cl-loop for s in (mapcar #'car secs)
                                  collect
                                  (when (string-match "\\\\\\([^}]+\\){%s}" s)
                                    (match-string 1 s)))))
      (replace-regexp-in-string
       "\\\\begin{document}"
       (concat "\\begin{document}\n"
               (cl-loop for sn in secnames
                        concat
                        (format "\\setcounter{%s}{%d}"
                                sn
                                (1- (string-to-number
                                     (pop aj/org-latex-numbering-start))))))
       string t t))))


#+END_SRC


*** Export and ignore everyting below a specific level, for some backends
I don’t really use this now, but I keep these variable definitions around since I have them in some old files and don’t want to hear the safe-local-variable complaints
#+begin_src emacs-lisp
(defvar-local aj/org-ignore-below-level nil)
(put 'aj/org-ignore-below-level 'safe-local-variable (lambda (arg) (or (integerp arg) (eq nil arg))))
(defvar-local aj/org-ignore-below-level-backends ())
(put 'aj/org-ignore-below-level-backends 'safe-local-variable
	 (lambda (arg) (and (listp arg)
                   (cl-every 'symbolp arg))))

(defvar aj/org-ignore-level-regexp "")
#+end_src


**** Funktioner :ARCHIVE:
#+BEGIN_SRC emacs-lisp
(defun aj/org-ignore-below-level (backend)
  "Makes sure to clean all content below level set by
`aj/org-ignore-below-level' if run by
`org-export-before-parsing-hook' and current backend is a member
of `aj/org-ignore-below-level-backends'."
  ;; (when (member backend '(odt);; aj/org-ignore-below-level-backends
  ;; )
  (setq aj/org-ignore-level-regexp
        (format "^\\*\\{1,%d\\} " 4 ;; aj/org-ignore-below-level
                ))
  (org-map-entries 'aj/org-clean-hl-contents))
;; )

(defun aj/org-clean-hl-contents ()
  "Helper function responsible for cleaning contents below specific level, run by `aj/org-ignore-below-level'"
  (when (= (org-current-level) aj/org-ignore-below-level)
	(end-of-line)
	(let ((sp (point)))
	  (when (search-forward-regexp aj/org-ignore-level-regexp nil t)
		(forward-line -1)
		(end-of-line)
		(delete-region sp (point))))))

(add-hook 'org-export-before-parsing-hook 'aj/org-ignore-below-level)
(remove-hook 'org-export-before-parsing-hook 'aj/org-ignore-below-level)


#+END_SRC
exportera bara manus till odt



*** Ignore headlines (but not content) with tag "ignoreheading" at export
Adapted from: [[http://orgmode.org/cgit.cgi/org-mode.git/plain/contrib/lisp/ox-extra.el][ox-extra.el]] ([[http://stackoverflow.com/a/29588450][Alternative]])

The last parts are some half-successful attempts to solve this for ox-reveal exports

#+BEGIN_SRC emacs-lisp
(defcustom aj/org-ignoreheading-tags '("ignoreheading")
  "Tags for which the heading should be removed but content kept
  in org export"
  :group 'aj
  :type '(repeat string)
  :safe (lambda (x) (cl-every #'stringp x)))

;; (defcustom aj/org-ignoreheadinglocal-tags '("ignoreheadinglocal")
;;   "Tags for which the heading should be removed after output,
;; but content kept in org export."
;;   :group 'aj
;;   :type '(repeat string)
;;   :safe (lambda (x) (cl-every #'stringp x)))

(defun aj/org-export-ignore-headlines (data backend info)
  (cond
   ((eq backend 'beamer) ; do nothing (maybe should?)
    data)
   (t
    (aj/org-data-remove-headline data backend info))))

(defun aj/org-data-remove-headline (data backend info)
  "Remove headlines tagged \"ignoreheading\" retaining contents and promoting children.
Each headline tagged \"ignoreheading\" will be removed retaining its
contents and promoting any children headlines to the level of the
parent."
  (org-element-map data 'headline
    (lambda (object)
      (when ; this is the difference to the version from ox-extra
          (cl-intersection aj/org-ignoreheading-tags
                           (org-element-property :tags object)
                           :test #'string=)
        (let ((level-top (org-element-property :level object))
              level-diff)

          (dolist (el (org-element-contents object))
            ;; recursively promote all nested headlines
            (org-element-map el 'headline
              (lambda (el)
                (unless level-diff
                  (setq level-diff (- (org-element-property :level el)
                                      level-top)))
                (org-element-put-property el :level
                                          (- (org-element-property :level el)
                                             level-diff))))
            ;; insert everything back into parse tree, except for segments
            ;; (non-headlines) on level 1 (believe that’s the
            ;; pathological case)
            (unless (and (= 1 level-top)
                         (not (equal 'headline (org-element-type el))))
              (org-element-insert-before el object))))
        (org-element-extract-element object)))
    info nil)
  (org-extra--merge-sections data backend info)
  data)

(defun org-extra--merge-sections (data _backend info)
  (org-element-map data 'headline
    (lambda (hl)
      (let ((sections
             (cl-loop
              for el in (org-element-map (org-element-contents hl)
                            '(headline section) #'identity info)
              until (eq (org-element-type el) 'headline)
              collect el)))
        (when (and sections
                   (> (length sections) 1))
          (apply #'org-element-adopt-elements
                 (car sections)
                 (cl-mapcan (lambda (s) (org-element-contents s))
                            (cdr sections)))
          (mapc #'org-element-extract-element (cdr sections)))))
    info))

;; (defun aj/org-mark-headline-to-be-removed (data backend info)
;;   "Mark headline to be removed in post-processing"
;;   (org-element-map data 'headline
;;     (lambda (hl)
;;       (when (cl-intersection aj/org-ignoreheadinglocal-tags
;;                           (org-element-property :tags hl))
;;         (org-element-put-property
;;          hl :title '(("!!!IGNOREHEADING!!!")))))
;;     info nil)
;;   data)

;; (defun aj/org-remove-marked-ignoreheadings (string backend info)
;;   (replace-regexp-in-string "<h2.*!!!IGNOREHEADING!!!.*h2>" ""
;;                             string)
;;   ;; string
;;   )

;; (add-to-list 'org-export-filter-final-output-functions #'aj/org-remove-marked-ignoreheadings)


(add-hook 'org-export-filter-parse-tree-functions #'aj/org-export-ignore-headlines)

#+END_SRC

*** stripheading, pre-parsing alternative to ignoreheading
Does not promote children so gives a sometimes different effect on the tree.

#+BEGIN_SRC emacs-lisp
(defun aj/org-export-strip-headings (_backend)
  "Strip lines containing \"stripheadings\" tag."
  (save-excursion
    (flush-lines ":stripheading:" )))

(add-hook 'org-export-before-parsing-hook #'aj/org-export-strip-headings)

#+END_SRC

*** by-backend, macro for some exports
#+begin_src emacs-lisp
(defmacro org-by-backend (&rest body)
  `(case org-export-current-backend ,@body))
#+end_src

*** Ignore or include trees with backend specific tags
#+BEGIN_SRC emacs-lisp
(defun aj/ox-sel-excl-by-backend (options backend)
  "Adds noexport_backend and export_backend to :exclude-tags
and :select-tags in org export."
  (let* ((ex (plist-get options :exclude-tags))
         (sel (plist-get options :select-tags))
         (bn (symbol-name backend))
         (par (org-export-backend-parent
               (ignore-errors (org-export-get-backend backend))))
         (par (when par (symbol-name par))))
    (push  (concat "noexport_" bn) ex)
    (push (concat "export_" bn) sel)
    (when par
      (push (concat "noexport_" par)  ex)
      (push (concat "export_" par) sel))
    (plist-put options :exclude-tags ex)
    (plist-put options :select-tags sel)
    options))

(add-to-list 'org-export-filter-options-functions #'aj/ox-sel-excl-by-backend)
#+END_SRC

** Publishing :org_async:
(projects are in custom.el)
#+BEGIN_SRC emacs-lisp
(setq ange-ftp-try-passive-mode t) ; needed!
#+END_SRC

** org-babel
#+BEGIN_SRC emacs-lisp
(setq org-babel-latex-htlatex-packages
      '("[usenames]{color}" "{tikz}" "{color}" "{listings}" "{amsmath}" "{pgfplots}")
      org-babel-load-languages
      '((awk . t) (latex . t) (emacs-lisp . t) (ditaa . t) (shell . t)))
#+END_SRC

** Cosmetics, display, faces
*** Fix org-indent
Redefine ~org-indent--compute-prefixes~ for better alignment
See discussion here: https://lists.gnu.org/archive/html/emacs-orgmode/2019-01/msg00235.html
#+begin_src emacs-lisp
(with-eval-after-load "org-indent"
  (defun org-indent--compute-prefixes ()
    "Compute prefix strings for regular text and headlines."
    (setq org-indent--heading-line-prefixes
	      (make-vector org-indent--deepest-level nil))
    (setq org-indent--inlinetask-line-prefixes
	      (make-vector org-indent--deepest-level nil))
    (setq org-indent--text-line-prefixes
	      (make-vector org-indent--deepest-level nil))
    (dotimes (n org-indent--deepest-level)
      (let ((indentation (if (<= n 1) 0
			               (* (1- org-indent-indentation-per-level)
			                  (1- n)))))
        ;; Headlines line prefixes.
        (let ((heading-prefix (make-string indentation ?*)))
	      (aset org-indent--heading-line-prefixes
	            n
	            (org-add-props heading-prefix nil 'face 'org-indent))
	      ;; Inline tasks line prefixes
	      (aset org-indent--inlinetask-line-prefixes
	            n
	            (cond ((<= n 1) "")
		              ((bound-and-true-p org-inlinetask-show-first-star)
		               (concat org-indent-inlinetask-first-star
			                   (substring heading-prefix 1)))
		              (t (org-add-props heading-prefix nil 'face 'org-indent)))))
        ;; Text line prefixes.
        (aset org-indent--text-line-prefixes
	          n
	          (org-add-props
		          (concat (make-string (+ n indentation) ?*)
			              (and (> n 0)
			                   (char-to-string org-indent-boundary-char)))
		          nil 'face 'org-indent))))))
#+end_src
*** Fontify src blocks natively
#+BEGIN_SRC emacs-lisp
(setq org-src-fontify-natively t)

;; (defun aj/org-avoid-hooks-in-fontify-block (fun lang beg end)
;;   (let* ((lang-mode (org-src--get-lang-mode lang))
;;          (hook (intern (concat (symbol-name lang-mode) "-hook"))))
;;     (if (and (fboundp lang-mode)
;;              (boundp hook))
;;         (cl-progv (list hook) (list nil)
;;           (funcall fun lang beg end))
;;       (funcall fun lang beg end))))

;; (advice-add 'org-src-font-lock-fontify-block :around
;;             #'aj/org-avoid-hooks-in-fontify-block)
#+END_SRC

*** Org Bullets
#+begin_src emacs-lisp
(use-package org-bullets
  :hook (org-mode . org-bullets-mode)
  :custom org-bullets-bullet-list
  ;; '("■" "■" "■""■" "■" "■" "■" "■" "■" "■" "■" "■" "■")
  '("▌" "▌" "▌" "▌" "▌" "▌" "▌" "▌" "▌" "▌" "▌" "▌" "▌" )
  ;; '("■" "━" "━" "━" "━" "━" "━" "━" "━" "━" "━"
  ;; "━" "━" "━" "━" "━" "━" "━" "━" "━" "━" "━")
  ;; '("✹" "✸" "✷" "✶" "✻" "✼" "✽" "✿" "❀" "❁"
  ;;   "❈" "❉" "❊" "❆" "▹" "▹" "▹" "▹")
  )
#+end_src

*** Scaling command for org tables
Sometimes a table is too wide for the window width, and becomes unreadable when lines wrap. One workaround is to do some face remapping to scale down the ~org-table~ face. A command for that is defined here.
#+begin_src emacs-lisp
(defvar-local aj/org-table-scale-remapping nil)

(defun aj/org-table-scale-reset ()
  (interactive)
  (face-remap-remove-relative aj/org-table-scale-remapping)
  (setq aj/org-table-scale-remapping nil))

(defun aj/org-table-scale (&optional increase)
  (interactive "P")
  "Decrease the font-size of org tables in current buffer.
With a prefix argument, increase the size, with a double prefix
argument, reset to default."
  (if (equal increase '(16))
      (aj/org-table-scale-reset)
    (let ((current (car (cdr-safe (assq :height aj/org-table-scale-remapping)))))
      (aj/org-table-scale-reset)
      (setq aj/org-table-scale-remapping
            (face-remap-add-relative
             'org-table 'org-table
             (list :height (if current
                               (+ current (if increase 0.1 -0.1))
                             0.8)))))))
#+end_src

*** Special tag faces and highlighting of special headlines
Add special tag faces, add for file-local select/exclude-tags. Highlight the entire headline for some tags.
#+begin_src emacs-lisp
(defface aj/org-special-tags-face '((t . (:inherit org-tag :underline t)))
  "Face for special tags"
  :group 'aj)

(defface aj/org-select-tags-face
  '((t . (:inherit (hydra-face-teal aj/org-special-tags-face))))
  "Face for select tags"
  :group 'aj)
(defface aj/org-exclude-tags-face
  '((t . (:inherit (hydra-face-red aj/org-special-tags-face))))
  "Face for exclude tags"
  :group 'aj)
(defface aj/org-ignoreheading-tags-face
  '((t . (:inherit (hydra-face-amaranth aj/org-special-tags-face))))
  "Face for ignoreheading tags"
  :group 'aj)

(defface aj/org-select-line-face '((t . (:inherit (bold underline))))
  "Face for selected headlines"
  :group 'aj)
(defface aj/org-exclude-line-face '((t . (:inherit (shadow italic))))
  "Face for excluded headlines"
  :group 'aj)
(defface aj/org-ignoreheading-line-face '((t . (:inherit (shadow))))
  "Face for ignored headlines"
  :group 'aj)

;; set tags, independent of current buffer
(setq org-tag-faces
      `(("noexport" aj/org-exclude-tags-face)
        ("export" aj/org-select-tags-face)
        ("notitle" aj/org-special-tags-face)
        ,@(cl-loop for i in aj/org-ignoreheading-tags
                   collect (list i 'aj/org-ignoreheading-tags-face))
        ("stripheading" aj/org-ignoreheading-tags-face)
        ("read_only" :inherit (aj/org-special-tags-face hydra-face-pink))
        ,@(cl-loop
           for b in org-export-backends
           append
           (let ((s (symbol-name b)))
             `((,(concat "export_" s) aj/org-select-tags-face)
               (,(concat "noexport_" s) aj/org-exclude-tags-face))))))

(org-set-tag-faces 'org-tag-faces org-tag-faces)

;; set tags and headlines, dependent on buffer settings
(defvar aj/org-special-tag-headline-faces
  '(("noexport" nil aj/org-exclude-line-face)
    ("export" nil aj/org-select-line-face)
    ("notitle" nil aj/org-ignoreheading-line-face)
    ("stripheading" nil aj/org-ignoreheading-line-face)))

(defun aj/org-local-special-tag-faces ()
  "Possibly add local SELECT and EXCLUDE tags to
‘org-tag-faces’ in current buffer."
  (let ((extratags
         (append
          (cl-loop for s in (aj/org-get-buffer-defined-tags "SELECT_TAGS")
                   collect (list s 'aj/org-select-tags-face
                                 'aj/org-select-line-face))
          (cl-loop for e in (aj/org-get-buffer-defined-tags "EXCLUDE_TAGS")
                   collect (list e 'aj/org-exclude-tags-face
                                 'aj/org-exclude-line-face))))
        (ignoretags (cl-loop for i in aj/org-ignoreheading-tags
                             collect (list i 'aj/org-ignoreheading-tags-face
                                           'aj/org-ignoreheading-line-face))))
    ;; special tag faces
    (when (or extratags (local-variable-p 'aj/org-ignoreheading-tags))
      (setq-local
       org-tag-faces
       (append org-tag-faces
               (cl-loop for (tag tf _lf) in (append extratags ignoretags)
                        collect (list tag tf))))
      (make-local-variable 'org-tags-face-special-faces-re)
      (org-set-tag-faces 'org-tag-faces org-tag-faces))

    ;; fontify whole line for some of them
    (setq org-font-lock-extra-keywords
          (append org-font-lock-extra-keywords
                  (cl-loop
                   for (tag _tf lf) in
                   (append aj/org-special-tag-headline-faces extratags ignoretags)
                   collect
                   (list
                    (concat
                     "^\\*+"
                     "\\(?: "
                     org-todo-regexp
                     "\\)?" ; optional todo
                     "\\(?: +\\(?:\\[#.\\]\\)\\)?" ; prio
                     "\\(?: +\\(?4:.*?\\)\\)??" ; heading, :4
                     "\\(?::\\([[:alnum:]_@#%:]+\\)\\)?" ; maybe tags before
                     ":" tag ":"
                     "\\(\\(?:[[:alnum:]_@#%:]+\\):\\)?" ; maybe tags after
                     )
                    `(4 ',lf prepend)))))))

;; instead of executing org-export--get-inbuffer-options, a short
;; custom function to get select/exclude-tags in only current buffer.
;; (this ignores if select/exclude tags are defined in a SETUPFILE,
;; for some reason, using get-inbuffer-options was problematic with
;; the repeated activations of org-mode when using a SETUPFILE,
;; instead of debugging it thoroughly, this works ok)
(defun aj/org-get-buffer-defined-tags (tag)
  (let ((re (org-make-options-regexp (list tag))))
    (org-with-wide-buffer
     (goto-char (point-min))
     (cl-loop while (re-search-forward re nil t)
              append
              (let ((element (org-element-at-point)))
                (when (eq (org-element-type element) 'keyword)
                  (split-string (org-element-property :value element))))))))

(add-hook 'org-font-lock-set-keywords-hook #'aj/org-local-special-tag-faces)
#+end_src
*** Cdlatex and pretty entities sub-super don’t work well together.
#+begin_src emacs-lisp
(add-hook 'cdlatex-mode-hook (lambda () (when (eq major-mode 'org-mode)
                                     (setq-local org-pretty-entities-include-sub-superscripts nil))))
#+end_src

*** Alternating bullets for plain lists
#+begin_src emacs-lisp
(setq org-list-demote-modify-bullet '(("+" . "-") ("-" . "+")))
#+end_src
*** Tags column at 0
I use variable-width fonts, so trying to align tags to the right is useless. But in the agenda we want them right aligned and setting it in the hook means we can adapt to the current window.
#+BEGIN_SRC emacs-lisp
(setq org-tags-column 0
      org-auto-align-tags nil)
(add-hook 'org-agenda-mode-hook '(lambda ()
                                  (setq org-agenda-tags-column (- (window-width)))))
#+END_SRC
*** COMMENT Indent quote-blocks
Trying to answer: https://emacs.stackexchange.com/questions/38570/org-mode-quote-block-indentation-highlighting

This works if ~org-indent-mode~ is not used. But I use it all the time so no use for me yet.
#+BEGIN_SRC emacs-lisp
(add-hook 'org-font-lock-hook #'aj/org-indent-quotes)

(defun aj/org-indent-quotes (limit)
  (let ((case-fold-search t))
    (while (search-forward-regexp "^[ \t]*#\\+begin_quote" limit t)
      (let ((beg (1+ (match-end 0))))
        ;; on purpose, we look further than LIMTI
        (when (search-forward-regexp "^[ \t]*#\\+end_quote" nil t)
          (let ((end (1- (match-beginning 0)))
                (indent (propertize "    " 'face 'org-hide)))
            (add-text-properties beg end (list 'line-prefix indent
                                               'wrap-prefix indent))))))))

(add-hook 'org-font-lock-hook #'aj/org-indent-quotes)
(remove-hook 'org-font-lock-hook #'aj/org-indent-quotes)

;; (let ((indent
;;        (propertize
;;         (concat (when org-indent-mode
;;                   (get-text-property beg 'line-prefix))
;;                 "    ")
;;         'face 'org-hide))))



;; (defun aj/org-indent-quotes-indent-mode (beg end _)
;;   (when org-indent-mode
;;     (save-excursion
;;       (goto-char beg)
;;       (aj/org-indent-quotes end))))

;; (advice-add 'org-indent-refresh-maybe :after #'aj/org-indent-quotes-indent-mode)

;; (advice-remove 'org-indent-refresh-maybe #'aj/org-indent-quotes-indent-mode)

#+END_SRC
** org-word-count
https://github.com/tesujimath/org-wc
An ideally flexible org word count would be based on the parser in org-element, where the right stuff could be excluded.
This one is based on regex walking and skipping though. And that is quite fast.
#+BEGIN_SRC emacs-lisp
(use-package org-wc
  :straight nil ;; TODO fix
  :load-path "~/kodat/elisp/org-wc"
  :commands (org-word-count org-wc-count-subtrees org-wc-display org-wc-remove-overlays)
  :bind (:map org-mode-map
              ("C-c C-=" . org-wc-display)))
#+END_SRC

** org-num-mode -- overlays for numbering outlines
Org 9.3 introduces a brilliant real-time solution for numbering outlines while editing.

Previous, slow solution:
https://gitlab.com/andersjohansson/org-outline-numbering
#+BEGIN_SRC emacs-lisp
(use-package org-num
  :straight nil
  :custom (org-num-skip-tags '("ignoreheading" "ignoreheadinglocal" "ARCHIVE"))
  (org-num-skip-unnumbered t)
  (org-num-skip-commented t))
#+END_SRC

** Open org links with alternate programs :ARCHIVE:
#+begin_src emacs-lisp
(defun aj/org-open-at-point-with-alternate (&optional arg refb)
  (interactive "P")
  (let ((org-file-apps '(("pdf" . "pdfxedit %s"))))
	(org-open-at-point arg refb)))

(define-key org-mode-map (kbd "C-c S-C-o") 'aj/org-open-at-point-with-alternate)
#+end_src



* Provide statement
#+BEGIN_SRC emacs-lisp
(provide 'aj-org-config)
#+END_SRC

* Provide statement async :org_async:no_default_tangle:
#+BEGIN_SRC emacs-lisp
(provide 'aj-org-config-org-async)
#+END_SRC

* Local variables for lisp :org_async:
#+BEGIN_SRC emacs-lisp
;; Local Variables:
;; byte-compile-warnings: (not make-local)
;; End:
#+END_SRC

* Local Variables :ARCHIVE:

# Local Variables:
# eval: (progn (require 'use-package) (variable-pitch-mode -1))
# aj/inhibit-flyspell: t
# End:
