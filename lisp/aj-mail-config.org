#+TITLE: Mail config file (mu4e)
#+AUTHOR: Anders Johansson
#+PROPERTY: header-args :tangle yes :comments no :no-expand t
#+TODO: KOLLA TODO | DONE

* Lexical-binding
#+begin_src emacs-lisp
;; -*- lexical-binding: t -*-
#+end_src

* mail-config
** Basic settings for mailing and auth
I use ~msmtp~ together with the queueing script ~msmtpq~ (included with ~msmtp~).
#+begin_src emacs-lisp
(setq message-send-mail-function #'message-send-mail-with-sendmail
      message-interactive nil ;; because msmtpq always returns message
      ;; that is interpreted as fail
      sendmail-program "msmtpq"
      message-sendmail-extra-arguments '("--read-recipients")
      mu4e-action-tags-header "Keywords")
;; (require 'auth-source-pass)
;; (auth-pass-enable)
#+end_src

** Display mail queue (from ~msmtpq~) in modeline
#+begin_src emacs-lisp
(defvar aj/mail-queue-modeline "")
(add-to-list 'global-mode-string '(t aj/mail-queue-modeline))

(defun aj/update-mail-queue-modeline (_event)
  (let ((l (length (directory-files "~/.msmtp.queue" nil "\\.mail$"))))
    (setq aj/mail-queue-modeline
          (if (< 0 l)
              (format " %d%s " l
                      (all-the-icons-alltheicon "arrow-right" :v-adjust 0.02))
            ""))))

;; first run
(aj/update-mail-queue-modeline t)
;; update on file changes
(defvar aj/mail-queue-watch
  (file-notify-add-watch "~/.msmtp.queue" '(change) #'aj/update-mail-queue-modeline))
#+end_src

** Definition of contexts -- private settings
#+begin_src emacs-lisp
;;(shouldn’t this be a macro)
(defun aj/construct-match-func (emailregexp)
  "Return a match function which matches :to fields of passed msg
or the from field if we are in `mu4e-compose-mode' with
EMAILREGEXP"
  `(lambda (msg)
     (or
      (and msg (mu4e-message-contact-field-matches msg :to ,emailregexp))
      (and (not msg) (eq major-mode 'mu4e-compose-mode) (string-match-p ,emailregexp (message-fetch-field "from"))))))


(defcustom aj/mu4e-refile-fns nil
  "List of functions for determining correct refile dir for a message.

Each function receives a message MSG and should return a string
with maildir or a list with a maildir string, which means let the
user choose, starting at that path."
  :group 'aj
  :type '(repeat function))

(require 'aj-mail-config-private)
#+end_src

** My custom tags
#+begin_src emacs-lisp
(defcustom aj/mail-tags '()
  "Tags I use for emails. Each element is a list with the name
of the tag, the color, the symbol and (optionally) the default refile
folder (if this is wrapped as a list it means the starting point
for refile folder selection)"
  :group 'aj
  :type '(repeat
          (cons :tag "Tag"
                (string :tag "Name")
                (set :tag "Properties"
                     (cons :tag "Color" (const color) string)
                     (cons :tag "Symbol" (const symbol) string)
                     (cons :tag "Refile dir" (const refile)
                           (choice (string :tag "Refile folder")
                                   (list :tag "Start for refile selection" string)))))))

(defun aj/mu4e-refile-by-tag (msg)
  "Refile according to tags in MSG."
  (when-let ((tag (car-safe (mu4e-msg-field msg :tags)))
             (tl (alist-get tag aj/mail-tags nil nil #'equal)))
    (alist-get 'refile tl)))

(add-to-list 'aj/mu4e-refile-fns #'aj/mu4e-refile-by-tag)
#+end_src

** Symbols
#+begin_src emacs-lisp
(defconst aj/mu4e-symbols-override
  '((mu4e-headers-draft-mark      ("D" . "📝")) ;; ✒ ✏
    (mu4e-headers-flagged-mark    ("F" . "🏴"))
    (mu4e-headers-new-mark        ("N" . " "))
    (mu4e-headers-passed-mark     ("P" . "↪")) ;; ↪ "→"
    (mu4e-headers-replied-mark    ("R" . "↩")) ;; "→"
    (mu4e-headers-seen-mark       ("S" . " ")) ;; ✓ 🗸 ✔
    (mu4e-headers-trashed-mark    ("T" . "🗑")) ;; 🗑
    (mu4e-headers-attach-mark     ("a" . "📎"))
    (mu4e-headers-encrypted-mark  ("x" . "🔐"))
    (mu4e-headers-signed-mark     ("s" . "🔏"))
    (mu4e-headers-unread-mark     ("u" . "● ") modus-themes-completion-match-2) ;; ★
    (mu4e-headers-list-mark       ("s" . "⚟"))
    (mu4e-headers-personal-mark   ("p" . "👨"))
    (mu4e-headers-calendar-mark   ("c" . "📅"))
    ))


(cl-loop for (var (letter . symbol) face) in aj/mu4e-symbols-override
         do (set var (cons letter (propertize symbol 'face (or face '(:weight normal))))))

(setq mu4e-headers-visible-flags
      '(list unread replied passed attach encrypted signed draft flagged calendar))
#+end_src

** Add ons
*** org-mu4e
#+begin_src emacs-lisp
(use-package mu4e-org
  :straight nil
  :demand t)
#+end_src

*** mu4e-crm-contacts :ARCHIVE:
Insert contacts with completing-read-multiple
https://gitlab.com/andersjohansson/mu4e-crm-contacts
#+begin_src emacs-lisp
(use-package mu4e-crm-contacts
  :straight (:depth full :host gitlab :repo "andersjohansson/mu4e-crm-contacts")
  :bind (:map mu4e-compose-mode-map
              ("<backtab>" . mu4e-crm-contacts-insert))
  :after mu4e-compose)
#+end_src

*** mu4e-alert :ARCHIVE:
Only display unread count in modeline
#+begin_src emacs-lisp
(use-package mu4e-alert
  :after mu4e
  :custom (mu4e-alert-set-window-urgency nil)
  :config
  (mu4e-alert-enable-mode-line-display)

  ;; (mu4e-alert-set-default-style 'notifications)
  ;; (defun aj/open-mu4e-unread (&rest _args)
  ;;   (if-let (window
  ;;            (cl-loop with res = nil
  ;;                     for buffer in (list mu4e~headers-buffer mu4e~view-buffer mu4e~main-buffer-name)
  ;;                     if (setq res (and buffer (get-buffer-window buffer t))) return res))
  ;;       (progn
  ;;         (select-frame-set-input-focus (window-frame window))
  ;;         (select-window window))
  ;;     (select-frame-set-input-focus (make-frame)))
  ;;   (mu4e-alert-view-unread-mails))

  ;; (defun mu4e-alert-notify-unread-messages (mails)
  ;;   "Display desktop notification for given MAILS."
  ;;   (let* ((mail-groups (funcall mu4e-alert-mail-grouper
  ;;                                mails))
  ;;          (sorted-mail-groups (sort mail-groups
  ;;                                    mu4e-alert-grouped-mail-sorter))
  ;;          (notifications (mapcar (lambda (group)
  ;;                                   (funcall mu4e-alert-grouped-mail-notification-formatter
  ;;                                            group
  ;;                                            mails))
  ;;                                 sorted-mail-groups)))
  ;;     (dolist (notification (cl-subseq notifications 0 (min 5 (length notifications))))
  ;;       (notifications-notify :body (plist-get notification :body)
  ;;                             :title (plist-get notification :title)
  ;;                             :actions '("default" "Open mails")
  ;;                             :on-action 'aj/open-mu4e-unread
  ;;                             :category "mu4e-alert"))
  ;;     (when notifications
  ;;       (mu4e-alert-set-window-urgency-maybe))))

  ;; (defun mu4e-alert-notify-unread-messages-count (mail-count)
  ;;   "Display desktop notification for given MAIL-COUNT."
  ;;   (when (not (zerop mail-count))
  ;;     (notifications-notify :body (funcall mu4e-alert-email-count-notification-formatter
  ;;                                          mail-count)
  ;;                           :title mu4e-alert-email-count-title
  ;;                           :actions '("default" "Open mails")
  ;;                           :on-action 'aj/open-mu4e-unread
  ;;                           :category "mu4e-alert")))
  )
#+end_src

*** mu4e-query-helper :ARCHIVE:
Some completion for searching, more extensive than the recently included completion-at-point functions in mu4e-search.
Available at: https://gitlab.com/andersjohansson/mu4e-query-helper

#+begin_src emacs-lisp
(use-package mu4e-query-helper
  :straight (:depth full :host gitlab :repo "andersjohansson/mu4e-query-helper")
  :after mu4e-headers
  :bind (:map mu4e-search-minor-mode-map
		      ("s" . mu4e-query-helper-search)
		      ("S" . mu4e-query-helper-search-edit)))
#+end_src

** Contact handling
*** LDAP (EUDC) :ARCHIVE:
#+begin_src emacs-lisp
(with-eval-after-load 'mu4e-compose
  (bind-key "C-c C-ä" #'eudc-expand-inline mu4e-compose-mode-map))

(setq eudc-server-hotlist
      '(("ldap://localhost:1389" . ldap)))
(eudc-set-server "ldap://localhost:1389" 'ldap)
(setq eudc-expansion-overwrites-query t)

(defun aj/display-eudc-info-at-point ()
  (interactive)
  (if-let ((email (or (get-text-property (point) 'email)
                      (thing-at-point 'email t))))
      (aj/display-eudc-info-other-buffer (s-chop-prefix "<" (s-chop-suffix ">" email)))
    (user-error "No address found at point")))

;;TODO, try to parse address around point also ^

(defvar aj/interesting-ldap-fields '(cn title department mail telephonenumber mobile uid manager))

(dolist (i '((title . "Title")
             (department . "Institution")
             (mail . "Mail")
             (mobile . "Mobil")
             (uid . "ID")
             (manager . "Chef")))
  (add-to-list 'eudc-user-attribute-names-alist i))

(defun aj/display-eudc-info-other-buffer (email)
  (interactive "sEmail: ")
  (if-let ((results (eudc-query `((mail . ,email)))))
      (let ((buf (get-buffer-create "*aj-eudc*")))
        (unless (eq buf (current-buffer))
          (view-buffer-other-window buf)
          (with-current-buffer buf
            (let* ((inhibit-read-only t)
                   (fields (cl-loop for f in aj/interesting-ldap-fields
                                    collect
                                    (cons f (eudc-format-attribute-name-for-display f))))
                   (fieldlength (cl-loop for f in fields maximize (length (cdr f)))))
              (erase-buffer)
              (cl-loop for result in results
                       do
                       (cl-loop for f in fields
                                do
                                (when-let (ff (alist-get (car f) result))
                                  (eudc-print-record-field
                                   (cons (cdr f)
                                         (decode-coding-string ff 'utf-8))
                                   fieldlength))
                                )
                       (insert "\n"))))))
    (user-error "No results found for address %s" email)))


;; TODO. Gör "Chef", klickbar. Kanske går att göra med en lämplig
;; funktion för den (och för id, men det är nog mer meningslöst) i:
;; eudc-attribute-display-method-alist
#+end_src

** View mode
*** Avoid shr filling paragraphs
In html emails, shr by default fills paragraph, and the column used is ~fill-column~, set in ~mm-shr~. I don’t want this, because I use ~visual-line-mode~ as well as ~visual-fill-column-mode~. Setting ~fill-column~ to 0 sets ~shr-width~ to 0, which avoids all filling.

This is especially good for avoiding unneccesarily filled quoted original messages.
#+begin_src emacs-lisp
(advice-add 'mm-shr :around #'aj/mm-shr-fix-width)

(defun aj/mm-shr-fix-width (fun &rest args)
  (let ((fill-column 0)
        (shr-use-fonts nil))
    (apply fun args)))
#+end_src

*** Standard settings
#+begin_src emacs-lisp
(add-hook 'mu4e-view-mode-hook #'variable-pitch-mode)
(add-hook 'mu4e-view-mode-hook #'visual-line-mode)
;; with visual-line-mode, no need to fill headers

;; (add-to-list 'mu4e-view-actions '("Webkit-widget" . mu4e-action-view-with-xwidget))
(setq mu4e-html2text-command 'mu4e-shr2text)
#+end_src

*** Clean up headers in gnus-view, shorten addresses
It is good to be able to see that the address we get an email from is correct, but we don’t need to see the full address. This little patching to ~mu4e--view-render-buffer~  displays the domain name or possibly a short symbol fetched from the list ~aj/mail-domain~.

Secure and economical.
#+begin_src emacs-lisp
(advice-add 'mu4e--view-render-buffer :after #'aj/article-prettify-addresses)

(defmacro aj/with-article-narrowed-to-header (header &rest body)
  "If HEADER field is found, execute BODY with buffer narrowed to it."
  (declare (indent 1) (debug t))
  `(let ((case-fold-search t)
         ;; start end
         )
     (article-narrow-to-head)
     (when
         (re-search-forward (concat "^" ,header ": ") nil t)
       (narrow-to-region
        (point)
        (progn
          (forward-line 1)
          (if (re-search-forward "^[^ \n\t]" nil t)
	          (1- (point-at-bol))
            (point-max))))
       ,@body)
     (widen)))

(defun aj/article-prettify-addresses (&rest _ignore)
  "Remove line-breaks in address headers and prettify adresses."
  (save-excursion
    (save-restriction
      (let ((inhibit-read-only t))
        (cl-loop for (h . fun) in '(("From" . gnus-button-reply)
                                    ("To" . gnus-msg-mail)
                                    ("CC" . gnus-msg-mail))
                 do
                 (aj/with-article-narrowed-to-header h
                   (let ((new (aj/prettify-address-header
                               (buffer-substring-no-properties
                                (point-min) (point-max))
                               fun)))
                     (delete-region (point-min) (point-max))
                     (insert new))
                   (when (< (point-min) (point-max))
                     (put-text-property (point-min) (1- (point-max))
                                        'wrap-prefix
                                        `(space :align-to ,(+ 2 (length h)))))))))))

(defun aj/prettify-address-header (addresses &optional gnus-callback)
  "Prettify ADDRESSES string, make buttons using GNUS-CALLBACK function."
  (let (gnus-article-button-face
        ;; A hack for making mail-header-parse-addresses work with an
        ;; already decoded (non-ascii) list of addresses. Otherwise
        ;; names like ”Elin Ågren” gets "translated" to “Elin gren”,
        ;; because ‘ietf-drums-parse-address’ assumes first letters in
        ;; name-words should be ascii (but not the full string, which
        ;; is why “Hrvoje Nikšić <hniksic@srce.hr>”, given in the
        ;; example in Info node `(emacs-mime)Interface Functions',
        ;; works.
        ;; TODO, is this a bug that should be reported?
        (ietf-drums-atext-token (concat ietf-drums-atext-token "[:alpha:]")))
    (string-join
     (cl-loop for (email . name) in (mail-header-parse-addresses addresses)
              collect
              (with-temp-buffer
                (insert (if name
                            (format "%s%s"
                                    (propertize name 'face 'message-header-cc)
                                    (aj/mu4e-mail-domain-symbol email))
                          email))
                (gnus-article-add-button (point-min) (point-max) gnus-callback
                                         (if name
                                             (format "%s <%s>" name email)
                                           email))
                (buffer-string)))
     ", ")))

(defun aj/mu4e-mail-domain-symbol (email)
  (let ((maildomain (cadr (split-string (string-trim email "'" "'") "@")))
        (mailstring (concat "<" email ">")))
    (cl-loop for (d . s) in aj/mail-domains
             when (string-match-p d maildomain)
             return
             (cond
              ((null s) (propertize (concat " " mailstring) 'display ""))
              ((stringp s)
               (propertize (concat " " mailstring) 'display
                           (concat " " (propertize s 'face 'aj/shadow-fringe))))
              ((listp s)
               (concat " "
                       (propertize mailstring
                                   'display
                                   (create-image
                                    (car s) nil nil
                                    :height (round (* (or (cadr s) 0.8)
                                                      (line-pixel-height)))
                                    :ascent 'center)))
               ))
             finally return
             (propertize
              (concat " " mailstring)
              'display
              (propertize (concat " (" maildomain ")") 'face 'shadow)))))

(defcustom aj/mail-domains nil
  "Alist of mappings between regexps for an email domain and display string.

If found, the display string is shown instead of the full domain when displaying emails in mu4e.
The display string can also be a list with a path to an image.
Examples:
((\"chalmers.se$\" . \"🅒\")
 (\"uu.se$\" . \"🅤\")))
"
  :group 'aj
  :type '(alist :key-type regexp :value-type (choice string (const nil) (list file))))
#+end_src

*** Save-attachment, with open function that suits me better
#+begin_src emacs-lisp
(define-key mu4e-view-mode-map [remap mu4e-view-save-attachments] #'aj/mu4e-view-save-attachments)
(define-key mu4e-view-mode-map "o" #'aj/mu4e-view-open-attachments)

(defun aj/mu4e-view-save-attachments (&optional arg open)
  "Save mime parts from current mu4e gnus view buffer.
Queries for directory to save in, or just saves to
‘mu4e-attachment-dir’ if prefix ARG is given."
  (interactive "P")
  (let* ((parts (mu4e-view-mime-parts))
         (candidates  (seq-map
                       (lambda (fpart)
                         (cons ;; (filename . annotation)
                          (plist-get fpart :filename)
                          fpart))
                       (seq-filter
                        (lambda (part) (plist-get part :attachment-like))
                        parts)))
         (candidates (or candidates
                         (mu4e-warn "No attachments for this message")))
         (files (mu4e--completing-read "Save file(s): " candidates
                                       'attachment 'multi))
         (custom-dir (unless arg (read-directory-name "Save to directory: "))))
    (if files
        (dolist (fname files)
          (let* ((part (cdr (assoc fname candidates)))
                 (path (mu4e--uniqify-file-name
                        (mu4e-join-paths
                         (or custom-dir (plist-get part :target-dir))
                         (plist-get part :filename))))
                 (path (if (file-exists-p path)
			               (let (newname (count 1))
				             (while (and
					                 (setq newname
					                       (concat
						                    (file-name-sans-extension file)
						                    (format "(%s)" count)
						                    (file-name-extension file t)))
					                 (file-exists-p newname))
				               (cl-incf count))
				             newname)
			             path)))
            (mm-save-part-to-file (plist-get part :handle) path)
            (when open (embark-open-externally path))))
      (mu4e-message "No attached files found"))))

(defun aj/mu4e-view-open-attachments (arg)
  (interactive "P")
  (aj/mu4e-view-save-attachments (not arg) t))
#+end_src

** Command for quick check of new mails
#+begin_src emacs-lisp
;;(defvar aj/mu4e-get-mail-command-quick "mbsync --new -qq uu-inbox gmail-inbox ajf-inbox")
(defvar aj/mu4e-get-mail-command-quick "aj-mailsync-quick")

(defun aj/mu4e-update-mail-and-index (full?)
  "Quickly update inbox. Arg FULL? for full sync."
  (interactive "P")
  (if full?
      (mu4e-update-mail-and-index t)
    (let ((mu4e-get-mail-command aj/mu4e-get-mail-command-quick))
      (mu4e-update-mail-and-index t))))

(bind-key "C-c C-u" #'aj/mu4e-update-mail-and-index mu4e-update-minor-mode-map)
#+end_src

** Composing and sending

*** Remove ~Sv:~, ~Aw:~ or other localized variants of ~Re:~ when replying.
This is used in ~message-strip-subject-re~, which cleans the subject up before replying.
#+begin_src emacs-lisp
(setq message-subject-re-regexp "^[ 	]*\\(\\(?:A\\(?:ng\\|[Ww]\\)\\|R\\(?:EF\\|ef\\|[Ee]\\)\\|S[Vv]\\)\\(\\[[0-9]*\\]\\)* ?:[ 	]*\\)*[ 	]*")

;; generated by
;;(regexp-opt '("Re" "RE" "Sv" "SV" "REF" "Ref" "AW" "Aw" "Ang"))
#+end_src

*** Format=flowed, but with long lines
As most clients (outlook etc.) don’t support format=flowed correctly anyway. Sending as long lines as possible will mostly make it look ok.
https://vxlabs.com/2019/08/25/format-flowed-with-long-lines/
#+begin_src emacs-lisp
(setq mu4e-compose-format-flowed t
      fill-flowed-encode-column 998
      ;; because we use visual-fill-column-mode
      fill-flowed-display-column most-positive-fixnum)

;; Better behaviour with use-hard-newlines?
;; (defun aj/use-hard-newlines ()
;;   (use-hard-newlines t t))
;; (add-hook 'mu4e-compose-mode-hook #'aj/use-hard-newlines)
#+end_src

*** Some compose settings
#+begin_src emacs-lisp
(setq mail-user-agent #'mu4e-user-agent
      mu4e-compose-hidden-headers '("^Face:" "^X-Face:" "^X-Draft-From:" "^User-agent:" "References:" "In-Reply-To" "Message-ID:" "Fcc:"))

;; in case write is invoked before mu4e is loaded
(add-hook 'mu4e-compose-pre-hook #'mu4e--start)
#+end_src

*** Remove signature function, used below
#+begin_src emacs-lisp
(defun aj/message-remove-signature ()
  "Find and remove signature."
  (save-excursion
    (when (message-goto-signature)
      (forward-line -1)
      (delete-region (1- (point)) (point-max)))))
#+end_src

*** Signature cycling
I have long and "official" signatures defined for my accounts, but often I want to just include my name, or nothing at all. This function allows me to cycle through the signature set in the context (variable ~message-context~), a list of shorter ones, and localized signatures when writing in different languages (English and Swedish really).

Also commented below is a function for switching signature language automatically with guess-language. I found it too unpredictable however (for example when replying in a different language) and just switching manually gives better control.
#+begin_src emacs-lisp
(defvar aj/message-simple-signatures '((none . ""))
  "Alist of signature names (symbol) and signatures (strings).")
(defvar aj/mu4e-compose-localized-signatures nil
  "Alist of language symbols and signature strings.
Set in my private mail config, possibly with mu4e context.")

(defvar-local aj/message-sig-cycle 0)

(defun aj/message-signature-cycle ()
  (interactive)
  (let ((sigs (cl-remove nil
                         (cl-remove-duplicates
                          (append (list (cons 'initial message-signature))
                                  aj/message-simple-signatures
                                  aj/mu4e-compose-localized-signatures)
                          :test #'equal :key #'cdr :from-end t))))
    (setq aj/message-sig-cycle
          (mod (1+ aj/message-sig-cycle)
               (length sigs)))
    (aj/message-change-signature (nth aj/message-sig-cycle sigs) t)))

(bind-key "C-c C-p" #'aj/message-signature-cycle mu4e-compose-mode-map)

(cl-defun aj/message-change-signature ((name . sig) &optional show)
  (save-excursion
    (aj/message-remove-signature)
    (let ((message-signature sig))
      (unless (or (not sig) (string= message-signature ""))
        (message-insert-signature))
      (message "Switched to signature %s"
               (propertize (symbol-name name) 'face 'bold)))
    (when show
      ;; to be able to see what happens in a long message:
      (sit-for 0.6))))

;; Switch signature with guess-language?

;; (with-eval-after-load 'guess-language
;;   (add-to-list 'guess-language-after-detection-functions
;;                #'aj/message-switch-signature-language))

;; (defun aj/message-switch-signature-language (lang _beg _end)
;;   (when (eq major-mode 'mu4e-compose-mode)
;;     (aj/message-change-signature
;;      (alist-get lang aj/mu4e-compose-localized-signatures))))
#+end_src

*** KOLLA Allow and handle context change while composing :ARCHIVE:
I often open a compose buffer without checking the context. The functions below make sure that switching context in a compose buffer works as expected. A function to switch address and signature when switching context is defined. However, several compose buffers may be open at once, and this will only switch for the current buffer (which I believe is the most reasonable behaviour). To ensure that we don’t attempt to send a message with the wrong context active, a function to check if the context matches with the from address is added to ~message-send-hook~.
#+begin_src emacs-lisp
(defun aj/mu4e-compose-context-switch (&rest _ignore)
  "When switching context in a compose buffer, switch “from” and signature."
  (when (eq major-mode 'mu4e-compose-mode)
    (message-replace-header "From" (mu4e~draft-from-construct))
    (message-replace-header "Reply-to" mu4e-compose-reply-to-address)
    (setq-local message-signature mu4e-compose-signature)
    (setq aj/message-sig-cycle 0)
    (aj/message-remove-signature)
    (save-excursion (message-insert-signature))))

(advice-add 'mu4e-context-switch :after #'aj/mu4e-compose-context-switch)

(defun aj/message-send-check-context ()
  "Check that from address and context matches, and ask to change if required.

This is to avoid making mistakes in trying to send the current
message from the wrong account"
  ;; this may be a too strict check
  (when (not
         (or
          (null mu4e-contexts)
          (string= (message-fetch-field "from")
                   (mu4e~draft-from-construct))))
    (let ((context (mu4e-context-determine nil nil)))
      (cond ((and context
                  (y-or-n-p
                   (format
                    "Attempt to send via mismatching context. Switch to [%s] and send? "
                    (mu4e-context-name context))))
             (mu4e-context-switch t (mu4e-context-name context)))
            ((not context)
             (mu4e-context-switch
              t
              (mu4e-context-name  ; throws an error if no context found:
               (mu4e~context-ask-user
                "Attempt to send via mismatching context! Send after switching to: "))))
            (t (signal 'quit nil))))))

(add-hook 'message-send-hook #'aj/message-send-check-context)
#+end_src

*** KOLLA Context cycling :ARCHIVE:
I want to use a single binding to switch (cycle through) contexts when composing.
#+begin_src emacs-lisp
(defun aj/mu4e-cycle-contexts ()
  "Cycle through `mu4e-contexts'."
  (interactive)
  (when mu4e-contexts
    (let* ((names (mapcar #'mu4e-context-name mu4e-contexts))
           (currentname (ignore-errors (mu4e-context-name mu4e~context-current))))
      (mu4e-context-switch t
                           (nth
                            (mod (if currentname
                                     (1+ (cl-position currentname names :test #'equal))
                                   0)
                                 (length names))
                            names)))))

(bind-key "C-c C-i" #'aj/mu4e-cycle-contexts mu4e-compose-mode-map)
#+end_src

*** Ask for confirmation before sending mail
#+begin_src emacs-lisp
(setq message-confirm-send t)
#+end_src

*** Let flyspell only check relevant regions
#+begin_src emacs-lisp
(put 'mu4e-compose-mode 'flyspell-mode-predicate #'mail-mode-flyspell-verify)
#+end_src
**** Home grown  :ARCHIVE:
#+begin_src emacs-lisp
(defun aj/mu4e-compose-flyspell-ignore ()
  "Function used for `flyspell-generic-check-word-predicate' to ignore headers in message-mode"
  (or (and (message-in-body-p) (not (aj/message-in-signature-p)))
      (and (save-excursion (beginning-of-line)
                           (looking-at-p "^Subject: "))
           (not (org-in-regexp "Subject:")))))

(autoload 'org-in-regexp "org")

(defun aj/message-in-signature-p ()
  (save-excursion
    (save-match-data
      (re-search-backward message-signature-separator nil t))))

(put 'mu4e-compose-mode 'flyspell-mode-predicate #'aj/mu4e-compose-flyspell-ignore)
#+end_src
*** Identity switching in compose buffer :ARCHIVE:
#+begin_src emacs-lisp
(bind-keys
 :map mu4e-compose-mode-map
 ("C-c C-i" . aj/message-switch-uu-identity)
 ("C-c C-p" . aj/message-signature-cycle))

(defvar aj/message-current-uu-identity "Physics")

(defun aj/message-switch-uu-identity ()
  (interactive)
  (setq aj/message-current-uu-identity
        (if (string= aj/message-current-uu-identity "Physics")
            "Gender"
          "Physics")
        aj/message-sig-cycle 0)
  (let* ((cv (mu4e-context-vars
              (aj/mu4e-context-get-context
               aj/message-current-uu-identity)))
         (user-mail-address (cdr (assoc 'user-mail-address cv)))
         (message-signature-file (cdr (assoc 'message-signature-file cv)))
         (message-signature t))
    (save-excursion
      (aj/message-change-from (message-make-from))
      (aj/message-remove-signature)
      (message-insert-signature))))
#+end_src
*** Automatically refile message efter reply or forward :ARCHIVE:
When I have acted upon a message I refile it from the inbox. Replying or forwarding almost certainly means I want to do this.

I have never gotten this to work though.
#+begin_src emacs-lisp
;; (defvar aj/mu4e-rep-msg-tmp nil)
;; (defun aj/mu4e~compose-set-parent-flag (path)
;;  "Also refile the replied message to archive"
;;  (let ((buf (find-file-noselect path)))
;;    (when buf
;;      (with-current-buffer buf
;;        (message-narrow-to-headers-or-head)
;;        (let ((in-reply-to (message-fetch-field "in-reply-to"))
;;              (forwarded-from)
;;              (references (message-fetch-field "references"))
;;              (mu4e-view-func (lambda (msg) (setq aj/mu4e-rep-msg-tmp msg))))
;;          (unless in-reply-to
;;            (when references
;;              (with-temp-buffer ;; inspired by `message-shorten-references'.
;;                (insert references)
;;                (goto-char (point-min))
;;                (let ((refs))
;;                  (while (re-search-forward "<[^ <]+@[^ <]+>" nil t)
;;                    (push (match-string 0) refs))
;;                  ;; the last will be the first
;;                  (setq forwarded-from (first refs))))))
;;          ;; remove the <>
;;          (when (and in-reply-to (string-match "<\\(.*\\)>" in-reply-to))
;;            (mu4e~proc-view (match-string 1 in-reply-to))
;;            (mu4e--server-move (match-string 1 in-reply-to)
;;                            (and (accept-process-output mu4e~proc-process 1)
;;                                 (aj/mu4e-refile-folder aj/mu4e-rep-msg-tmp t))
;;                            "+R-N-F"))
;;          (when (and forwarded-from (string-match "<\\(.*\\)>" forwarded-from))
;;            (mu4e~proc-view (match-string 1 forwarded-from))
;;            (mu4e--server-move (match-string 1 forwarded-from)
;;                            (and (accept-process-output mu4e~proc-process 1)
;;                                 (aj/mu4e-refile-folder aj/mu4e-rep-msg-tmp t))
;;                            "+P-N-F"))))))
;;  (setq aj/mu4e-rep-msg-tmp nil))


;; variant:
;; (defun aj/mu4e~compose-set-parent-flag (path)
;;  "Also refile the replied message to archive"
;;  (let ((buf (find-file-noselect path)))
;;    (when buf
;;      (with-current-buffer buf
;;        (message-narrow-to-headers-or-head)
;;        (let ((in-reply-to (message-fetch-field "in-reply-to"))
;;              (forwarded-from)
;;              (references (message-fetch-field "references"))
;;              (mu4e-view-func (lambda (msg) (setq aj/mu4e-rep-msg-tmp msg))))
;;          (unless in-reply-to
;;            (when references
;;              (with-temp-buffer ;; inspired by `message-shorten-references'.
;;                (insert references)
;;                (goto-char (point-min))
;;                (let ((refs))
;;                  (while (re-search-forward "<[^ <]+@[^ <]+>" nil t)
;;                    (push (match-string 0) refs))
;;                  ;; the last will be the first
;;                  (setq forwarded-from (first refs))))))
;;          ;; remove the <>
;;          (when (and in-reply-to (string-match "<\\(.*\\)>" in-reply-to))
;;            (let ((msgid (match-string 1 in-reply-to)))
;;              (mu4e~proc-view msgid)
;;              ;; (accept-process-output mu4e~proc-process 10 nil)
;;              (message "AJ: %s" aj/mu4e-rep-msg-tmp)
;;              ;; (mu4e--server-move msgid
;;              ;;                 (and aj/mu4e-rep-msg-tmp
;;              ;;                      (aj/mu4e-refile-folder aj/mu4e-rep-msg-tmp t))
;;              ;;                 "+R-N-F")
;;              ))
;;          (when (and forwarded-from (string-match "<\\(.*\\)>" forwarded-from))
;;            (mu4e~proc-view (match-string 1 forwarded-from))
;;            ;;(accept-process-output mu4e~proc-process 1 nil t)
;;            (mu4e--server-move (match-string 1 forwarded-from)
;;                            (and aj/mu4e-rep-msg-tmp
;;                                 (aj/mu4e-refile-folder aj/mu4e-rep-msg-tmp t))
;;                            "+P-N-F"))))))
;;  (setq aj/mu4e-rep-msg-tmp nil))
;; (advice-add 'mu4e~compose-set-parent-flag :override #'aj/mu4e~compose-set-parent-flag)

#+end_src

*** Yank adressess
#+begin_src emacs-lisp
;; (defun aj/message-yank-adressess ()
;;   (interactive)
;;   (let* ((ck (current-kill 0))
;;          (cksp (split-string ck "\n" t "[ 	]+")))
;;     (if (< 1 (safe-length cksp))
;;         (insert (mapconcat 'substring-no-properties cksp ", "))
;;       (insert-for-yank ck))))

;; (bind-key "C-c M-y" #'aj/message-yank-adressess mu4e-compose-mode-map)

(define-key mu4e-compose-mode-map [remap yank] #'aj/message-yank-addressess)

(defun aj/message-yank-addressess ()
  "Yank addresses correctly if we are in address field, otherwise yank."
  (interactive)
  (if (save-excursion (beginning-of-line) (looking-at-p "\\(To\\|Cc\\Bcc\\):"))
      (let* ((ck (current-kill 0))
             (cksp (split-string ck "\n" t "[ 	]+")))
        (if (< 1 (safe-length cksp))
            (insert (mapconcat 'substring-no-properties cksp ", "))
          (insert-for-yank ck)))
    (yank)))
#+end_src

*** Don’t return to mu4e buffers when mail has been sent
I often invoke a compose buffer in a window where I’m doing something else, and when mu4e then wants to helpfully switch back to the headers buffer or something, my window config gets messed up. Just revert back to doing ~message-kill-buffer~ is better.
#+begin_src emacs-lisp
(advice-add 'mu4e-message-kill-buffer :override #'message-kill-buffer)
#+end_src

*** Mail greetings
Quickly insert a "Hi NN" with correct name, or if we are at the end of the mail, a "Best, NN".
#+begin_src emacs-lisp
(defvar reftex-cite-punctuation)
(defun aj/mail-insert-greeting (&optional firstname)
  "Insert a language dependent (informal) greeting when composing a mail.
Recipient names are fetched from the To field. Prefix-argument
FIRSTNAME means greet only first recipient.
If not at beginning of body, insert “Best, NN” greeting."
  (interactive "P")
  (require 'reftex-cite)
  (let ((sv (eq 'sv (aj/buffer-language-or-guess))))
    (if (looking-back (concat mail-header-separator "[[:space:]]"))
        (when-let ((names
                    (save-excursion
                      (save-restriction
                        (widen)
                        (message-narrow-to-headers-or-head)
                        (cl-loop for (name _email) in (mail-extract-address-components
                                                       (message-fetch-field "To" t) t)
                                 collect (car (split-string name)))))))
          (let ((reftex-cite-punctuation (if sv '(", " " och " "") '(", " " and " ""))))
            (insert
             (if sv "Hej" "Hi")
             " "
             (if firstname
                 (car names)
               (reftex-format-names names 100))
             ",\n")))
      (insert (if sv "Vänliga hälsningar,\n" "Best,\n")
              user-full-name))))

(defun aj/buffer-language-or-guess ()
  "Return symbol sv if we should write in Swedish, else assume english, en."
  (if ispell-current-dictionary
      (if (aj/writing-swedish-p) 'sv 'en)
    (guess-language-buffer)))

(bind-key "C-c C-å" #'aj/mail-insert-greeting 'mu4e-compose-mode-map)
#+end_src

*** Customize cite string
#+begin_src emacs-lisp

;; customize the reply-quote-string
(setq message-citation-line-format "\n\nOn %A %-e %b %Y at %R, %f wrote:\n")
;; choose to use the formatted string, with some language guessing
(setq message-citation-line-function #'aj/message-insert-formatted-citation-line)

(autoload #'guess-language-buffer "guess-language")

(defun aj/message-insert-formatted-citation-line (&rest args)
  "Guess language and maybe force date formats to Swedish, else English"
  (let* ((sv (eq 'sv (guess-language-buffer)))
         (system-time-locale (if sv "sv_SE.UTF-8" "C"))
         (message-citation-line-format
          (if sv
              ;; (format "________________________________________
              ;; Från: %s
              ;; Date: %%A %%Y-%%m-%%d
              ;; Ref: %s
              ;; ID: %s
              ;; Chars: %s
              ;; lines: %s
              ;; xref: %s
              ;; extra: %s
              ;; Skickat: den 4 februari 2022 16:20
              ;; To: akgrp1@lists.chalmers.se; AK ordf; Fakultetsrådet; gru-ledningsgrupp@lists.chalmers.se; Stödet HR-ledningsgrupp; Rek.enhet; Stödet HR-partner; chalmersledningsgrupp@lists.chalmers.se; Peter Hellqvist; Jean-Marc Orliaguet; Johan Persson
              ;; Kopia: Lennart Josefson; Yvonne Jonsson; Stefan Bengtsson; Wictoria Mellgren
              ;; Ämne: [fakultetsradet] Beslut om revidering av Chalmers arbetsordning för undervisande och forskande personal (C 2021-0613)"
              ;;                       (mail-header-from message-reply-headers)
              ;;                       ;; (mail-header-date message-reply-headers)
              ;;                       (mail-header-references message-reply-headers)
              ;;                       (mail-header-id message-reply-headers)
              ;;                       (mail-header-chars message-reply-headers)
              ;;                       (mail-header-lines message-reply-headers)
              ;;                       (mail-header-xref message-reply-headers)
              ;;                       (mail-header-extra message-reply-headers)
              ;;                       ())


              "\n\n%-e %B %Y %R, skrev %f:\n"
            message-citation-line-format)))
    (apply #'message-insert-formatted-citation-line args)
    ))
#+end_src

*** Attachments
**** Put attachments at end of buffer
From: http://mbork.pl/2015-11-28_Fixing_mml-attach-file_using_advice
#+begin_src emacs-lisp
(defun aj/mml-attach-file--go-to-eob (orig-fun &rest args)
  "Go to the end of buffer before attaching files."
  (save-excursion
    (save-restriction
      (widen)
      (goto-char (point-max))
      (search-backward-regexp message-signature-separator (- (point) 500) t) ;; 500 chars reasonable limit for signature
      (apply orig-fun args))))

(advice-add 'mml-attach-file :around #'aj/mml-attach-file--go-to-eob)
#+end_src

**** Use custom command to invert prefix argument logic of ~mml-attach-file~
#+begin_src emacs-lisp
(defun aj/mml-attach-file (arg)
  (interactive "P")
  (let ((current-prefix-arg (not arg)))
    (call-interactively #'mml-attach-file)))

(bind-key "C-c C-a" 'aj/mml-attach-file mu4e-compose-mode-map)
#+end_src

**** KOLLA Attach with dired
#+begin_src emacs-lisp
(with-eval-after-load "dired"
  (require 'gnus-dired)
  ;; make the `gnus-dired-mail-buffers' function also work on
  ;; message-mode derived modes, such as mu4e-compose-mode
  (defun aj/gnus-dired-mail-buffers ()
    "Return a list of active message buffers."
    (let (buffers)
      (save-current-buffer
        (dolist (buffer (buffer-list t))
          (set-buffer buffer)
          (when (and (derived-mode-p 'message-mode)
                     (null message-sent-message-via))
            (push (buffer-name buffer) buffers))))
      (nreverse buffers)))
  (advice-add 'gnus-dired-mail-buffers :override #'aj/gnus-dired-mail-buffers)

  (setq gnus-dired-mail-mode 'mu4e-user-agent)
  (add-hook 'dired-mode-hook 'turn-on-gnus-dired-mode))
#+end_src

**** Attach via dropbox-link :ARCHIVE:
#+begin_src emacs-lisp
(defun aj/copy-to-dropbox-return-link (file)
  "Copies a file to public dropbox folder and returns public url"
  (let ((newfile (expand-file-name (file-name-nondirectory file) "~/Dropbox/delning-publikt")))
    (copy-file file newfile 1)
    (aj/dropbox-get-link newfile)))

(defun aj/dropbox-get-link (filename)
  "Puts dropbox public link to FILENAME in kill ring.

Non-interactive use returns link"
  (interactive "f")
  (let ((link (replace-regexp-in-string
               "dl=0" "dl=1"
               (shell-command-to-string
                (format "dropbox-cli sharelink %s" (shell-quote-argument filename))))))
    (if (called-interactively-p)
        (kill-new link)
      link)))

(defun aj/mml-attach-file-dropbox-link ()
  "Attach file by inserting dropbox link."
  (interactive)
  (let ((file (mml-minibuffer-read-file "Dropbox link file: ")))
    (insert (aj/copy-to-dropbox-return-link file))))
#+end_src

**** Add a recipient filename to attachment at point
#+begin_src emacs-lisp
(defun aj/mml-add-attachment-recipient-filename ()
  "Add a recipient filename to attachment at point"
  (interactive)
  (save-excursion
    (goto-char (point-at-bol))
    (when (and (looking-at-p "<#part")
               (search-forward-regexp "filename=\"\\([^\"]+\\)\"" (point-at-eol) t))
      (goto-char (match-beginning 0))
      (when-let ((filename (read-string
                            "Recipient filename: "
                            (file-name-nondirectory
                             (substring-no-properties
                              (match-string 1))))))
        (insert (format "recipient-filename=\"%s\" " filename))))))
#+end_src

**** Warning when forgetting to include attachments
Adapted from https://www.topbug.net/blog/2016/12/09/attachment-reminder-in-emacs-message-mode/,
http://disq.us/p/158wrxo, and http://mbork.pl/2016-02-06_An_attachment_reminder_in_mu4e

#+begin_src emacs-lisp
(defcustom aj/message-attachment-intent-re
  (regexp-opt '("attached"
		        "attachment"
                "pdf"
                "bifogad"
                "bifogar"
                "bilaga"))
  "A regex which - if found in the message, and if there is no
attachment - should launch the no-attachment warning.")

(defun aj/message-says-attachment-p ()
  "Return t if the message suggests there can be an attachment."
  (save-excursion
    (mail-text)
    (save-match-data
      (let (search-result)
        (while
            (and (setq search-result
                       (re-search-forward
                        aj/message-attachment-intent-re nil t))
                 ;; old mu4e-cited-regexp
                 (org-match-line "^\\(\\([[:alpha:]]+\\)\\|\\( *\\)\\)\\(\\(>+ ?\\)+\\)")))
        search-result))))

(defun aj/message-has-attachment-p ()
  "Return t if the message has an attachment."
  (save-excursion
    (mail-text)
    (save-match-data
      (search-forward "<#part" nil t))))

(defun aj/message-pre-send-check-attachment ()
  (when (and (aj/message-says-attachment-p)
             (not (aj/message-has-attachment-p)))
    (unless
        (y-or-n-p "Är du säker på att du inte glömde en bilaga?!")
      (keyboard-quit))))

(add-hook 'message-send-hook 'aj/message-pre-send-check-attachment -50)

#+end_src

**** Detach attachments :ARCHIVE:
#+begin_src emacs-lisp
;;TODO, fixa! (kolla på mm- funktionerna (mime-biblioteket))
;; (defun aj/mu4e-remove-attachment (msg num)
;;   "Remove attachment."
;;   (let* ((attach (mu4e~view-get-attach msg num))
;;           (path (mu4e-msg-field msg :path))
;;           (filename (and attach (plist-get attach :name)))
;;           (cmd (format "remove-mime-attachment --filename=\"%s\" < \"%s\" > \"%s\".lock && mv \"%s\".lock \"%s\""
;;                        filename path path path path path path))
;;           ;; (cmd (format "altermime --input=%s --remove='%s'"  path filename))
;;           )
;;     (when (and filename
;;             (yes-or-no-p
;;          (format "Are you sure you want to remove '%s'?" filename)))
;;       (shell-command cmd "*SHELL_REMOVE_CMD*")
;;       (message cmd))))

;; (add-to-list 'mu4e-view-attachment-actions
;;   '("remove-attachment" . aj/mu4e-remove-attachment))

(defun aj/mu4e-detach-attachments (&optional msg)
  "Detach all files"
  (interactive)
  (let* ((msg (or msg (mu4e-message-at-point)))
         (count (hash-table-count mu4e~view-attach-map))
         (attachnums (mu4e-split-ranges-to-numbers "a" count))
         (attachdir "/home/aj/Hämtningar/mejl-extrakt/")
         ;; (bodytext (or (mu4e-message-field msg :body-txt)
         ;;               (mu4e-message-field msg :body-html)))
         ;; (textpart (cl-find-if
         ;;            (lambda (part)
         ;;              (and (not (mu4e-message-part-field part :attachment))
         ;;                   (member
         ;;                    (mu4e-message-part-field part :mime-type)
         ;;                    '("text/plain" "text/html"))))
         ;;              (mu4e-message-field msg :parts)))
         )
    (dolist (num attachnums)
      (let* ((att (mu4e~view-get-attach msg num))
             (fname  (plist-get att :name))
             (index (plist-get att :index))
             (retry t)
             fpath)
        (while retry
          (setq fpath (concat attachdir fname))
          (setq retry
                (and (file-exists-p fpath)
                     (not (y-or-n-p
                           (mu4e-format "Overwrite '%s'?" fpath))))))
        (mu4e~proc-extract
         'save (mu4e-message-field msg :docid)
         index mu4e-decryption-policy fpath)))))
#+end_src


*** Mail templates :ARCHIVE:
#+begin_src emacs-lisp
(defcustom aj/mu4e-templates-dir "~/.emacs.d/mu4e-templates"
  "Directory for mail templates"
  :type 'directory
  :group 'aj)

(defun aj/weekly-report-mail ()
  ""
  (interactive)
  (mu4e~compose-handler 'new)
  (delete-region (point-min) (point-max))
  (insert (format (aj/read-string-from-file
                   (expand-file-name "weekly-report.eml"  aj/mu4e-templates-dir))
                  (aj/weekly-report-copy-link))))
#+end_src

** Headers settings
*** Thread folding
Introduced in May 2023. For some stupid reason both ~tab~ and ~C-tab~ is bound to ~mu4e-thread-fold-toggle-goto-next~ in the mode-map. (And I use ~C-tab~ for switching windows).
#+begin_src emacs-lisp
(keymap-set mu4e-thread-mode-map "C-<tab>" nil)
#+end_src
*** Always show the headings buffer when launching with search or bookmarks
Disregard and remove any other windows where it is shown.

#+begin_src emacs-lisp
;; I don’t use the main view:
;; with the redefinition below (pop-up-frame) this will bury header
;; buffer and delete that frame, which is what I want.
(define-key mu4e-headers-mode-map [remap mu4e~headers-quit-buffer] #'quit-window)

;; POSSIBLE NEW SOLUTION?
;; (add-to-list 'display-buffer-alist
;;              '(("\\*mu4e-headers\\*" (display-buffer-full-frame display-buffer-pop-up-frame))))


;; OLD SOLUTION
;; (defvar aj/mu4e-headers-auto-updating nil)
;; (defun aj/mu4e-headers-set-auto-updating (&optional _ignore)
;;   (setq aj/mu4e-headers-auto-updating t))

;; (advice-add 'mu4e~headers-maybe-auto-update :before
;;             #'aj/mu4e-headers-set-auto-updating)


;; (el-patch-defun mu4e--search-execute (expr ignore-history)
;;   "Search for query EXPR.

;; Switch to the output buffer for the results. If IGNORE-HISTORY is
;; true, do *not* update the query history stack."
;;   (let* ((buf (mu4e-get-headers-buffer nil t))
;;          (view-window mu4e~headers-view-win)
;;          (inhibit-read-only t)
;;          (rewritten-expr (funcall mu4e-query-rewrite-function expr))
;;          (maxnum (unless mu4e-search-full mu4e-search-results-limit)))
;;     (with-current-buffer buf
;;       ;; NOTE: this resets all buffer-local variables, including
;;       ;; `mu4e~headers-view-win', which may have a live window if the
;;       ;; headers buffer already exists when `mu4e-get-headers-buffer'
;;       ;; is called.
;;       (mu4e-headers-mode)
;;       (setq mu4e~headers-view-win view-window)
;;       (unless ignore-history
;;         ;; save the old present query to the history list
;;         (when mu4e--search-last-query
;;           (mu4e--search-push-query mu4e--search-last-query 'past)))
;;       (setq mu4e--search-last-query rewritten-expr)
;;       (setq list-buffers-directory rewritten-expr)
;;       (mu4e~headers-update-mode-line))

;;     (el-patch-swap
;;       ;; when the buffer is already visible, select it; otherwise,
;;       ;; switch to it.
;;       (unless (get-buffer-window buf 0)
;;         (switch-to-buffer buf))

;;       ;; if not auto-updating, and not viewing in current frame: Pop up
;;       ;; a frame.
;;       (progn
;;         (unless aj/mu4e-headers-auto-updating
;;           (unless (get-buffer-window mu4e-headers-buffer-name) ;; do stuff if not in the current frame
;;             (let (win)
;;               (while (setq win (get-buffer-window mu4e-headers-buffer-name t))
;;                 ;; delete that full frame, or only the window
;;                 (if (window-parent win)
;;                     (delete-window win)
;;                   (delete-frame (window-frame win)))))
;;             ;; pop up a new frame!
;;             ;;(make-frame '((full-screen . t)))
;;             ;; but fullscreen doesn’t work on pgtk
;;             (display-buffer mu4e-headers-buffer-name
;;                             '(display-buffer-pop-up-frame))))
;;         (setq aj/mu4e-headers-auto-updating nil)))

;;     (run-hook-with-args 'mu4e-search-hook expr)
;;     (mu4e~headers-clear mu4e~search-message)
;;     (setq mu4e~headers-search-start (float-time))
;;     (mu4e--server-find
;;      rewritten-expr
;;      mu4e-search-threads
;;      mu4e-search-sort-field
;;      mu4e-search-sort-direction
;;      maxnum
;;      mu4e-search-skip-duplicates
;;      mu4e-search-include-related)))

;; (defun aj/mu4e-search-show-buffer (&rest _ignore)
;;   (unwind-protect
;;       (unless aj/mu4e-headers-auto-updating
;;         (unless (get-buffer-window mu4e-headers-buffer-name) ;; do stuff if not in the current frame
;;           (let (win)
;;             (while (setq win (get-buffer-window mu4e-headers-buffer-name t))
;;               ;; delete that full frame, or only the window
;;               (if (window-parent win)
;;                   (delete-window win)
;;                 (delete-frame (window-frame win)))))
;;           ;; pop up a new frame!
;;           ;;(make-frame '((full-screen . t)))
;;           ;; but fullscreen doesn’t work on pgtk
;;           (display-buffer-pop-up-frame mu4e-headers-buffer-name nil)))
;;     (setq aj/mu4e-headers-auto-updating nil)))
    #+end_src

*** Variable pitch in mu4e-headers-mode
#+begin_src emacs-lisp
(setq mu4e-headers-precise-alignment t)
(add-hook 'mu4e-headers-mode-hook #'variable-pitch-mode)

(defun aj/mu4e-header-line-format ()
  "Empty header line"
  "")

(advice-add 'mu4e~header-line-format :override #'aj/mu4e-header-line-format)

(add-hook 'mu4e-headers-mode-hook #'aj/mu4e-remap-header-line-face)

(defun aj/mu4e-remap-header-line-face ()
  (face-remap-add-relative 'header-line
                           :foreground 'unspecified
                           :background 'unspecified
                           :inherit 'fringe
                           :height 0.5))


;; (defun aj/mu4e~header-line-format ()
;;   "Get the format for the header line."
;;   (let ((uparrow   (if mu4e-use-fancy-chars " ▲" " ^"))
;;         (downarrow (if mu4e-use-fancy-chars " ▼" " V")))
;;     (cons
;;      (propertize " " 'display '(space :align-to 0))
;;      ;; (make-string
;;      ;;  (+ mu4e~mark-fringe-len (floor (fringe-columns 'left t))) ?\s)
;;      (mapcar
;;       (lambda (item)
;;         (let* ((field (car item)) (width (cdr item))
;;                (info (cdr (assoc field
;;                                  (append mu4e-header-info mu4e-header-info-custom))))
;;                (require-full (plist-get info :require-full))
;;                (sortable (plist-get info :sortable))
;;                ;; if sortable, it is either t (when field is sortable itself)
;;                ;; or a symbol (if another field is used for sorting)
;;                (sortfield (when sortable (if (booleanp sortable) field sortable)))
;;                (help (plist-get info :help))
;;                ;; triangle to mark the sorted-by column
;;                (arrow
;;                 (when (and sortable (eq sortfield mu4e-headers-sort-field))
;;                   (if (eq mu4e-headers-sort-direction 'descending) downarrow uparrow)))
;;                (name (concat (plist-get info :shortname) arrow))
;;                (map (make-sparse-keymap)))
;;           (when require-full
;;             (mu4e-error "Field %S is not supported in mu4e-headers-mode" field))
;;           (when sortable
;;             (define-key map [header-line mouse-1]
;;               (lambda (&optional e)
;;                 ;; getting the field, inspired by `tabulated-list-col-sort'
;;                 (interactive "e")
;;                 (let* ((obj (posn-object (event-start e)))
;;                        (field
;;                         (and obj (get-text-property 0 'field (car obj)))))
;;                   ;; "t": if we're already sorted by field, the sort-order is
;;                   ;; changed
;;                   (mu4e-headers-change-sorting field t)))))
;;           (concat
;;            (propertize
;;             (if width
;;                 (mu4e~headers-truncate-field field name (- width 1))
;;               name)
;;             'face (if arrow '(:inherit (variable-pitch bold)) 'variable-pitch)
;;             'help-echo help
;;             'mouse-face (when sortable 'highlight)
;;             'keymap (when sortable map)
;;             'field field) " ")))
;;       mu4e-headers-fields))))
#+end_src

*** Fix for mark targets when using ~mu4e-headers-precise-alignment~
#+begin_src emacs-lisp
(el-patch-feature mu4e-mark)
(with-eval-after-load 'mu4e-mark
  (el-patch-defun mu4e-mark-at-point (mark target)
    "Mark (or unmark) message at point.
MARK specifies the mark-type. For `move'-marks and `trash'-marks
the TARGET argument is non-nil and specifies to which maildir the
message is to be moved/trashed. The function works in both
headers buffers and message buffers.

The following marks are available, and the corresponding props:

   MARK       TARGET    description
   ----------------------------------------------------------
   `refile'    y        mark this message for archiving
   `something' n        mark this message for *something* (decided later)
   `delete'    n        remove the message
   `flag'      n        mark this message for flagging
   `move'      y        move the message to some folder
   `read'      n        mark the message as read
   `trash'     y        trash the message to some folder
   `unflag'    n        mark this message for unflagging
   `untrash'   n        remove the `trashed' flag from a message
   `unmark'    n        unmark this message
   `unread'    n        mark the message as unread
   `action'    y        mark the message for some action."
    (interactive)
    (let* ((msg (mu4e-message-at-point))
           (docid (mu4e-message-field msg :docid))
           ;; get a cell with the mark char and the "move" already has a target
           ;; (the target folder) the other ones get a pseudo "target", as info
           ;; for the user.
           (markdesc (cdr (or (assq mark mu4e-marks)
                              (mu4e-error "Invalid mark %S" mark))))
           (get-markkar
            (lambda (char)
              (if (listp char)
                  (if mu4e-use-fancy-chars (cdr char) (car char))
                char)))
           (markkar (funcall get-markkar (plist-get markdesc :char)))
           (target (mu4e--mark-get-dyn-target mark target))
           (show-fct (plist-get markdesc :show-target))
           (shown-target (if show-fct
                             (funcall show-fct target)
                           (if target (format "%S" target)))))
      (unless docid (mu4e-warn "No message on this line"))
      (unless (eq major-mode 'mu4e-headers-mode)
        (mu4e-error "Not in headers-mode"))
      (save-excursion
        (when (mu4e~headers-mark docid markkar)
          ;; update the hash -- remove everything current, and if add the new
          ;; stuff, unless we're unmarking
          (remhash docid mu4e--mark-map)
          ;; remove possible mark overlays
          (remove-overlays (line-beginning-position) (line-end-position)
			               'mu4e-mark t)
          ;; now, let's set a mark (unless we were unmarking)
          (unless (eql mark 'unmark)
            (puthash docid (cons mark target) mu4e--mark-map)
            ;; when we have a target (ie., when moving), show the target folder in
            ;; an overlay
            (when (and shown-target mu4e-headers-show-target)
              (let* ((targetstr (propertize (concat "-> " shown-target " ")
                                            'face 'mu4e-system-face))
                     ;; mu4e~headers-goto-docid docid t \will take us just after
                     ;; the docid cookie and then we skip the mu4e--mark-fringe
                     (start (+ (length mu4e--mark-fringe)
                               (mu4e~headers-goto-docid docid t)))
                     (overlay (make-overlay
                               start
                               (el-patch-swap
                                 (+ start (length targetstr))
                                 (let ((eol (line-end-position)))
                                   (or (and mu4e-headers-precise-alignment
                                            (let ((end-col (cl-loop for (f . w)
                                                                    in mu4e-headers-fields
                                                                    while (numberp w)
                                                                    sum w)))
                                              (save-excursion
                                                (when-let ((match
                                                            (text-property-search-forward
                                                             'display
                                                             `(space :align-to ,end-col)
                                                             t))
                                                           (beg (prop-match-beginning match)))
                                                  (when (< beg eol)
                                                    beg)))))
                                       (min (line-end-position)
                                            (+ start (length targetstr)))))))))
                (overlay-put overlay 'display targetstr)
                (overlay-put overlay 'mu4e-mark t)
                (overlay-put overlay 'evaporate t)
                docid))))))))


#+end_src
*** Set face of subject field to variable-pitch :ARCHIVE:
#+begin_src emacs-lisp
(defun aj/mu4e-headers-field-set-subject-face (msg field)
  "Set face of VAL to variable-pitch if FIELD is :subject."
  (when (member field '(:thread-subject :subject))
    '(:inherit variable-pitch)))

(setq mu4e-headers-field-properties-function
      #'aj/mu4e-headers-field-set-subject-face)
#+end_src

*** Small stupid fix for first space in headers headline :ARCHIVE:
#+begin_src emacs-lisp
(advice-add 'mu4e~header-line-format :around #'aj/mu4e-fix-header-space)

(defun aj/mu4e-fix-header-space (fn &rest r)
  (let ((mu4e~mark-fringe-len 3))
    (apply fn r)))
#+end_src

*** Headers fields
**** Set headers fields to view depending on what maildir is viewed
#+begin_src emacs-lisp
(setq aj/mu4e-headers-fields
      '(:gmail
        (;;(:empty . 2)
         (:aj-human-date . 12)
         (:flags . 6)
         (:from-or-to . 22)
         (:gmailtags . 5)
         ;; (:othermaildir . 10)
         ;; (:mailing-list . 7)
         ;; (:thread-subject)
         )
        :chalmers
        (;;(:empty . 3)
         (:aj-human-date . 12)
         (:flags . 6)
         (:from-or-to . 22)
         (:ajtags . 3)
         (:othermaildir . 12)
         (:ajlists . 8)
         ;; (:thread-subject)
         )
        nil
        (;;(:empty . 2)
         (:aj-human-date . 12)
         (:flags . 6)
         (:from-or-to . 22)
         ;; (:ajtags . 3)
         (:gmailtags . 5)
         (:othermaildir . 12)
         (:mailing-list . 7)
         ;; (:thread-subject)
         )))

(autoload 's-match-strings-all "s")
(autoload '--all? "dash")
(defun aj/mu4e-set-headers-fields (query)
  "Set ‘mu4e-headers-fields’ depending on which maildir is viewed."
  (when (buffer-live-p (mu4e-get-headers-buffer))
    (with-current-buffer (mu4e-get-headers-buffer)
      (let* ((mdm
              (s-match-strings-all
               "maildir:\\(?2:\\\"\\(?1:[^\\\"]+\\)\\\"\\|\\(?1:[^[:space:]]+\\)\\)"
               query))
             (maildirs (mapcar #'cadr mdm))
             (headers-fields
              (plist-get
               aj/mu4e-headers-fields
               ;; select based on what maildirs are shown.
               (when maildirs
                 (cond
                  ((--all? (string-match-p "^/chalmers" it) maildirs)
                   :chalmers)
                  ((--all? (string-match-p "^/\\(mejla\\|ajf\\)" it) maildirs)
                   :gmail)))))
             (headers-fields
              ;; If only a single maildir, no need for :othermaildir, remove it
              (if (and (= 1 (length maildirs))
                       (let ((md (car maildirs)))
                         (not (or (string-suffix-p "/" md)
                                  (string-suffix-p "*" md)))))
                  (assq-delete-all :othermaildir headers-fields)
                headers-fields)))

        ;; kolla https://github.com/djcb/mu/issues/2341
        (setq mu4e-headers-fields
              (append headers-fields
                      `((,(if mu4e-search-threads
                              :thread-subject
                            :subject))))

              ;; no need now that I don’t display it.
              ;; header-line-format (mu4e~header-line-format)
              )))))


(add-hook 'mu4e-headers-search-hook #'aj/mu4e-set-headers-fields)
;;(remove-hook 'mu4e-headers-search-hook #'aj/mu4e-set-headers-fields)

(setq mu4e-headers-fields (plist-get aj/mu4e-headers-fields nil)
      ;; mu4e-headers-from-or-to-prefix '("" . "⯈")
      mu4e-headers-include-related nil
      mu4e-headers-visible-columns nil)

#+end_src

**** My custom headers fields
#+begin_src emacs-lisp
(add-to-list 'mu4e-header-info-custom
             '(:gmailtags .
                          (:name "Labels"
                                 :shortname "GL"
                                 :help "Gmail labels"
                                 :function aj/mu4e-gmail-labels-display)))

(defvar aj/mu4e-gmail-labels
  '(("\\Inbox" (color . "#076678") (symbol . "↓"))
    ("\\Sent" (color . "#665c54") (symbol . "↑"))
    ("\\Important" (color . "#b57614") (symbol . "❧"))
    ("\\Draft" (color . "#665c54") (symbol . "□"))))

(defun aj/mu4e-gmail-labels-display (msg)
  (let ((tags (mu4e-message-field msg :tags)))
    (cl-loop for (label . props) in aj/mu4e-gmail-labels
             concat
             (if (member label tags)
                 (let ((symb (alist-get 'symbol found tag))
                       (color (alist-get 'color found)))
                   (if color
                       (propertize symb 'face (list :foreground color))
                     symb))
               " "))))

(add-to-list 'mu4e-header-info-custom
             '(:othermaildir . (:name "Maildir"
                                      :shortname "M"
                                      :help "Maildir"
                                      :function aj/mu4e-other-maildir)))

(autoload 's-chop-prefix "s")
(autoload 's-shared-start "s")
(autoload 's-replace-all "s")
(defun aj/mu4e-other-maildir (msg)
  "Returns a possibly shortened indication of MSGs maildir
Returns the empty string if this is the \"current\" maildir."
  (let ((mmd (mu4e-message-field msg :maildir))
        (lq (mu4e-last-query)))
    (if (string-match  "maildir:\\\"\\(.+\\)\\\"" lq)
        (let ((smd (match-string 1 lq)))
          (if (string= smd mmd)
              ""
            (s-chop-prefix (s-shared-start mmd smd) mmd)))
      ;; only first letter of base maildir, in bold:
      (setq mmd (replace-regexp-in-string
                 "^/[^/]+"
                 (lambda (s) (propertize (substring s 1 2) 'face 'bold))
                 mmd 'fixed 'literal))
      (s-replace-all aj/mu4e-maildir-icons mmd)
      ;; (cl-loop for (find . rep) in aj/mu4e-maildir-icons do
      ;;          (setq mmd (replace-regexp-in-string find rep mmd 'fixed 'literal t t)))
      )))

(defvar aj/mu4e-maildir-icons
  `(("/Archive/undervisning" . "//u")
    ("/Archive/yearly/" . "/ ")
    ("/Archive/listor" . "//")
    ("/Archive" . "/")
    ("/Deleted Items" . "/")
    ("/Sent Items" . ,(concat "/" (all-the-icons-material "send")))
    ("/INBOX" . "/")
    )
  )

(add-to-list 'mu4e-header-info-custom
             '(:aj-human-date .
                              (:name "Date"
                                     :shortname "Date"
                                     :help "Date/time when the message was written."
                                     :function aj/mu4e~headers-human-date)))

(defsubst aj/mu4e~headers-human-date (msg)
  "Show a 'human' date.
If the date is today, yesterday or, show the time, otherwise, show the
date. The formats used for date and time are
`mu4e-headers-date-format' and `mu4e-headers-time-format'."
  (let ((date (mu4e-msg-field msg :date)))
    (propertize
     (if (equal date '(0 0 0))
         "None"
       (let* ((days1 (time-to-days date))
              (days2 (time-to-days (current-time))))
         (cond
          ((eq days1 days2)
           (format-time-string "     %H:%M" date))
          ((eq days1 (1- days2)) ;;yesterday
           (format-time-string "igår %H:%M" date))
          ((< (- days2 days1) 5)
           (format-time-string "%a  %H:%M" date))
          (t (format-time-string "%x" date)))))
     'face 'fixed-pitch)))
#+end_src

**** Custom header, tags
#+begin_src emacs-lisp
(add-to-list 'mu4e-header-info-custom
             '(:ajtags .
                       (:name "Tags"
                              :shortname "🏷"
                              :help "Tags"
                              :function aj/mu4e-header-tags)))

(defun aj/mu4e-header-tags (msg)
  (let ((tags (sort (mu4e-message-field msg :tags) 'string<)))
    (cl-loop with found
             for tag in tags
             if (setq found (assoc tag aj/mail-tags))
             concat
             (let ((symb (alist-get 'symbol found tag))
                   (color (alist-get 'color found)))
               (if color
                   (propertize symb 'face (list :foreground color))
                 symb)))))
#+end_src

**** COMMENT Custom flags including calendar :ARCHIVE:
#+begin_src emacs-lisp
(add-to-list 'mu4e-header-info-custom
             '(:ajflags .
                        (:name "Flags"
                               :shortname "Flags"
                               :help "Flags"
                               :function aj/mu4e-headers-flags)))

(defun aj/mu4e-headers-flags (msg)
  (let* ((flags (mu4e-message-field msg :flags))
         (flags-str (mu4e~headers-flags-str flags))
         (cal (cl-loop for part in (mu4e-message-field msg :parts)
                       if (equal (plist-get part :mime-type) "text/calendar")
                       return "📅")))
    (propertize (concat flags-str cal)
                'help-echo (format "%S" flags)))))
#+end_src

**** Custom field for lists
#+begin_src emacs-lisp
(add-to-list 'mu4e-header-info-custom
             '(:ajlists .
                        (:name "List"
                               :shortname "List"
                               :help "List"
                               :function aj/mu4e-headers-list)))

(defcustom aj/mu4e-mailing-lists nil
  "Alist with shortnames of mailing lists based on list address.
Like ‘mu4e-user-mailing-lists’."
  :group 'aj
  :type '(alist :key-type string :value-type string))

(defun aj/mu4e-headers-list (msg)
  "Show a mailing list"
  (if-let ((list (mu4e-msg-field msg :mailing-list)))
      (mu4e~headers-mailing-list list)
    (string-join
     (cl-loop for (list . short) in aj/mu4e-mailing-lists
              when (mu4e-message-contact-field-matches
                    msg '(:to :from :cc :bcc) list)
              collect short)
     ", ")))
#+end_src

*** Load next 500 messages
#+begin_src emacs-lisp
(defvar aj/mu4e-page 1
  "Current page in mu4e search")

(defun aj/mu4e-reset-page (&rest _r)
  (setq aj/mu4e-page 1))

;; We need to reset it for the "standard searches", but also when
;; invoking an interactive search
(add-hook 'mu4e-search-bookmark-hook #'aj/mu4e-reset-page)
(advice-add 'mu4e-search-maildir :before #'aj/mu4e-reset-page)

(defun aj/mu4e-next-messages-for-query ()
  "Fetch the next number of messages for current mu4e query.
Move to last message in current view so that newly fetched
messages are visible."
  (interactive)
  (when (and (mu4e-current-buffer-type-p 'headers)
             (not mu4e-headers-full-search))
    (when-let ((query (mu4e-last-query)))
      (cl-incf aj/mu4e-page)
      (let ((mu4e-search-results-limit
             (* aj/mu4e-page mu4e-search-results-limit))
            (last-msg (save-excursion
                        (goto-char (point-max))
                        (forward-line -1)
                        (plist-get
                         (mu4e-message-at-point)
                         :message-id))))
        (mu4e-search query nil nil t last-msg)
        ;; (mu4e-mark-handle-when-leaving)
        ;;(mu4e~headers-search-execute expr ignore-history)
        ;; (run-hook-with-args 'mu4e-headers-search-hook expr)
        ))))

(keymap-set mu4e-headers-mode-map "N" #'aj/mu4e-next-messages-for-query)

#+end_src


** Dynamic folders for refile etc. + special functions for gmail-relabeling
One could think that it would be reasonable to put this in the contexts, but no, these settings are mostly per message, and is therefore better dynamically matched on the current message.

The most complex part is for choosing refile folders, depending on account and special functions in ~aj/mu4e-refile-fns~.
#+begin_src emacs-lisp
;; Utility function
;; In its current form kind of repetitive. But I could want special
;; conditions, so I will not abstract it more now.

(cl-defmacro aj/mu4e-msg-account (msg &key chalmers mejla ajf default gmail)
  (declare (indent 1))
  `(cond
    ((and ,msg ,chalmers (string-match-p "^/chalmers/" (mu4e-message-field ,msg :maildir)))
     ,chalmers)
    ((and ,msg ,mejla (string-match-p "^/mejla/" (mu4e-message-field ,msg :maildir)))
     ,mejla)
    ((and ,msg ,ajf (string-match-p "^/ajf/" (mu4e-message-field ,msg :maildir)))
     ,ajf)
    ((and ,msg ,gmail (or
                       (string-match-p "^/mejla/" (mu4e-message-field ,msg :maildir))
                       (string-match-p "^/ajf/" (mu4e-message-field ,msg :maildir))))
     ,gmail)
    (t ,default)))

(setq mu4e-sent-folder "/chalmers/Sent Items" ; gmail is set to delete sent mails
                                        ; (because it recreates them on the
                                        ; server from the mails sent via its
                                        ; smtp server.)
      mu4e-drafts-folder "/UTKAST" ; Don’t care about syncing these
                                        ; to the server
      mu4e-trash-folder (lambda (msg)
                          (aj/mu4e-msg-account msg
                            :chalmers "/chalmers/Deleted Items"
                            :mejla "/mejla/Papperskorgen"
                            :ajf "/ajf/Papperskorgen"))
      mu4e-refile-folder #'aj/mu4e-refile-folder)


(defvar aj/mu4e-refile-sender-hash (make-hash-table :test 'equal)) ;; (added to ‘savehist-additional-variables’)

(defun aj/mu4e-refile-guess-by-sender (msg)
  (cl-loop with current-max = 0
           with current-mf = nil
           for (folder . count) in
           (gethash (cdar (mu4e-msg-field msg :from))
                    aj/mu4e-refile-sender-hash)
           if (< current-max count) do
           (setq current-mf folder
                 current-max count)
           finally return
           ;; Change this to:
           ;; no suggestions + extra choice for refiling. Refiling
           ;; should guess or fall back to default archive. Otherwise
           ;; the user can do a move. More expected to get interaction
           ;; for move vs refile.
           current-mf
           ;; (when current-mf
           ;;   (if ;; Treat it as a fact if very common, or
           ;;       ;; if matching matches the default folder.
           ;;       (or (< 3 current-max)
           ;;           (equal current-mf (aj/mu4e-default-refile-folder msg)))
           ;;       current-mf
           ;;     ;; else, as a suggestion
           ;;     (list current-mf)))
           ))

(defun aj/mu4e-refile-store-history (from folder)
  "Store FOLDER in history for sender FROM."
  (cl-incf (alist-get
            folder
            (gethash from aj/mu4e-refile-sender-hash '())
            0 nil #'equal)))

(defun aj/mu4e-refile-store-history-msg (msg folder)
  "Stores history for sender in MSG and returns FOLDER."
  (when-let ((from (mu4e-msg-field msg :from)))
    (aj/mu4e-refile-store-history (mu4e-contact-email (car from)) folder))
  folder)

(defun aj/mu4e-refile-store-history-after-move (folder)
  "Stores history for sender in msg at point and returns FOLDER."
  (when-let (from (mu4e-field-at-point :from))
    (aj/mu4e-refile-store-history (mu4e-contact-email (car from)) folder))
  folder)

(advice-add 'mu4e--mark-get-move-target :filter-return #'aj/mu4e-refile-store-history-after-move)

(add-to-list 'aj/mu4e-refile-fns #'aj/mu4e-refile-guess-by-sender t)

(defun aj/mu4e-refile-folder (msg)
  "Choose a refile folder for MSG.
Choose depending on account functions in ‘aj/mu4e-refile-fns’ or
fallback to default refile folder."
  (let ((dir (run-hook-with-args-until-success 'aj/mu4e-refile-fns msg)))
    (cond
     ((stringp dir)
      dir)
     ((consp dir)
      (aj/mu4e-refile-store-history-msg msg (aj/mu4e-choose-refile (car dir) msg)))
     (t
      (aj/mu4e-default-refile-folder msg)))))

;; (defun aj/mu4e-refile-folder (msg &optional force-choice)
;;   "Guess or offer to select a refile folder for MSG.
;; Chooses depending on account functions in ‘aj/mu4e-refile-fns’
;; No automatic guess if FORCE-CHOICE is non-nil."
;;   (let ((dir (run-hook-with-args-until-success 'aj/mu4e-refile-fns msg)))
;;     (cond
;;      ((stringp dir)
;;       (if force-choice
;;           (aj/mu4e-refile-store-history-msg msg (aj/mu4e-choose-refile dir msg))
;;         dir))
;;      ((consp dir)
;;       (aj/mu4e-refile-store-history-msg msg (aj/mu4e-choose-refile (car dir) msg)))
;;      (t
;;       (aj/mu4e-refile-store-history-msg msg (aj/mu4e-choose-refile nil msg))))))

;; (defun aj/mu4e-refile-folder (msg &optional force-choice)
;;   "Guess or offer to select a refile folder for MSG.
;; Chooses depending on account functions in ‘aj/mu4e-refile-fns’
;; No automatic guess if FORCE-CHOICE is non-nil."
;;   (let* ((user-has-chosen nil)
;;          (found
;;           (or (cl-loop for fn in aj/mu4e-refile-fns do
;;                        (when-let ((res (funcall fn msg)))
;;                          (cond
;;                           ((stringp res) (cl-return res))
;;                           ((listp res) (cl-return (prog1 (aj/mu4e-choose-refile (car res) msg)
;;                                                     (setq user-has-chosen t)))))))
;;               (aj/mu4e-default-refile-folder msg))))
;;     (aj/mu4e-refile-store-history-msg
;;      msg
;;      (if (and found
;;               (or user-has-chosen (not force-choice)))
;;          found
;;        (aj/mu4e-choose-refile found msg)))))

(defun aj/mu4e-default-refile-folder (msg)
  (aj/mu4e-msg-account msg
    :chalmers (concat "/chalmers/Archive/yearly/" (format-time-string "%Y" (mu4e-message-field msg :date)))
    ;; Only for show, they get changed labels via custom action
    :mejla "/mejla/Alla mail"
    :ajf "/ajf/Alla mail"))

(defun aj/mu4e-choose-refile (startdir msg)
  "Choose a refile directory for MSG, starting search from STARTDIR"
  (let* ((subject (mu4e-message-field msg :subject))
         (subject (substring subject 0 (min 18 (length subject))))
         (case-fold-search t)
         (dir (completing-read (format "Refile \"%s\": " subject)
                               (mu4e-get-maildirs)
                               nil
                               t
                               startdir
                               nil
                               (aj/mu4e-default-refile-folder msg))))
    (unless (string= " " dir)
      dir)))

;; gmail is treated with labels instead of folder moves

(add-hook 'mu4e-mark-execute-pre-hook #'aj/mu4e-gmail-mark-pre-hook)
(remove-hook 'mu4e-mark-execute-pre-hook #'aj/mu4e-gmail-mark-pre-hook)


;; For forcing gmail-refiled messages to be removed from headers listing.

(defvar aj/mu4e-treat-as-move nil)

;; (defun aj/mu4e-gmail-mark-pre-hook (mark msg)
;;   (aj/mu4e-msg-account msg
;;     :mejla (aj/mu4e-gmail-retag mark msg)
;;     :ajf (aj/mu4e-gmail-retag mark msg)))

;; (defun aj/mu4e-gmail-retag (mark msg)
;;   (cond ;; ((equal mark 'refile)
;;    ;;  (setq aj/mu4e-treat-as-move t)
;;    ;;  (mu4e-action-retag-message msg "-\\Inbox"))
;;    ;; this moves to trash directory as well:
;;    ((equal mark 'trash) (mu4e-action-retag-message msg "-\\Inbox,-\\Starred"))
;;    ;; ((equal mark 'flag) (mu4e-action-retag-message msg "\\Starred"))
;;    ;; ((equal mark 'unflag) (mu4e-action-retag-message msg "-\\Starred"))
;;    ))


(advice-add 'mu4e-mark-execute-all :before (lambda (&rest _ignore) (setq aj/mu4e-treat-as-move nil)))

(setq mu4e-update-func #'aj/mu4e-headers-update-handler)
(defun aj/mu4e-headers-update-handler (msg is-move maybe-view)
  "Wrapper around ‘mu4e~headers-update-handler’ to remove
messages “refiled” in gmail accounts from the inbox listing."
  (let ((docid (plist-get msg :docid)))
    (mu4e~headers-update-handler
     msg
     (or
      (memq docid aj/mu4e-treat-as-move)
      is-move)
     maybe-view)
    (setq aj/mu4e-treat-as-move (delq docid aj/mu4e-treat-as-move))))

(defun aj/mu4e-retag-as-move (msg tagchange)
  (push (plist-get msg :docid) aj/mu4e-treat-as-move)
  (mu4e-action-retag-message msg tagchange))

;; Redefine refile to work with gmail
(setf (cl-getf (alist-get 'refile mu4e-marks) :action)
      #'aj/mu4e-refile-action)

(defun aj/mu4e-refile-action (docid msg target)
  (funcall
   (aj/mu4e-msg-account msg
     :gmail (lambda (_docid msg _target) (aj/mu4e-retag-as-move msg "-\\Inbox"))
     :default (lambda (docid _msg target)
                (mu4e--server-move docid (mu4e--mark-check-target target) "-N+S")))
   docid msg target))

;; Redefine move to trash
(setf (cl-getf (alist-get 'trash mu4e-marks) :action)
      #'aj/mu4e-trash-action)

(defun aj/mu4e-trash-action (docid msg target)
  "Move to trash, mark as read, possibly change gmail labels"
  (when-let ((retagfn
              (aj/mu4e-msg-account msg
                :gmail (lambda (msg) (mu4e-action-retag-message msg "-\\Inbox,-\\Starred,-\\Important")))))
    (funcall retagfn msg))
  (mu4e--server-move docid (mu4e--mark-check-target target) "+T+S-N"))
#+end_src

** Marks
*** Custom marks
**** Add tag
#+begin_src emacs-lisp
(defun aj/mu4e-choose-tag ()
  (let ((tags
         (cl-loop for (tag . props) in (append aj/mail-tags aj/mu4e-gmail-labels)
                  collect
                  (cons (let ((color (alist-get 'color props))
                              (display (concat (alist-get 'symbol props " ") " " tag )))
                          (if color
                              (propertize display 'face (list :foreground color))
                            display))
                        tag)))

        (case-fold-search t))
    (completing-read "Add tag: " tags)))
(add-to-list 'mu4e-marks
             '(tag
               :char       ("g" . "🏷")
               :prompt     "tag"
               :ask-target aj/mu4e-choose-tag
               :action      (lambda (docid msg target)
                              (mu4e-action-retag-message msg (concat "+" target)))))

(mu4e~headers-defun-mark-for tag)
(bind-key "ö" #'mu4e-headers-mark-for-tag mu4e-headers-mode-map)
;; (mu4e~view-defun-mark-for tag)
;; (define-key 'mu4e-view-mode-map (kbd "C-ö") 'mu4e-headers-mark-for-tag)


#+end_src

**** Refile + mark as read :ARCHIVE:
At times, I can safely refile messages without reading them and at the same time marking them read.
#+begin_src emacs-lisp
(add-to-list 'mu4e-marks
             '(refile-read
               :char ("f" . "⧐")
               :prompt "refile"
               :dyn-target (lambda (target msg)
                             (aj/mu4e-refile-folder msg))
               :action aj/mu4e-refile-read-action))

(defun aj/mu4e-refile-read-action (docid msg target)
  (funcall
   (aj/mu4e-msg-account msg
     :gmail (lambda (docid msg target)
              (mu4e-action-retag-message msg "-\\Inbox")
              (mu4e--server-move docid (mu4e--mark-check-target target) "-N+S"))
     :default (lambda (docid _msg target)
                (mu4e--server-move
                 docid (mu4e--mark-check-target target) "-N+S")))
   docid msg target))


(mu4e~headers-defun-mark-for refile-read)
(bind-key "ä" #'mu4e-headers-mark-for-refile-read mu4e-headers-mode-map)

#+end_src


*** Mark all duplicates in current view for deletion
#+begin_src emacs-lisp
(defun aj/mu-mark-duplicates-for-deletion ()
  (interactive)
  (mu4e-headers-mark-for-each-if
   '(delete)
   #'aj/mu-message-is-duplicate))

(defun aj/mu-message-is-duplicate (msg &optional _param)
  (plist-get (mu4e-message-field msg :thread) :duplicate))

;; (defun aj/mu-find-stupid-duplicates ()
;;   (interactive)
;;   (let ((mu4e-headers-results-limit -1)
;;         (mu4e-headers-skip-duplicates nil)
;;         (mu4e-headers-found-hook '(aj/mu-mark-duplicates-for-deletion)))
;;     (mu4e-headers-search "maildir:/uu/* date:20171001..now ")))
#+end_src

*** COMMENT Directly applied marks :ARCHIVE:
Here I define my own variant of ~mu4e~headers-defun-mark-for~ which defines functions taking a prefix argument to optionally execute the mark immediately.
Some of the functions are redefined.
#+begin_src emacs-lisp
(defmacro aj/mu4e~headers-defun-mark-for (mark)
  "Define a function mu4e~headers-mark-MARK, which takes a prefix argument to execute the mark immediately."
  (let ((funcname (intern (format "mu4e-headers-mark-for-%s" mark)))
        (docstring (format "Mark header at point with %s." mark)))
    `(progn
       (defun ,funcname (arg) ,docstring
              (interactive "P")
              (if arg
                  (let* ((msg (mu4e-message-at-point))
                         (markdescr (assq ',mark mu4e-marks))
                         (docid (plist-get msg :docid))
                         (ask-target (mu4e--mark-ask-target ',mark))
                         (target (mu4e--mark-get-dyn-target ',mark ask-target)))
                    (if markdescr
                        (funcall (plist-get (cdr markdescr) :action) docid msg target)
                      (mu4e-error "Unrecognized mark %S" ',mark)))
                (mu4e-headers-mark-and-next ',mark)))
       (put ',funcname 'definition-name ',mark))))

;; (aj/mu4e~headers-defun-mark-for refile)
;; (aj/mu4e~headers-defun-mark-for something)
;; (aj/mu4e~headers-defun-mark-for delete)
(aj/mu4e~headers-defun-mark-for flag)
;;  (aj/mu4e~headers-defun-mark-for move)
(aj/mu4e~headers-defun-mark-for read)
(aj/mu4e~headers-defun-mark-for trash)
(aj/mu4e~headers-defun-mark-for unflag)
;;  (aj/mu4e~headers-defun-mark-for untrash)
(aj/mu4e~headers-defun-mark-for unread)
;;  (aj/mu4e~headers-defun-mark-for action)
#+end_src

** Make toggle functions for flagging and unread
These two actions which doesn’t move the message from the folder is good to be able to just toggle directly.
#+begin_src emacs-lisp
(defun aj/mu4e-toggle-flag ()
  (interactive)
  (let* ((msg (mu4e-message-at-point))
         (docid (plist-get msg :docid)))
    (if (member 'flagged (plist-get msg :flags))
        (mu4e--server-move docid nil "-F-u-N")
      (mu4e--server-move docid nil "+F-u-N"))))

(defun aj/mu4e-toggle-unread ()
  (interactive)
  (let* ((msg (mu4e-message-at-point))
         (docid (plist-get msg :docid)))
    (if (member 'unread (plist-get msg :flags))
        (mu4e--server-move docid nil "-u-N")
      (mu4e--server-move docid nil "+u-N"))))


(bind-keys :map mu4e-headers-mode-map
           ("+" . aj/mu4e-toggle-flag)
           ("." . aj/mu4e-toggle-unread))
#+end_src

** Actions for toggling tags :ARCHIVE:
#+begin_src emacs-lisp
(defvar aj/mu4e-tagchange-history nil)
(defun aj/mu4e-change-tags ()
  "Add or remove tags for current message"
  (interactive)
  (let ((msg (mu4e-message-at-point)))
    (when msg
      (mu4e-action-retag-message
       msg
       (read-from-minibuffer "Add or remove tags: "
                             nil nil nil 'aj/mu4e-tagchange-history)))))

;; Tag-toggle commands
(defun aj/mu4e-defun-toggle-tags (taglist)
  "Defines and binds functions for toggling up to ten tags in mu4e-headers"
  ;;(let ((cutlist (cl-subseq taglist 0 (min 10 (safe-length taglist)))))
  (dotimes (i (min 10 (safe-length taglist)))
    (let* ((tag (nth i taglist))
           (tagname (if (listp tag) (car tag) tag))
           (fname (intern (concat "aj/mu4e-toggle-tag-" tagname))))
      (eval
       `(defun ,fname () ,(format "Toggle the %s-tag in mu4e-headers-mode" tagname)
               (interactive)
               (let ((msg (mu4e-message-at-point)))
                 (when msg
                   (if (member ,tagname (mu4e-message-field msg :tags))
                       (mu4e-action-retag-message msg ,(concat "-" tagname))
                     (mu4e-action-retag-message msg ,(concat "+" tagname)))))))
      (bind-key (number-to-string (mod (1+ i) 10))
                fname
                mu4e-headers-mode-map))))

(aj/mu4e-defun-toggle-tags aj/mail-tags)
#+end_src

** Action for View in external browser
#+begin_src emacs-lisp
(add-to-list 'mu4e-view-actions '("View in external browser" . mu4e-action-view-in-browser))
#+end_src

** Contacts exclusion for completion
#+begin_src emacs-lisp
(defvar aj/mu4e-contacts-exclude-pattern
  (regexp-opt
   (append (with-temp-buffer
             (insert-file-contents "~/contacts-exclude")
             (split-string (buffer-substring (point-min) (point-max)) "\n" t))
           '("no-reply" "noreply" "github.com" "donotreply" "newsletter" "launchpad.net"
             "notification"))))

(setq mu4e-contact-process-function #'aj/mu4e-contact-process-function)

(defun aj/mu4e-contact-process-function (c)
  (unless (string-match-p aj/mu4e-contacts-exclude-pattern c)
    c))
#+end_src

** Empty old messages in trash
#+begin_src emacs-lisp
(use-package mu4e-purge-trash
  :straight ( :host sourcehut
              :repo "andersjohansson/mu4e-purge-trash")
  :custom (mu4e-purge-trash-query "maildir:\"/chalmers/Deleted Items\" date:..6m")
  :hook '(midnight-mode . mu4e-purge-trash))
#+end_src

* Provide statement
#+begin_src emacs-lisp
(provide 'aj-mail-config)

;; Local Variables:
;; byte-compile-warnings: '(not free-vars)
;; End:
#+end_src

* Local Variables :ARCHIVE:

# Local Variables:
# eval: (progn (require 'use-package) (variable-pitch-mode -1))
# aj/inhibit-flyspell: t
# End:
