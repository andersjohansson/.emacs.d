#+TITLE: Mail config file (mu4e)
#+AUTHOR: Anders Johansson
#+PROPERTY: header-args :tangle yes :comments no :no-expand t
#+TODO: KOLLA TODO | DONE

* Lexical-binding
#+BEGIN_SRC emacs-lisp
;; -*- lexical-binding: t -*-
#+END_SRC

* mail-config
** Mu4e should be available
I install it with emacs, and this should prevent other packages below to install it via straight.
#+begin_src emacs-lisp
(use-package mu4e
  :straight (mu4e :type built-in))
#+end_src

** Basic settings for mailing and auth
I use ~msmtp~ together with the queueing script ~msmtpq~ (included with ~msmtp~).
#+BEGIN_SRC emacs-lisp
(setq message-send-mail-function #'message-send-mail-with-sendmail
      message-interactive nil ;; because msmtpq is slow with my slow network
      sendmail-program "msmtpq"
      message-sendmail-extra-arguments '("--read-recipients")
      mu4e-action-tags-header "Keywords")
;; (require 'auth-source-pass)
;; (auth-pass-enable)
#+END_SRC

** Display mail queue (from ~msmtpq~) in modeline
#+begin_src emacs-lisp
(defvar aj/mail-queue-modeline "")
(add-to-list 'global-mode-string '(t aj/mail-queue-modeline))

(defun aj/update-mail-queue-modeline (_event)
  (let ((l (length (directory-files "~/.msmtp.queue" nil "\\.mail$"))))
    (setq aj/mail-queue-modeline
          (if (< 0 l)
              (format " %d%s " l
                      (all-the-icons-alltheicon "arrow-right" :v-adjust 0.02))
            ""))))

;; first run
(aj/update-mail-queue-modeline t)
;; update on file changes
(defvar aj/mail-queue-watch
  (file-notify-add-watch "~/.msmtp.queue" '(change) #'aj/update-mail-queue-modeline))
#+end_src

** My custom tags :ARCHIVE:
#+BEGIN_SRC emacs-lisp
(defcustom aj/mail-tags '()
  "Tags I use for emails. Each element is a list with the name
of the tag, the color, the symbol and (optionally) the default refile
folder (if this is wrapped as a list it means the starting point
for refile folder selection)"
  :group aj)

#+END_SRC


** Symbols
#+BEGIN_SRC emacs-lisp
;; (defconst aj/mu4e-symbols-override
;;   '((mu4e-headers-draft-mark     . ("D" . "📝")) ;; ✒ ✏
;;     (mu4e-headers-flagged-mark   . ("F" . "🏴"))
;;     (mu4e-headers-new-mark       . ("N" . ""))
;;     (mu4e-headers-passed-mark    . ("P" . "❯")) ;; ↪ "→"
;;     (mu4e-headers-replied-mark   . ("R" . "❮")) ;; "→"
;;     (mu4e-headers-seen-mark      . ("S" . " ")) ;; ✓ 🗸 ✔
;;     (mu4e-headers-trashed-mark   . ("T" . "✗")) ;; 🗑
;;     (mu4e-headers-attach-mark    . ("a" . "📎"))
;;     (mu4e-headers-encrypted-mark . ("x" . "🔐"))
;;     (mu4e-headers-signed-mark    . ("s" . "🔏"))
;;     (mu4e-headers-unread-mark    . ("u" . "●")) ;; ★
;;))


;; Only symbols that are in Ubuntu mono font, to avoid width problems
(defconst aj/mu4e-symbols-override
  '((mu4e-headers-draft-mark     . ("D" . "□")) ;; ✒ ✏
    (mu4e-headers-flagged-mark   . ("F" . "†"))
    (mu4e-headers-new-mark       . ("N" . " "))
    (mu4e-headers-passed-mark    . ("P" . "»")) ;; ↪ "→"
    (mu4e-headers-replied-mark   . ("R" . "«")) ;; "→"
    (mu4e-headers-seen-mark      . ("S" . "")) ;; ✓ 🗸 ✔
    (mu4e-headers-trashed-mark   . ("T" . "∏")) ;; 🗑
    (mu4e-headers-attach-mark    . ("a" . "■"))
    (mu4e-headers-encrypted-mark . ("x" . "🔐"))
    (mu4e-headers-signed-mark    . ("s" . "🔏"))
    (mu4e-headers-unread-mark    . ("u" . "•")) ;; ★
    ))


(cl-loop for (var . (letter . symbol)) in aj/mu4e-symbols-override
         do (set var (cons letter (propertize symbol 'face '(:weight normal)))))
#+END_SRC

** Definition of contexts -- private settings
#+BEGIN_SRC emacs-lisp
;;(shouldn’t this be a macro)
(defun aj/construct-match-func (emailregexp)
  "Return a match function which matches :to fields of passed msg
or the from field if we are in `mu4e-compose-mode' with
EMAILREGEXP"
  `(lambda (msg)
     (or
      (and msg (mu4e-message-contact-field-matches msg :to ,emailregexp))
      (and (not msg) (eq major-mode 'mu4e-compose-mode) (string-match-p ,emailregexp (message-fetch-field "from"))))))


(defcustom aj/mu4e-refile-fns nil
  "List of functions for determining correct refile dir for a message.

Each function receives a message MSG and should return a string
with maildir or a list with a maildir string, which means let the
user choose, starting at that path.")


(require 'aj-mail-config-private)
#+END_SRC
** Basic settings
#+BEGIN_SRC emacs-lisp
(setq mu4e-confirm-quit nil
      mu4e-context-policy 'pick-first
      mu4e-compose-context-policy 'ask-if-none
      mu4e~update-buffer-height 4
      mu4e-split-view 'vertical
      mu4e-index-update-error-warning nil)

(with-eval-after-load "helm"
  (add-to-list 'helm-completing-read-handlers-alist
               '(mu4e-view-save-attachment-single . helm-read-file-name-handler-1))
  (add-to-list 'helm-completing-read-handlers-alist
               '(mu4e-view-save-attachment-multi . helm-read-file-name-handler-1)))
#+END_SRC

** Add ons
*** org-mu4e
#+BEGIN_SRC emacs-lisp
(use-package org-mu4e
  :straight nil
  :commands org-mu4e-store-link org-mu4e-open)
#+END_SRC

*** mu4e-maildirs-extension :ARCHIVE:
#+BEGIN_SRC emacs-lisp
(use-package mu4e-maildirs-extension
  :after mu4e
  :config (setq mu4e-maildirs-extension-use-bookmarks nil
                mu4e-maildirs-extension-toggle-maildir-key (kbd "TAB"))
  (mu4e-maildirs-extension-load))
#+END_SRC

*** helm-mu
#+BEGIN_SRC emacs-lisp
(use-package helm-mu
  :commands (helm-mu helm-mu-contacts)
  :config (require 'mu4e-headers)
  (bind-key "S" #'helm-mu mu4e-main-mode-map))
#+END_SRC

*** mu4e-helm-contact
Insert contacts with helm
https://gitlab.com/andersjohansson/mu4e-helm-contact
#+BEGIN_SRC emacs-lisp
  (use-package mu4e-helm-contact
	:straight nil
	:load-path "~/kodat/elisp/mu4e-helm-contact"
	:after mu4e-compose)
#+END_SRC

*** mu4e-alert
Only display unread count in modeline
#+BEGIN_SRC emacs-lisp
(use-package mu4e-alert
  :after mu4e
  :custom (mu4e-alert-set-window-urgency nil)
  :config
  (mu4e-alert-enable-mode-line-display)

  ;; (mu4e-alert-set-default-style 'notifications)
  ;; (defun aj/open-mu4e-unread (&rest _args)
  ;;   (if-let (window
  ;;            (cl-loop with res = nil
  ;;                     for buffer in (list mu4e~headers-buffer mu4e~view-buffer mu4e~main-buffer-name)
  ;;                     if (setq res (and buffer (get-buffer-window buffer t))) return res))
  ;;       (progn
  ;;         (select-frame-set-input-focus (window-frame window))
  ;;         (select-window window))
  ;;     (select-frame-set-input-focus (make-frame)))
  ;;   (mu4e-alert-view-unread-mails))

  ;; (defun mu4e-alert-notify-unread-messages (mails)
  ;;   "Display desktop notification for given MAILS."
  ;;   (let* ((mail-groups (funcall mu4e-alert-mail-grouper
  ;;                                mails))
  ;;          (sorted-mail-groups (sort mail-groups
  ;;                                    mu4e-alert-grouped-mail-sorter))
  ;;          (notifications (mapcar (lambda (group)
  ;;                                   (funcall mu4e-alert-grouped-mail-notification-formatter
  ;;                                            group
  ;;                                            mails))
  ;;                                 sorted-mail-groups)))
  ;;     (dolist (notification (cl-subseq notifications 0 (min 5 (length notifications))))
  ;;       (notifications-notify :body (plist-get notification :body)
  ;;                             :title (plist-get notification :title)
  ;;                             :actions '("default" "Open mails")
  ;;                             :on-action 'aj/open-mu4e-unread
  ;;                             :category "mu4e-alert"))
  ;;     (when notifications
  ;;       (mu4e-alert-set-window-urgency-maybe))))

  ;; (defun mu4e-alert-notify-unread-messages-count (mail-count)
  ;;   "Display desktop notification for given MAIL-COUNT."
  ;;   (when (not (zerop mail-count))
  ;;     (notifications-notify :body (funcall mu4e-alert-email-count-notification-formatter
  ;;                                          mail-count)
  ;;                           :title mu4e-alert-email-count-title
  ;;                           :actions '("default" "Open mails")
  ;;                           :on-action 'aj/open-mu4e-unread
  ;;                           :category "mu4e-alert")))
  )
#+END_SRC

*** mu4e-query-helper
Some completion for searching.
Available at: https://gitlab.com/andersjohansson/mu4e-query-helper

#+BEGIN_SRC emacs-lisp
  (use-package mu4e-query-helper
	:straight nil
	:load-path "~/kodat/elisp/mu4e-query-helper/"
	:after mu4e-headers
	:bind (:map mu4e-headers-mode-map
		   ("s" . mu4e-query-helper-search)
		   ("S" . mu4e-query-helper-search-edit)))
#+END_SRC

** Contact handling
*** LDAP (EUDC)
#+begin_src emacs-lisp
(with-eval-after-load 'mu4e-compose
  (bind-key "C-c C-ä" #'eudc-expand-inline mu4e-compose-mode-map))

(setq eudc-server-hotlist
      '(("ldap://localhost:1389" . ldap)))
(eudc-set-server "ldap://localhost:1389" 'ldap)
(setq eudc-expansion-overwrites-query t)

;; Don’t do any stupid options saving, my options are above!
(setq eudc-options-file "nonononononononono.el") ;; see eudc.el::1157
(with-eval-after-load 'eudc
  (advice-add 'eudc-save-options :override #'ignore))

(defun aj/display-eudc-info-at-point ()
  (interactive)
  (if-let ((email (or (get-text-property (point) 'email)
                      (thing-at-point 'email t))))
      (aj/display-eudc-info-other-buffer (s-chop-prefix "<" (s-chop-suffix ">" email)))
    (user-error "No address found at point")))

;;TODO, try to parse address around point also ^

(defvar aj/interesting-ldap-fields '(cn title department mail telephonenumber mobile uid manager))

(dolist (i '((title . "Title")
             (department . "Institution")
             (mail . "Mail")
             (mobile . "Mobil")
             (uid . "ID")
             (manager . "Chef")))
  (add-to-list 'eudc-user-attribute-names-alist i))

(defun aj/display-eudc-info-other-buffer (email)
  (interactive "sEmail: ")
  (if-let ((results (eudc-query `((mail . ,email)))))
      (let ((buf (get-buffer-create "*aj-eudc*")))
        (unless (eq buf (current-buffer))
          (view-buffer-other-window buf)
          (with-current-buffer buf
            (let* ((inhibit-read-only t)
                   (fields (cl-loop for f in aj/interesting-ldap-fields
                                    collect
                                    (cons f (eudc-format-attribute-name-for-display f))))
                   (fieldlength (cl-loop for f in fields maximize (length (cdr f)))))
              (erase-buffer)
              (cl-loop for result in results
                       do
                       (cl-loop for f in fields
                                do
                                (when-let (ff (alist-get (car f) result))
                                  (eudc-print-record-field
                                   (cons (cdr f)
                                         (decode-coding-string ff 'utf-8))
                                   fieldlength))
                                )
                       (insert "\n"))))))
    (user-error "No results found for address %s" email)))


;; TODO. Gör "Chef", klickbar. Kanske går att göra med en lämplig
;; funktion för den (och för id, men det är nog mer meningslöst) i:
;; eudc-attribute-display-method-alist
#+end_src

** View mode settings
#+BEGIN_SRC emacs-lisp
(add-hook 'mu4e-view-mode-hook #'visual-line-mode)
(add-hook 'mu4e-view-mode-hook #'variable-pitch-mode)
(require 'mu4e-contrib)
;; (add-to-list 'mu4e-view-actions '("Webkit-widget" . mu4e-action-view-with-xwidget))
(setq mu4e-html2text-command 'mu4e-shr2text)
#+END_SRC

** Command for quick check of new mails
#+BEGIN_SRC emacs-lisp
;;(defvar aj/mu4e-get-mail-command-quick "mbsync --new -qq uu-inbox gmail-inbox ajf-inbox")
(defvar aj/mu4e-get-mail-command-quick "aj-mailsync-quick")

(defun aj/mu4e-update-mail-and-index (full?)
  (interactive "P")
  (if full?
      (mu4e-update-mail-and-index t)
    (let ((mu4e-get-mail-command aj/mu4e-get-mail-command-quick))
      (mu4e-update-mail-and-index t))))

(bind-key "C-c C-u" #'aj/mu4e-update-mail-and-index mu4e-headers-mode-map)
#+END_SRC

** Composing and sending
*** Format=flowed, but with long lines
As most clients (outlook etc.) don’t support format=flowed correctly anyway. Sending as long lines as possible will mostly make it look ok.
https://vxlabs.com/2019/08/25/format-flowed-with-long-lines/
#+begin_src emacs-lisp
(setq mu4e-compose-format-flowed t
      fill-flowed-encode-column 998)
#+end_src

*** Some compose settings
#+BEGIN_SRC emacs-lisp
(setq mail-user-agent 'mu4e-user-agent
      mu4e-compose-hidden-headers '("^Face:" "^X-Face:" "^X-Draft-From:" "^User-agent:" "References:"))

;; in case write is invoked before mu4e is loaded 
(add-hook 'mu4e-compose-pre-hook #'mu4e~start)

;; (with-eval-after-load "helm-mode"
;;   (add-to-list 'helm-mode-no-completion-in-region-in-modes 'mu4e-compose-mode))
#+END_SRC

*** Make header separator a thin line
The line ~--text follows this line--~ that separaters headers from the message doesn’t look that nice. We can improve on it! 
We set the face for it to a thin line with the same background and foreground.
Then, we also want it to extend to the end of line, so we’ll have to patch ~mu4e~draft-insert-mail-header-separator~ to insert an extra line break.

#+begin_src emacs-lisp
(set-face-attribute 'mu4e-compose-separator-face nil
                    :background "#e0e0e0" :foreground "#e0e0e0"
                    :height 0.2 :box nil :extend t)
(el-patch-feature mu4e-draft)
(with-eval-after-load 'mu4e-draft
  (el-patch-defun mu4e~draft-insert-mail-header-separator ()
    "Insert `mail-header-separator' in the first empty line of the message.
`message-mode' needs this line to know where the headers end and
the body starts. Note, in `mu4e-compose-mode', we use
`before-save-hook' and `after-save-hook' to ensure that this
separator is never written to the message file. Also see
`mu4e-remove-mail-header-separator'."
    ;; we set this here explicitly, since (as it has happened) a wrong
    ;; value for this (such as "") breaks address completion and other things
    (set (make-local-variable 'mail-header-separator) "--text follows this line--")
    (put 'mail-header-separator 'permanent-local t)
    (save-excursion
      ;; make sure there's not one already
      (mu4e~draft-remove-mail-header-separator)
      (let ((sepa (propertize (el-patch-wrap 1 1 (concat mail-header-separator "\n"))
                              'intangible t
                              ;; don't make this read-only, message-mode
                              ;; seems to require it being writable in some cases
                              ;;'read-only "Can't touch this"
                              'rear-nonsticky t
                              'font-lock-face 'mu4e-compose-separator-face)))
        (widen)
        ;; search for the first empty line
        (goto-char (point-min))
        (if (search-forward-regexp "^$" nil t)
            (progn
              (replace-match sepa)
              ;; `message-narrow-to-headers` searches for a
              ;; `mail-header-separator` followed by a new line. Therefore, we
              ;; must insert a newline if on the last line of the buffer.
              (when (= (point) (point-max))
                (insert "\n")))
          (progn ;; no empty line? then prepend one
            (goto-char (point-max))
            (insert "\n" sepa)))))))
#+end_src

*** Allow and handle context change while composing
I often open a compose buffer without checking the context. The functions below make sure that switching context in a compose buffer works as expected. A function to switch address and signature when switching context is defined. However, several compose buffers may be open at once, and this will only switch for the current buffer (which I believe is the most reasonable behaviour). To ensure that we don’t attempt to send a message with the wrong context active, a function to check if the context matches with the from address is added to ~message-send-hook~.
#+BEGIN_SRC emacs-lisp
(defun aj/mu4e-compose-context-switch (&rest _ignore)
  "When switching context in a compose buffer, switch “from” and signature."
  (when (eq major-mode 'mu4e-compose-mode)
    (message-replace-header "From" (mu4e~draft-from-construct))
    (message-replace-header "Reply-to" mu4e-compose-reply-to-address)
    (setq-local message-signature mu4e-compose-signature)
    (setq aj/message-sig-cycle 0)
    (aj/message-remove-signature)
    (save-excursion (message-insert-signature))))

(advice-add 'mu4e-context-switch :after #'aj/mu4e-compose-context-switch)

(defun aj/message-remove-signature ()
  "Find and remove signature."
  (save-excursion
    (when (message-goto-signature)
      (forward-line -1)
      (delete-region (1- (point)) (point-max)))))

(defun aj/message-send-check-context ()
  "Check that from address and context matches, and ask to change if required.

This is to avoid making mistakes in trying to send the current
message from the wrong account"
  ;; this may be a too strict check
  (when (not
         (or
          (null mu4e-contexts)
          (string= (message-fetch-field "from")
                   (mu4e~draft-from-construct))))
    (let ((context (mu4e-context-determine nil nil)))
      (cond ((and context
                  (y-or-n-p
                   (format
                    "Attempt to send via mismatching context. Switch to [%s] and send? "
                    (mu4e-context-name context))))
             (mu4e-context-switch t (mu4e-context-name context)))
            ((not context)
             (mu4e-context-switch
              t
              (mu4e-context-name  ; throws an error if no context found:
               (mu4e~context-ask-user
                "Attempt to send via mismatching context! Send after switching to: "))))
            (t (signal 'quit nil))))))

(add-hook 'message-send-hook #'aj/message-send-check-context)
#+END_SRC

*** Signature cycling
I have long and "official" signatures defined for my accounts, but often I want to just include my name, or nothing at all. This function allows me to cycle through the signature set in the context (variable ~message-context~), a list of shorter ones, and localized signatures when writing in different languages (English and Swedish really). 

Also commented below a function for switching signature language automatically with guess-language. I found it too unpredictable however (for example when replying in a different language) and just switching manually gives more control.
#+BEGIN_SRC emacs-lisp
(defvar aj/message-simple-signatures '("Anders Johansson\n" ""))
(defvar aj/mu4e-compose-localized-signatures nil
  "Alist of language and signature")

(defvar-local aj/message-sig-cycle 0)

(defun aj/message-signature-cycle ()
  (interactive)
  (let ((sigs (cl-remove nil
                         (cl-remove-duplicates
                          (append (list message-signature)
                                  (mapcar #'cdr aj/mu4e-compose-localized-signatures)
                                  aj/message-simple-signatures)
                          :test #'equal))))
    (setq aj/message-sig-cycle
          (mod (1+ aj/message-sig-cycle)
               (length sigs)))
    (aj/message-change-signature (nth aj/message-sig-cycle sigs) t)))

(bind-key "C-c C-p" #'aj/message-signature-cycle mu4e-compose-mode-map)

(defun aj/message-change-signature (sig &optional show)
  (save-excursion
    (aj/message-remove-signature)
    (let ((message-signature sig))
      (unless (or  (not sig) (string= message-signature ""))
        (message-insert-signature)))
    (when show
      ;; to be able to see what happens in a long message:
      (sit-for 0.4))))

;; Switch signature with guess-language?

;; (with-eval-after-load 'guess-language
;;   (add-to-list 'guess-language-after-detection-functions
;;                #'aj/message-switch-signature-language))

;; (defun aj/message-switch-signature-language (lang _beg _end)
;;   (when (eq major-mode 'mu4e-compose-mode)
;;     (aj/message-change-signature
;;      (alist-get lang aj/mu4e-compose-localized-signatures))))
#+END_SRC

*** Context cycling
I want to use a single binding to switch (cycle through) contexts when composing.
#+BEGIN_SRC emacs-lisp
(defun aj/mu4e-cycle-contexts ()
  "Cycle through `mu4e-contexts'."
  (interactive)
  (when mu4e-contexts
    (let* ((names (mapcar #'mu4e-context-name mu4e-contexts))
           (currentname (ignore-errors (mu4e-context-name mu4e~context-current))))
      (mu4e-context-switch t
                           (nth
                            (mod (if currentname
                                     (1+ (cl-position currentname names :test #'equal))
                                   0)
                                 (length names))
                            names)))))

(bind-key "C-c C-i" #'aj/mu4e-cycle-contexts mu4e-compose-mode-map)
#+END_SRC

*** Ask for confirmation before sending mail
#+BEGIN_SRC emacs-lisp
(setq message-confirm-send t)
#+END_SRC

*** Let flyspell only check relevant regions
#+BEGIN_SRC emacs-lisp
(put 'mu4e-compose-mode 'flyspell-mode-predicate #'mail-mode-flyspell-verify)
#+END_SRC
**** Home grown  :ARCHIVE:
#+BEGIN_SRC emacs-lisp
(defun aj/mu4e-compose-flyspell-ignore ()
  "Function used for `flyspell-generic-check-word-predicate' to ignore headers in message-mode"
  (or (and (message-in-body-p) (not (aj/message-in-signature-p)))
      (and (save-excursion (beginning-of-line)
                           (looking-at-p "^Subject: "))
           (not (org-in-regexp "Subject:")))))

(autoload 'org-in-regexp "org")

(defun aj/message-in-signature-p ()
  (save-excursion
    (save-match-data
      (re-search-backward message-signature-separator nil t))))

(put 'mu4e-compose-mode 'flyspell-mode-predicate #'aj/mu4e-compose-flyspell-ignore)
#+END_SRC
*** Identity switching in compose buffer :ARCHIVE:
#+BEGIN_SRC emacs-lisp
(bind-keys
 :map mu4e-compose-mode-map
 ("C-c C-i" . aj/message-switch-uu-identity)
 ("C-c C-p" . aj/message-signature-cycle))

(defvar aj/message-current-uu-identity "Physics")

(defun aj/message-switch-uu-identity ()
  (interactive)
  (setq aj/message-current-uu-identity
        (if (string= aj/message-current-uu-identity "Physics")
            "Gender"
          "Physics")
        aj/message-sig-cycle 0)
  (let* ((cv (mu4e-context-vars
              (aj/mu4e-context-get-context
               aj/message-current-uu-identity)))
         (user-mail-address (cdr (assoc 'user-mail-address cv)))
         (message-signature-file (cdr (assoc 'message-signature-file cv)))
         (message-signature t))
    (save-excursion
      (aj/message-change-from (message-make-from))
      (aj/message-remove-signature)
      (message-insert-signature))))
#+END_SRC
*** Automatically refile message efter reply or forward :ARCHIVE:
When I have acted upon a message I refile it from the inbox. Replying or forwarding almost certainly means I want to do this.

I have never gotten this to work though.
#+BEGIN_SRC emacs-lisp
;; (defvar aj/mu4e-rep-msg-tmp nil)
;; (defun aj/mu4e~compose-set-parent-flag (path)
;;  "Also refile the replied message to archive"
;;  (let ((buf (find-file-noselect path)))
;;    (when buf
;;      (with-current-buffer buf
;;        (message-narrow-to-headers-or-head)
;;        (let ((in-reply-to (message-fetch-field "in-reply-to"))
;;              (forwarded-from)
;;              (references (message-fetch-field "references"))
;;              (mu4e-view-func (lambda (msg) (setq aj/mu4e-rep-msg-tmp msg))))
;;          (unless in-reply-to
;;            (when references
;;              (with-temp-buffer ;; inspired by `message-shorten-references'.
;;                (insert references)
;;                (goto-char (point-min))
;;                (let ((refs))
;;                  (while (re-search-forward "<[^ <]+@[^ <]+>" nil t)
;;                    (push (match-string 0) refs))
;;                  ;; the last will be the first
;;                  (setq forwarded-from (first refs))))))
;;          ;; remove the <>
;;          (when (and in-reply-to (string-match "<\\(.*\\)>" in-reply-to))
;;            (mu4e~proc-view (match-string 1 in-reply-to))
;;            (mu4e~proc-move (match-string 1 in-reply-to)
;;                            (and (accept-process-output mu4e~proc-process 1)
;;                                 (aj/mu4e-refile-folder aj/mu4e-rep-msg-tmp t))
;;                            "+R-N-F"))
;;          (when (and forwarded-from (string-match "<\\(.*\\)>" forwarded-from))
;;            (mu4e~proc-view (match-string 1 forwarded-from))
;;            (mu4e~proc-move (match-string 1 forwarded-from)
;;                            (and (accept-process-output mu4e~proc-process 1)
;;                                 (aj/mu4e-refile-folder aj/mu4e-rep-msg-tmp t))
;;                            "+P-N-F"))))))
;;  (setq aj/mu4e-rep-msg-tmp nil))


;; variant:
;; (defun aj/mu4e~compose-set-parent-flag (path)
;;  "Also refile the replied message to archive"
;;  (let ((buf (find-file-noselect path)))
;;    (when buf
;;      (with-current-buffer buf
;;        (message-narrow-to-headers-or-head)
;;        (let ((in-reply-to (message-fetch-field "in-reply-to"))
;;              (forwarded-from)
;;              (references (message-fetch-field "references"))
;;              (mu4e-view-func (lambda (msg) (setq aj/mu4e-rep-msg-tmp msg))))
;;          (unless in-reply-to
;;            (when references
;;              (with-temp-buffer ;; inspired by `message-shorten-references'.
;;                (insert references)
;;                (goto-char (point-min))
;;                (let ((refs))
;;                  (while (re-search-forward "<[^ <]+@[^ <]+>" nil t)
;;                    (push (match-string 0) refs))
;;                  ;; the last will be the first
;;                  (setq forwarded-from (first refs))))))
;;          ;; remove the <>
;;          (when (and in-reply-to (string-match "<\\(.*\\)>" in-reply-to))
;;            (let ((msgid (match-string 1 in-reply-to)))
;;              (mu4e~proc-view msgid)
;;              ;; (accept-process-output mu4e~proc-process 10 nil)
;;              (message "AJ: %s" aj/mu4e-rep-msg-tmp)
;;              ;; (mu4e~proc-move msgid
;;              ;;                 (and aj/mu4e-rep-msg-tmp
;;              ;;                      (aj/mu4e-refile-folder aj/mu4e-rep-msg-tmp t))
;;              ;;                 "+R-N-F")
;;              ))
;;          (when (and forwarded-from (string-match "<\\(.*\\)>" forwarded-from))
;;            (mu4e~proc-view (match-string 1 forwarded-from))
;;            ;;(accept-process-output mu4e~proc-process 1 nil t)
;;            (mu4e~proc-move (match-string 1 forwarded-from)
;;                            (and aj/mu4e-rep-msg-tmp
;;                                 (aj/mu4e-refile-folder aj/mu4e-rep-msg-tmp t))
;;                            "+P-N-F"))))))
;;  (setq aj/mu4e-rep-msg-tmp nil))
;; (advice-add 'mu4e~compose-set-parent-flag :override #'aj/mu4e~compose-set-parent-flag)

#+END_SRC

*** Yank adressess
#+BEGIN_SRC emacs-lisp
(defun aj/message-yank-adressess ()
  (interactive)
  (let* ((ck (current-kill 0))
         (cksp (split-string ck "\n" t "[ 	]+")))
    (if (< 1 (safe-length cksp))
        (insert (mapconcat 'substring-no-properties cksp ", "))
      (insert-for-yank ck))))

(bind-key "C-c M-y" #'aj/message-yank-adressess mu4e-compose-mode-map)
#+END_SRC

*** Don’t return to mu4e buffers when mail has been sent
I often invoke a compose buffer in a window where I’m doing something else, and when mu4e then wants to helpfully switch back to the headers buffer or something, my window config gets messed up. This is better.
#+BEGIN_SRC emacs-lisp
(advice-add 'mu4e~switch-back-to-mu4e-buffer :override #'ignore)
#+END_SRC

*** Customize cite string
#+BEGIN_SRC emacs-lisp
;; TODO, anropet till message-cite-original i mu4e-draft (vilken
;; funktion?) är ju helt verkningslöst då message-reply-buffer verkar
;; vara odefinierad (iaf vid forward). Kolla närmare
(with-eval-after-load 'mu4e-draft
  (defun aj/mu4e-draft-cite-original (fun origmsg)
    (let ((mu4e-view-show-addresses t)
          ;; (message-reply-buffer t)
          )
      (funcall fun origmsg)))
  (advice-add 'mu4e~draft-cite-original :around #'aj/mu4e-draft-cite-original)
  ;; customize the reply-quote-string
  (setq message-citation-line-format "On %A %-e %b %Y at %R, %f wrote:\n")
  ;; choose to use the formatted string, with some language guessing
  (setq message-citation-line-function #'aj/message-insert-formatted-citation-line)

  (autoload #'guess-language-buffer "guess-language")
  (defun aj/message-insert-formatted-citation-line (&rest args)
    "Guess language and maybe force date formats to Swedish, else English"
    (let* ((sv (eq 'sv (guess-language-buffer)))
           (system-time-locale (if sv "sv_SE" "C"))
           (message-citation-line-format
            (if sv
                "%a %-e %b %Y %R, skrev %f:\n"
              message-citation-line-format))) 
      (apply #'message-insert-formatted-citation-line args))))
#+END_SRC

*** Attachments
**** Put attachments at end of buffer 
From: http://mbork.pl/2015-11-28_Fixing_mml-attach-file_using_advice
#+BEGIN_SRC emacs-lisp
(defun aj/mml-attach-file--go-to-eob (orig-fun &rest args)
  "Go to the end of buffer before attaching files."
  (save-excursion
    (save-restriction
      (widen)
      (goto-char (point-max))
      (search-backward-regexp message-signature-separator (- (point) 500) t) ;; 500 chars reasonable limit for signature
      (apply orig-fun args))))

(advice-add 'mml-attach-file :around #'aj/mml-attach-file--go-to-eob)
#+END_SRC

**** Use custom command to invert prefix argument logic of ~mml-attach-file~
#+begin_src emacs-lisp
(defun aj/mml-attach-file (arg)
  (interactive "P")
  (let ((current-prefix-arg (not arg)))
    (call-interactively #'mml-attach-file)))

(bind-key "C-c C-a" 'aj/mml-attach-file mu4e-compose-mode-map)
#+end_src

**** Attach with dired
#+BEGIN_SRC emacs-lisp
(with-eval-after-load "dired"
  (require 'gnus-dired)
  ;; make the `gnus-dired-mail-buffers' function also work on
  ;; message-mode derived modes, such as mu4e-compose-mode
  (defun aj/gnus-dired-mail-buffers ()
    "Return a list of active message buffers."
    (let (buffers)
      (save-current-buffer
        (dolist (buffer (buffer-list t))
          (set-buffer buffer)
          (when (and (derived-mode-p 'message-mode)
                     (null message-sent-message-via))
            (push (buffer-name buffer) buffers))))
      (nreverse buffers)))
  (advice-add 'gnus-dired-mail-buffers :override #'aj/gnus-dired-mail-buffers)

  (setq gnus-dired-mail-mode 'mu4e-user-agent)
  (add-hook 'dired-mode-hook 'turn-on-gnus-dired-mode))
#+END_SRC

**** Attach via dropbox-link
#+BEGIN_SRC emacs-lisp
(defun aj/copy-to-dropbox-return-link (file)
  "Copies a file to public dropbox folder and returns public url"
  (let ((newfile (expand-file-name (file-name-nondirectory file) "~/Dropbox/delning-publikt")))
    (copy-file file newfile 1)
    (aj/dropbox-get-link newfile)))

(defun aj/dropbox-get-link (filename)
  "Puts dropbox public link to FILENAME in kill ring.

Non-interactive use returns link"
  (interactive "f")
  (let ((link (replace-regexp-in-string
               "dl=0" "dl=1"
               (shell-command-to-string
                (format "dropbox-cli sharelink %s" (shell-quote-argument filename))))))
    (if (called-interactively-p)
        (kill-new link)
      link)))

(defun aj/mml-attach-file-dropbox-link ()
  "Attach file by inserting dropbox link."
  (interactive)
  (let ((file (mml-minibuffer-read-file "Dropbox link file: ")))
    (insert (aj/copy-to-dropbox-return-link file))))
#+END_SRC

**** Add a recipient filename to attachment at point
#+begin_src emacs-lisp
(defun aj/mml-add-attachment-recipient-filename ()
  "Add a recipient filename to attachment at point"
  (interactive)
  (save-excursion
    (goto-char (point-at-bol))
    (when (and (looking-at-p "<#part")
               (search-forward-regexp "filename=\"\\([^\"]+\\)\"" (point-at-eol) t))
      (goto-char (match-beginning 0))
      (when-let ((filename (read-string
                            "Recipient filename: "
                            (file-name-nondirectory
                             (substring-no-properties
                              (match-string 1))))))
        (insert (format "recipient-filename=\"%s\" " filename))))))
#+end_src

**** Warning when forgetting to include attachments
Adapted from https://www.topbug.net/blog/2016/12/09/attachment-reminder-in-emacs-message-mode/, 
http://disq.us/p/158wrxo, and http://mbork.pl/2016-02-06_An_attachment_reminder_in_mu4e

#+begin_src emacs-lisp
(defcustom aj/message-attachment-intent-re
  (regexp-opt '("attached"
		        "attachment"
                "pdf"
                "bifogad"
                "bifogar"
                "bilaga"))
  "A regex which - if found in the message, and if there is no
attachment - should launch the no-attachment warning.")

(defun aj/message-says-attachment-p ()
  "Return t if the message suggests there can be an attachment."
  (save-excursion
    (mail-text)
    (save-match-data
      (let (search-result)
        (while
            (and (setq search-result
                       (re-search-forward
                        aj/message-attachment-intent-re nil t))
                 (org-match-line mu4e-cited-regexp)))
        search-result))))

(defun aj/message-has-attachment-p ()
  "Return t if the message has an attachment."
  (save-excursion
    (mail-text)
    (save-match-data
      (search-forward "<#part" nil t))))

(defun aj/message-pre-send-check-attachment ()
  (when (and (aj/message-says-attachment-p)
             (not (aj/message-has-attachment-p)))
    (unless
        (y-or-n-p "Är du säker på att du inte glömde en bilaga?!")
      (keyboard-quit))))

(add-hook 'message-send-hook 'aj/message-pre-send-check-attachment -50)

#+end_src

**** Detach attachments :ARCHIVE:
#+BEGIN_SRC emacs-lisp
;;TODO, fixa! (kolla på mm- funktionerna (mime-biblioteket))
;; (defun aj/mu4e-remove-attachment (msg num)
;;   "Remove attachment."
;;   (let* ((attach (mu4e~view-get-attach msg num))
;;           (path (mu4e-msg-field msg :path))
;;           (filename (and attach (plist-get attach :name)))
;;           (cmd (format "remove-mime-attachment --filename=\"%s\" < \"%s\" > \"%s\".lock && mv \"%s\".lock \"%s\""
;;                        filename path path path path path path))
;;           ;; (cmd (format "altermime --input=%s --remove='%s'"  path filename))
;;           )
;;     (when (and filename
;;             (yes-or-no-p
;;          (format "Are you sure you want to remove '%s'?" filename)))
;;       (shell-command cmd "*SHELL_REMOVE_CMD*")
;;       (message cmd))))

;; (add-to-list 'mu4e-view-attachment-actions
;;   '("remove-attachment" . aj/mu4e-remove-attachment))

(defun aj/mu4e-detach-attachments (&optional msg)
  "Detach all files"
  (interactive)
  (let* ((msg (or msg (mu4e-message-at-point)))
         (count (hash-table-count mu4e~view-attach-map))
         (attachnums (mu4e-split-ranges-to-numbers "a" count))
         (attachdir "/home/aj/Hämtningar/mejl-extrakt/")
         ;; (bodytext (or (mu4e-message-field msg :body-txt)
         ;;               (mu4e-message-field msg :body-html)))
         ;; (textpart (cl-find-if
         ;;            (lambda (part)
         ;;              (and (not (mu4e-message-part-field part :attachment))
         ;;                   (member
         ;;                    (mu4e-message-part-field part :mime-type)
         ;;                    '("text/plain" "text/html"))))
         ;;              (mu4e-message-field msg :parts)))
         )
    (dolist (num attachnums)
      (let* ((att (mu4e~view-get-attach msg num))
             (fname  (plist-get att :name))
             (index (plist-get att :index))
             (retry t)
             fpath)
        (while retry
          (setq fpath (concat attachdir fname))
          (setq retry
                (and (file-exists-p fpath)
                     (not (y-or-n-p
                           (mu4e-format "Overwrite '%s'?" fpath))))))
        (mu4e~proc-extract
         'save (mu4e-message-field msg :docid)
         index mu4e-decryption-policy fpath)))))
#+END_SRC


*** Mail templates :ARCHIVE:
#+BEGIN_SRC emacs-lisp
(defcustom aj/mu4e-templates-dir "~/.emacs.d/mu4e-templates"
  "Directory for mail templates"
  :type 'directory
  :group 'aj)

(defun aj/weekly-report-mail ()
  ""
  (interactive)
  ;; ((mu4e-compose-mode-hook
       ;;       (remq 'mu4e-helm-contact-hook-insert mu4e-compose-mode-hook))
       ;;      ;; (symbol-function 'mu4e~draft-newmsg-construct
       ;;      ;; #'aj/weekreport-msg-construct))
       ;;      )
  (mu4e~compose-handler 'new)
  (delete-region (point-min) (point-max))
  (insert (format (aj/read-string-from-file
                   (expand-file-name "weekly-report.eml"  aj/mu4e-templates-dir))
                  (aj/weekly-report-copy-link))))
#+END_SRC

** Headers settings

*** Small stupid fix for first space in headers headline
#+begin_src emacs-lisp
(advice-add 'mu4e~header-line-format :around #'aj/mu4e-fix-header-space)

(defun aj/mu4e-fix-header-space (fn &rest r)
  (let ((mu4e~mark-fringe-len 3))
    (apply fn r)))
#+end_src
*** Headers fields
**** Set headers fields to view depending on what maildir is viewed
#+BEGIN_SRC emacs-lisp
(setq aj/mu4e-headers-fields
      '(:gmail
        ((:aj-human-date . 12)
         (:flags . 6)
         (:from-or-to . 22)
         (:gmailtags . 5)
         ;; (:othermaildir . 10)
         ;; (:mailing-list . 7)
         (:thread-subject))
        :chalmers
        ((:aj-human-date . 12)
         (:flags . 6)
         (:from-or-to . 22)
         ;; (:ajtags . 3)
         (:othermaildir . 5)
         (:ajlists . 8)
         (:thread-subject))
        nil
        ((:aj-human-date . 12)
         (:flags . 6)
         (:from-or-to . 22)
         ;; (:ajtags . 3)
         (:gmailtags . 5)
         (:othermaildir . 10)
         (:mailing-list . 7)
         (:thread-subject))))

(autoload 's-match-strings-all "s")
(autoload '--all? "dash")
(defun aj/mu4e-set-headers-fields (query)
  "Set ‘mu4e-headers-fields’ depending on which maildir is viewed."
  (when (buffer-live-p (mu4e-get-headers-buffer))
    (with-current-buffer (mu4e-get-headers-buffer)
      (setq mu4e-headers-fields
            (plist-get
             aj/mu4e-headers-fields
             (when-let* ((mdm
                          (s-match-strings-all
                           "maildir:\\(?2:\\\"\\(?1:[^\\\"]+\\)\\\"\\|\\(?1:[^[:space:]]+\\)\\)"
                           query))
                         (maildirs (mapcar #'cadr mdm)))
               (cond
                ((--all? (string-match-p "^/chalmers" it) maildirs)
                 :chalmers)
                ((--all? (string-match-p "^/\\(mejla\\|ajf\\)" it) maildirs)
                 :gmail))))
            header-line-format (mu4e~header-line-format)))))


(add-hook 'mu4e-headers-search-hook #'aj/mu4e-set-headers-fields)
;;(remove-hook 'mu4e-headers-search-hook #'aj/mu4e-set-headers-fields)

(setq mu4e-headers-fields (plist-get aj/mu4e-headers-fields nil)
      ;; mu4e-headers-from-or-to-prefix '("" . "⯈")
      mu4e-headers-include-related nil
      mu4e-headers-visible-columns nil)

#+END_SRC

**** My custom headers fields
#+BEGIN_SRC emacs-lisp
(add-to-list 'mu4e-header-info-custom
             '(:gmailtags .
                          (:name "Labels"
                                 :shortname "GL"
                                 :help "Gmail labels"
                                 :function aj/mu4e-gmail-labels-display)))

(defvar aj/mu4e-gmail-labels
  '(("\\Inbox" "#076678" "↓")
    ("\\Sent" "#665c54" "↑")
    ("\\Important" "#b57614" "❧")
    ("\\Draft" "#665c54" "□")))

(defun aj/mu4e-gmail-labels-display (msg)
  (let ((tags (mu4e-message-field msg :tags)))
    (cl-loop for label in aj/mu4e-gmail-labels
             concat
             (if (member (car label) tags)
                 (propertize
                  (or (nth 2 label ) "⬕")
                  'face (list :foreground (cadr label)))
               " "))))


(add-to-list 'mu4e-header-info-custom
             '(:othermaildir . (:name "Maildir"
                                      :shortname "M"
                                      :help "Maildir"
                                      :function aj/mu4e-other-maildir)))

(autoload 's-chop-prefix "s")
(autoload 's-shared-start "s")
(autoload 's-replace-all "s")
(defun aj/mu4e-other-maildir (msg)
  "Returns a possibly shortened indication of MSGs maildir
Returns the empty string if this is the \"current\" maildir."
  (let ((mmd (mu4e-message-field msg :maildir)))
    (if (string-match  "maildir:\\\"\\(.+\\)\\\"" mu4e~headers-last-query)
        (let ((smd (match-string 1 mu4e~headers-last-query)))
          (if (string= smd mmd)
              ""
            (s-chop-prefix (s-shared-start mmd smd) mmd)))
      (s-replace-all '(("/uu/" . "🅄 ")
                       ("/chalmers/" . "🄲")
                       ("/mejla/" . "🄶 ")
                       ("/ajf/" . "🄰 ")) mmd))))

(add-to-list 'mu4e-header-info-custom
             '(:aj-human-date .
                              (:name "Date"
                                     :shortname "Date"
                                     :help "Date/time when the message was written."
                                     :function aj/mu4e~headers-human-date)))

(defsubst aj/mu4e~headers-human-date (msg)
  "Show a 'human' date.
If the date is today, yesterday or, show the time, otherwise, show the
date. The formats used for date and time are
`mu4e-headers-date-format' and `mu4e-headers-time-format'."
  (let ((date (mu4e-msg-field msg :date)))
    (if (equal date '(0 0 0))
        "None"
      (let* ((days1 (time-to-days date))
             (days2 (time-to-days (current-time))))
        (cond
         ((eq days1 days2)
          (format-time-string "  %X" date))
         ((eq days1 (1- days2)) ;;yesterday
          (format-time-string "igår %H:%M" date))
         ((< (- days2 days1) 5)
          (format-time-string "%a  %H:%M" date))
         
         (t (format-time-string "%x" date)))))))

#+END_SRC

**** Custom header, tags :ARCHIVE:
#+begin_src emacs-lisp
(add-to-list 'mu4e-header-info-custom
             '(:ajtags .
                       (:name "Tags"
                              :shortname "🏷"
                              :help "Tags"
                              :function aj/mu4e-header-tags)))

(defun aj/mu4e-header-tags (msg)
  (let ((tags (sort (mu4e-message-field msg :tags) 'string<)))
    (cl-loop with found
             for tag in tags
             if (setq found (assoc tag aj/mail-tags))
             concat
             (propertize
              (or (nth 2 found ) "⬕")
              'face (list :foreground (cadr found))))))

#+end_src
**** Custom field for lists
#+begin_src emacs-lisp
(add-to-list 'mu4e-header-info-custom
             '(:ajlists .
                        (:name "List"
                               :shortname "List"
                               :help "List"
                               :function aj/mu4e-headers-list)))

(defcustom aj/mu4e-mailing-lists nil
  "Alist with shortnames of mailing lists based on list address.
Like ‘mu4e-user-mailing-lists’."
  :group 'aj
  :type '(alist :key-type string :value-type string))

(defun aj/mu4e-headers-list (msg)
  "Show a mailing list"
  (if-let ((list (mu4e-msg-field msg :mailing-list)))
      (mu4e~headers-mailing-list list)
    (mapconcat
     #'identity
     (cl-loop for (list . short) in aj/mu4e-mailing-lists
              when (mu4e-message-contact-field-matches
                    msg '(:to :from :cc :bcc) list)
              collect short)
     ", ")))




#+end_src


*** Set face of subject field to variable-pitch
#+BEGIN_SRC emacs-lisp
(defun aj/mu4e-headers-field-set-subject-face (msg field)
  "Set face of VAL to variable-pitch if FIELD is :subject."
  (when (member field '(:thread-subject :subject))
    '(:inherit variable-pitch)))

(setq mu4e-headers-field-properties-function
      #'aj/mu4e-headers-field-set-subeject-face)
#+END_SRC

*** Load next 500 messages
#+BEGIN_SRC emacs-lisp
(defvar aj/mu-page 1)

(defun aj/mu-reset-page (&rest _r)
  (setq aj/mu-page 1))

;; We need to reset it for the "standard searches", but also when
;; invoking an interactive search
(add-hook 'mu4e-headers-search-bookmark-hook #'aj/mu-reset-page)
(advice-add 'mu4e~headers-jump-to-maildir :before #'aj/mu-reset-page)

(defun aj/mu-next-messages-for-query ()
  (interactive)
  (let ((hb (mu4e-get-headers-buffer)))
    (when (and (buffer-live-p hb) (not mu4e-headers-full-search))
      (with-current-buffer hb
        (when-let ((query (mu4e-last-query)))
          (cl-incf aj/mu-page)
          (let ((mu4e-headers-results-limit
                 (* aj/mu-page mu4e-headers-results-limit))
                (last-msg (save-excursion
                            (goto-char (point-max))
                            (forward-line -1)
                            (plist-get
                             (mu4e-message-at-point)
                             :message-id))))
            (mu4e-headers-search query nil nil t last-msg)
            ;; (mu4e-mark-handle-when-leaving)
            ;;(mu4e~headers-search-execute expr ignore-history)
            ;; (run-hook-with-args 'mu4e-headers-search-hook expr)
            ))))))
#+END_SRC

** Dynamic folders for refile etc. + special functions for gmail-relabeling
One could think that it would be reasonable to put this in the contexts, but no, these settings are mostly per message, and is therefore better dynamically matched on the current message.

The most complex part is for choosing refile folders, depending on account and special functions in ~aj/mu4e-refile-fns~.
#+BEGIN_SRC emacs-lisp
;; Utility function
;; In its current form kind of repetitive. But I could want special
;; conditions, so I will not abstract it more now.

(cl-defmacro aj/mu4e-msg-account (msg &key chalmers mejla ajf default gmail)
  (declare (indent 1))
  `(cond
    ((and ,msg (string-match-p "^/chalmers/" (mu4e-message-field ,msg :maildir)))
     ,chalmers)
    ((and ,msg ,mejla (string-match-p "^/mejla/" (mu4e-message-field ,msg :maildir)))
     ,mejla)
    ((and ,msg ,ajf (string-match-p "^/ajf/" (mu4e-message-field ,msg :maildir)))
     ,ajf)
    (t ,default)))

(setq mu4e-sent-folder "/chalmers/Skickat" ; gmail is set to delete sent mails
                                        ; (because it recreates them on the
                                        ; server from the mails sent via its
                                        ; smtp server.)
      mu4e-drafts-folder "/UTKAST" ; Don’t care about syncing these
                                        ; to the server
      mu4e-trash-folder (lambda (msg)
                          (aj/mu4e-msg-account msg
                            :chalmers "/chalmers/Borttagna objekt"
                            :mejla "/mejla/Papperskorgen"
                            :ajf "/ajf/Papperskorgen"))
      mu4e-refile-folder #'aj/mu4e-refile-folder)

(defun aj/mu4e-refile-folder (msg &optional force-choice)
  "Guess or offer to select a refile folder for MSG.
Chooses depending on account functions in ‘aj/mu4e-refile-fns’
No automatic guess if FORCE-CHOICE is non-nil."
  (let* ((user-has-chosen nil)
         (found
          (or (cl-loop for fn in aj/mu4e-refile-fns do
                       (when-let ((res (funcall fn msg)))
                         (cond
                          ((stringp res) (cl-return res))
                          ((listp res) (cl-return (prog1 (aj/mu4e-choose-refile (car ajrf) msg)
                                                    (setq user-has-chosen t)))))))
              (aj/mu4e-msg-account msg
                :chalmers "/chalmers/Arkiv"
                ;; Only for show, they get changed labels via custom action
                :mejla "/mejla/Alla mail"
                :ajf "/ajf/Alla mail"))))
    (if (and found
             (or user-has-chosen (not force-choice)))
        found
      (aj/mu4e-choose-refile found msg))))

(defvar aj/mu4e-helm-refile-history nil)
(defun aj/mu4e-choose-refile (startdir msg)
  "Choose a refile directory for MSG, starting search from STARTDIR"
  (let* ((subject (mu4e-message-field msg :subject))
         (subject (substring subject 0 (min 18 (length subject))))
         (case-fold-search t)
         (dir (helm-comp-read (format "Refile \"%s\":" subject)
                              (mu4e-get-maildirs) :initial-input startdir
                              :nomark t :must-match t :fuzzy t :case-fold t
                              :input-history aj/mu4e-helm-refile-history)))
    (unless (string= " " dir)
      dir)))

;; gmail is treated with labels instead of folder moves

(add-hook 'mu4e-mark-execute-pre-hook #'aj/mu4e-gmail-mark-pre-hook)
(remove-hook 'mu4e-mark-execute-pre-hook #'aj/mu4e-gmail-mark-pre-hook)


;; For forcing gmail-refiled messages to be removed from headers listing.
(defvar aj/mu4e-treat-as-move nil)

;; (defun aj/mu4e-gmail-mark-pre-hook (mark msg)
;;   (aj/mu4e-msg-account msg
;;     :mejla (aj/mu4e-gmail-retag mark msg)
;;     :ajf (aj/mu4e-gmail-retag mark msg)))

;; (defun aj/mu4e-gmail-retag (mark msg)
;;   (cond ;; ((equal mark 'refile)
;;    ;;  (setq aj/mu4e-treat-as-move t)
;;    ;;  (mu4e-action-retag-message msg "-\\Inbox"))
;;    ;; this moves to trash directory as well:
;;    ((equal mark 'trash) (mu4e-action-retag-message msg "-\\Inbox,-\\Starred"))
;;    ;; ((equal mark 'flag) (mu4e-action-retag-message msg "\\Starred"))
;;    ;; ((equal mark 'unflag) (mu4e-action-retag-message msg "-\\Starred"))
;;    ))


(advice-add 'mu4e-mark-execute-all :before (lambda () (setq aj/mu4e-treat-as-move nil)))

(setq mu4e-update-func #'aj/mu4e-headers-update-handler)
(defun aj/mu4e-headers-update-handler (msg is-move maybe-view)
  "Wrapper around ‘mu4e~headers-update-handler’ to remove
messages “refiled” in gmail accounts from the inbox listing."
  (let ((docid (plist-get msg :docid)))
    (mu4e~headers-update-handler
     msg
     (or
      (memq docid aj/mu4e-treat-as-move)
      is-move)
     maybe-view)
    (setq aj/mu4e-treat-as-move (delq docid aj/mu4e-treat-as-move))))

(defun aj/mu4e-retag-as-move (msg tagchange)
  (push (plist-get msg :docid) aj/mu4e-treat-as-move)
  (mu4e-action-retag-message msg tagchange))


;; Redefine refile to work with gmail
(setf (cl-getf (alist-get 'refile mu4e-marks) :action)
      #'aj/mu4e-refile-action)

(defun aj/mu4e-refile-action (docid msg target)
  (aj/mu4e-msg-account msg
    :mejla (aj/mu4e-retag-as-move msg "-\\Inbox")
    :ajf (aj/mu4e-retag-as-move msg "-\\Inbox")
    :chalmers (mu4e~proc-move docid
                              (mu4e~mark-check-target target)
                              "-N")
    :default (mu4e~proc-move docid
                             (mu4e~mark-check-target target)
                             "-N")))

;; Redefine move to trash
(setf (cl-getf (alist-get 'trash mu4e-marks) :action)
      #'aj/mu4e-trash-action)

(defun aj/mu4e-trash-action (docid msg target)
  "Move to trash, mark as read, possibly change gmail labels"
  (aj/mu4e-msg-account msg
    :mejla (mu4e-action-retag-message msg "-\\Inbox,-\\Starred,-\\Important")
    :ajf (mu4e-action-retag-message msg "-\\Inbox,-\\Starred,-\\Important"))
  
  (mu4e~proc-move docid (mu4e~mark-check-target target) "+T+S-N"))
#+END_SRC

** Marks
*** Custom marks
**** Add tag
#+BEGIN_SRC emacs-lisp
(defun aj/mu4e-choose-tag ()
  (let* ((face (lambda (tag)
                 (cons (propertize (concat (nth 2 tag) " " (car tag)) 'face `(:foreground ,(cadr tag)))
                       (car tag))))
         (tags (append
                ;; (mapcar face aj/mail-tags)
                (mapcar face aj/mu4e-gmail-labels)))
         (case-fold-search t))
    (helm-comp-read "Add tag:" tags :fuzzy t :case-fold t)))
(add-to-list 'mu4e-marks
             '(tag
               :char       ("g" . "🏷")
               :prompt     "tag"
               :ask-target aj/mu4e-choose-tag
               :action      (lambda (docid msg target)
                              (mu4e-action-retag-message msg (concat "+" target)))))

(mu4e~headers-defun-mark-for tag)
(define-key 'mu4e-headers-mode-map (kbd "ö") 'mu4e-headers-mark-for-tag)
(mu4e~view-defun-mark-for tag)
(define-key 'mu4e-view-mode-map (kbd "C-ö") 'mu4e-headers-mark-for-tag)
#+END_SRC

**** Refile + mark as read
At times, I can safely refile messages without reading them and at the same time marking them read.
#+BEGIN_SRC emacs-lisp
(add-to-list 'mu4e-marks
             '(refile-read
               :char ("f" . "⧐")
               :prompt "refile"
               :dyn-target (lambda (target msg)
                             (aj/mu4e-refile-folder msg))
               :action aj/mu4e-refile-read-action))

(defun aj/mu4e-refile-read-action (docid msg target)
  (aj/mu4e-msg-account msg
    :gmail '(progn
              (mu4e-action-retag-message msg "-\\Inbox")
              (mu4e~proc-move docid (mu4e~mark-check-target target) "-N+S"))
    :default '(mu4e~proc-move
               docid (mu4e~mark-check-target target) "-N+S")))


(mu4e~headers-defun-mark-for refile-read)
(define-key 'mu4e-headers-mode-map "ä" 'mu4e-headers-mark-for-refile-read)
#+END_SRC


*** Mark all duplicates in current view for deletion
#+BEGIN_SRC emacs-lisp
(defun aj/mu-mark-duplicates-for-deletion ()
  (interactive)
  (mu4e-headers-mark-for-each-if
   '(delete)
   #'aj/mu-message-is-duplicate))

(defun aj/mu-message-is-duplicate (msg &optional _param)
  (plist-get (mu4e-message-field msg :thread) :duplicate))

;; (defun aj/mu-find-stupid-duplicates ()
;;   (interactive)
;;   (let ((mu4e-headers-results-limit -1)
;;         (mu4e-headers-skip-duplicates nil)
;;         (mu4e-headers-found-hook '(aj/mu-mark-duplicates-for-deletion)))
;;     (mu4e-headers-search "maildir:/uu/* date:20171001..now ")))
#+END_SRC

*** COMMENT Directly applied marks :ARCHIVE:
Here I define my own variant of ~mu4e~headers-defun-mark-for~ which defines functions taking a prefix argument to optionally execute the mark immediately.
Some of the functions are redefined.
#+BEGIN_SRC emacs-lisp
(defmacro aj/mu4e~headers-defun-mark-for (mark)
  "Define a function mu4e~headers-mark-MARK, which takes a prefix argument to execute the mark immediately."
  (let ((funcname (intern (format "mu4e-headers-mark-for-%s" mark)))
        (docstring (format "Mark header at point with %s." mark)))
    `(progn
       (defun ,funcname (arg) ,docstring
              (interactive "P")
              (if arg
                  (let* ((msg (mu4e-message-at-point))
                         (markdescr (assq ',mark mu4e-marks))
                         (docid (plist-get msg :docid))
                         (ask-target (mu4e~mark-ask-target ',mark))
                         (target (mu4e~mark-get-dyn-target ',mark ask-target)))
                    (if markdescr
                        (funcall (plist-get (cdr markdescr) :action) docid msg target)
                      (mu4e-error "Unrecognized mark %S" ',mark)))
                (mu4e-headers-mark-and-next ',mark)))
       (put ',funcname 'definition-name ',mark))))

;; (aj/mu4e~headers-defun-mark-for refile)
;; (aj/mu4e~headers-defun-mark-for something)
;; (aj/mu4e~headers-defun-mark-for delete)
(aj/mu4e~headers-defun-mark-for flag)
;;  (aj/mu4e~headers-defun-mark-for move)
(aj/mu4e~headers-defun-mark-for read)
(aj/mu4e~headers-defun-mark-for trash)
(aj/mu4e~headers-defun-mark-for unflag)
;;  (aj/mu4e~headers-defun-mark-for untrash)
(aj/mu4e~headers-defun-mark-for unread)
;;  (aj/mu4e~headers-defun-mark-for action)
#+END_SRC


** Actions for toggling tags :ARCHIVE:
#+BEGIN_SRC emacs-lisp
(defvar aj/mu4e-tagchange-history nil)
(defun aj/mu4e-change-tags ()
  "Add or remove tags for current message"
  (interactive)
  (let ((msg (mu4e-message-at-point)))
    (when msg
      (mu4e-action-retag-message
       msg
       (read-from-minibuffer "Add or remove tags: "
                             nil nil nil 'aj/mu4e-tagchange-history)))))

;; Tag-toggle commands
(defun aj/mu4e-defun-toggle-tags (taglist)
  "Defines and binds functions for toggling up to ten tags in mu4e-headers"
  ;;(let ((cutlist (cl-subseq taglist 0 (min 10 (safe-length taglist)))))
  (dotimes (i (min 10 (safe-length taglist)))
    (let* ((tag (nth i taglist))
           (tagname (if (listp tag) (car tag) tag))
           (fname (intern (concat "aj/mu4e-toggle-tag-" tagname))))
      (eval
       `(defun ,fname () ,(format "Toggle the %s-tag in mu4e-headers-mode" tagname)
               (interactive)
               (let ((msg (mu4e-message-at-point)))
                 (when msg
                   (if (member ,tagname (mu4e-message-field msg :tags))
                       (mu4e-action-retag-message msg ,(concat "-" tagname))
                     (mu4e-action-retag-message msg ,(concat "+" tagname)))))))
      (bind-key (number-to-string (mod (1+ i) 10))
                fname
                mu4e-headers-mode-map))))

(aj/mu4e-defun-toggle-tags aj/mail-tags)
#+END_SRC

** Action for View in external browser
#+begin_src emacs-lisp
(add-to-list 'mu4e-view-actions '("View in external browser" . mu4e-action-view-in-browser))
#+end_src

** Contacts
#+begin_src emacs-lisp
(defvar aj/mu4e-contacts-exclude-pattern
  (regexp-opt
   '("no-reply" "noreply" "github.com" "donotreply" "newsletter" "launchpad.net"
     "notification")))

(setq mu4e-contact-process-function #'aj/mu4e-contact-process-function)

(defun aj/mu4e-contact-process-function (c)
  (unless (string-match-p aj/mu4e-contacts-exclude-pattern c)
    c))
#+end_src
* Provide statement
#+BEGIN_SRC emacs-lisp
(provide 'aj-mail-config)

;; Local Variables:
;; byte-compile-warnings: '(not free-vars)
;; End:
#+END_SRC

* Local Variables :ARCHIVE:

# Local Variables:
# eval: (progn (require 'use-package) (variable-pitch-mode -1))
# aj/inhibit-flyspell: t
# End:
