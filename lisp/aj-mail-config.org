#+TITLE: Mail config file (mu4e)
#+AUTHOR: Anders Johansson
#+PROPERTY: header-args :tangle yes :comments no :no-expand t
#+TODO: KOLLA TODO | DONE

* Lexical-binding
#+begin_src emacs-lisp
;; -*- lexical-binding: t -*-
#+end_src

* mail-config
** Basic settings for mailing and auth
I use ~msmtp~ together with the queueing script ~msmtpq~ (included with ~msmtp~).
#+begin_src emacs-lisp
(setq message-send-mail-function #'message-send-mail-with-sendmail
      message-interactive nil ;; because msmtpq always returns message
      ;; that is interpreted as fail
      sendmail-program "msmtpq"
      message-sendmail-extra-arguments '("--read-recipients")
      mu4e-action-tags-header "Keywords")
;; (require 'auth-source-pass)
;; (auth-pass-enable)
#+end_src

** Display mail queue (from ~msmtpq~) in modeline
#+begin_src emacs-lisp
(defvar aj/mail-queue-modeline "")
(add-to-list 'global-mode-string '(t aj/mail-queue-modeline))

(defun aj/update-mail-queue-modeline (_event)
  (let ((l (length (directory-files "~/.msmtp.queue" nil "\\.mail$"))))
    (setq aj/mail-queue-modeline
          (if (< 0 l)
              (format " %d%s " l
                      (all-the-icons-alltheicon "arrow-right" :v-adjust 0.02))
            ""))))

;; first run
(aj/update-mail-queue-modeline t)
;; update on file changes
(defvar aj/mail-queue-watch
  (file-notify-add-watch "~/.msmtp.queue" '(change) #'aj/update-mail-queue-modeline))
#+end_src

** Definition of contexts -- private settings
#+begin_src emacs-lisp
;;(shouldn’t this be a macro)
(defun aj/construct-match-func (emailregexp)
  "Return a match function which matches :to fields of passed msg
or the from field if we are in `mu4e-compose-mode' with
EMAILREGEXP"
  `(lambda (msg)
     (or
      (and msg (mu4e-message-contact-field-matches msg :to ,emailregexp))
      (and (not msg) (eq major-mode 'mu4e-compose-mode) (string-match-p ,emailregexp (message-fetch-field "from"))))))


(defcustom aj/mu4e-refile-fns nil
  "List of functions for determining correct refile dir for a message.

Each function receives a message MSG and should return a string
with maildir or a list with a maildir string, which means let the
user choose, starting at that path."
  :group 'aj
  :type '(repeat function))

(require 'aj-mail-config-private)
#+end_src

** My custom tags
#+begin_src emacs-lisp
(defcustom aj/mail-tags '()
  "Tags I use for emails. Each element is a list with the name
of the tag, the color, the symbol and (optionally) the default refile
folder (if this is wrapped as a list it means the starting point
for refile folder selection)"
  :group 'aj
  :type '(repeat
          (cons :tag "Tag"
                (string :tag "Name")
                (set :tag "Properties"
                     (cons :tag "Color" (const color) string)
                     (cons :tag "Symbol" (const symbol) string)
                     (cons :tag "Refile dir" (const refile)
                           (choice (string :tag "Refile folder")
                                   (list :tag "Start for refile selection" string)))))))

(defun aj/mu4e-refile-by-tag (msg)
  "Refile according to tags in MSG."
  (when-let ((tag (car-safe (mu4e-msg-field msg :tags)))
             (tl (alist-get tag aj/mail-tags nil nil #'equal)))
    (alist-get 'refile tl)))

(add-to-list 'aj/mu4e-refile-fns #'aj/mu4e-refile-by-tag)
#+end_src

** Symbols
#+begin_src emacs-lisp
(defconst aj/mu4e-symbols-override
  '((mu4e-headers-draft-mark      ("D" . "📝")) ;; ✒ ✏
    (mu4e-headers-flagged-mark    ("F" . "🏴"))
    (mu4e-headers-new-mark        ("N" . " "))
    (mu4e-headers-passed-mark     ("P" . "↪")) ;; ↪ "→"
    (mu4e-headers-replied-mark    ("R" . "↩")) ;; "→"
    (mu4e-headers-seen-mark       ("S" . " ")) ;; ✓ 🗸 ✔
    (mu4e-headers-trashed-mark    ("T" . "🗑")) ;; 🗑
    (mu4e-headers-attach-mark     ("a" . "📎"))
    (mu4e-headers-encrypted-mark  ("x" . "🔐"))
    (mu4e-headers-signed-mark     ("s" . "🔏"))
    (mu4e-headers-unread-mark    ("u" . "⚫ ") modus-themes-mark-symbol) ;; ★
    ))


;; not needed with the new :align-to fix for headers.
;; Only symbols that are in Ubuntu mono font, to avoid width problems
;; (defconst aj/mu4e-symbols-override
;;   '((mu4e-headers-draft-mark     . ("D" . "□")) ;; ✒ ✏
;;     (mu4e-headers-flagged-mark   . ("F" . "†"))
;;     (mu4e-headers-new-mark       . ("N" . " "))
;;     (mu4e-headers-passed-mark    . ("P" . "»")) ;; ↪ "→"
;;     (mu4e-headers-replied-mark   . ("R" . "«")) ;; "→"
;;     (mu4e-headers-seen-mark      . ("S" . "")) ;; ✓ 🗸 ✔
;;     (mu4e-headers-trashed-mark   . ("T" . "∏")) ;; 🗑
;;     (mu4e-headers-attach-mark    . ("a" . "■"))
;;     (mu4e-headers-encrypted-mark . ("x" . "🔐"))
;;     (mu4e-headers-signed-mark    . ("s" . "🔏"))
;;     (mu4e-headers-unread-mark    . ("u" . "•")) ;; ★
;;     ))


(cl-loop for (var (letter . symbol) face) in aj/mu4e-symbols-override
         do (set var (cons letter (propertize symbol 'face (or face '(:weight normal))))))

(setq mu4e-headers-visible-flags
      '(seen unread replied passed attach encrypted signed draft flagged))
#+end_src

** Save-attachment, with open function suits me better
#+begin_src emacs-lisp
(define-key mu4e-view-mode-map [remap mu4e-view-save-attachments] #'aj/mu4e-view-save-attachments)
(define-key mu4e-view-mode-map "o" #'aj/mu4e-view-open-attachments)

(defun aj/mu4e-view-save-attachments (&optional arg open)
  "Save mime parts from current mu4e gnus view buffer."
  (interactive "P")
  (cl-assert (and (eq major-mode 'mu4e-view-mode)
                  (derived-mode-p 'gnus-article-mode)))
  (let* ((parts (mu4e~view-gather-mime-parts))
         (handles '())
         (files '())
         dir)
    (dolist (part parts)
      (let ((fname (or (cdr (assoc 'filename (assoc "attachment" (cdr part))))
                       (cl-loop for item in part
                                for name = (and (listp item) (assoc-default 'name item))
                                thereis (and (stringp name) name)))))
	    (when fname
	      (push `(,fname . ,(cdr part)) handles)
	      (push fname files))))
    (if files
        (progn
          (setq files (completing-read-multiple "Save part(s): " files)
                dir (if arg (read-directory-name "Save to directory: ") mu4e-attachment-dir))
          (cl-loop for (f . h) in handles
                   when (member f files)
                   do (let* ((file (expand-file-name f dir))
                             (file (if (file-exists-p file)
			                           (let (newname (count 1))
				                         (while (and
					                             (setq newname
					                                   (concat
						                                (file-name-sans-extension file)
						                                (format "(%s)" count)
						                                (file-name-extension file t)))
					                             (file-exists-p newname))
				                           (cl-incf count))
				                         newname)
			                         file)))
                        (mm-save-part-to-file h f)
                        (when open (consult-file-externally f)))))
      (mu4e-message "No attached files found"))))

(defun aj/mu4e-view-open-attachments (arg)
  (interactive "P")
  (aj/mu4e-view-save-attachments arg t))
#+end_src

** Add ons
*** org-mu4e
#+begin_src emacs-lisp
(use-package mu4e-org
  :straight nil
  :demand t)
#+end_src

*** mu4e-maildirs-extension :ARCHIVE:
#+begin_src emacs-lisp
(use-package mu4e-maildirs-extension
  :after mu4e
  :config (setq mu4e-maildirs-extension-use-bookmarks nil
                mu4e-maildirs-extension-toggle-maildir-key (kbd "TAB"))
  (mu4e-maildirs-extension-load))
#+end_src

*** helm-mu :ARCHIVE:
#+begin_src emacs-lisp
(use-package helm-mu
  :commands (helm-mu helm-mu-contacts)
  :config (require 'mu4e-headers)
  (bind-key "S" #'helm-mu mu4e-main-mode-map))
#+end_src

*** mu4e-crm-contacts
Insert contacts with completing-read-multiple
https://gitlab.com/andersjohansson/mu4e-crm-contacts
#+begin_src emacs-lisp
(use-package mu4e-crm-contacts
  :straight (:depth full :host gitlab :repo "andersjohansson/mu4e-crm-contacts")
  :bind (:map mu4e-compose-mode-map
              ("<backtab>" . mu4e-crm-contacts-insert))
  :after mu4e-compose)
#+end_src

*** mu4e-alert :ARCHIVE:
Only display unread count in modeline
#+begin_src emacs-lisp
(use-package mu4e-alert
  :after mu4e
  :custom (mu4e-alert-set-window-urgency nil)
  :config
  (mu4e-alert-enable-mode-line-display)

  ;; (mu4e-alert-set-default-style 'notifications)
  ;; (defun aj/open-mu4e-unread (&rest _args)
  ;;   (if-let (window
  ;;            (cl-loop with res = nil
  ;;                     for buffer in (list mu4e~headers-buffer mu4e~view-buffer mu4e~main-buffer-name)
  ;;                     if (setq res (and buffer (get-buffer-window buffer t))) return res))
  ;;       (progn
  ;;         (select-frame-set-input-focus (window-frame window))
  ;;         (select-window window))
  ;;     (select-frame-set-input-focus (make-frame)))
  ;;   (mu4e-alert-view-unread-mails))

  ;; (defun mu4e-alert-notify-unread-messages (mails)
  ;;   "Display desktop notification for given MAILS."
  ;;   (let* ((mail-groups (funcall mu4e-alert-mail-grouper
  ;;                                mails))
  ;;          (sorted-mail-groups (sort mail-groups
  ;;                                    mu4e-alert-grouped-mail-sorter))
  ;;          (notifications (mapcar (lambda (group)
  ;;                                   (funcall mu4e-alert-grouped-mail-notification-formatter
  ;;                                            group
  ;;                                            mails))
  ;;                                 sorted-mail-groups)))
  ;;     (dolist (notification (cl-subseq notifications 0 (min 5 (length notifications))))
  ;;       (notifications-notify :body (plist-get notification :body)
  ;;                             :title (plist-get notification :title)
  ;;                             :actions '("default" "Open mails")
  ;;                             :on-action 'aj/open-mu4e-unread
  ;;                             :category "mu4e-alert"))
  ;;     (when notifications
  ;;       (mu4e-alert-set-window-urgency-maybe))))

  ;; (defun mu4e-alert-notify-unread-messages-count (mail-count)
  ;;   "Display desktop notification for given MAIL-COUNT."
  ;;   (when (not (zerop mail-count))
  ;;     (notifications-notify :body (funcall mu4e-alert-email-count-notification-formatter
  ;;                                          mail-count)
  ;;                           :title mu4e-alert-email-count-title
  ;;                           :actions '("default" "Open mails")
  ;;                           :on-action 'aj/open-mu4e-unread
  ;;                           :category "mu4e-alert")))
  )
#+end_src

*** mu4e-query-helper
Some completion for searching.
Available at: https://gitlab.com/andersjohansson/mu4e-query-helper

#+begin_src emacs-lisp
(use-package mu4e-query-helper
  :straight (:depth full :host gitlab :repo "andersjohansson/mu4e-query-helper")
  :after mu4e-headers
  :bind (:map mu4e-headers-mode-map
		      ("s" . mu4e-query-helper-search)
		      ("S" . mu4e-query-helper-search-edit)))
#+end_src

** Contact handling
*** LDAP (EUDC)
#+begin_src emacs-lisp
(with-eval-after-load 'mu4e-compose
  (bind-key "C-c C-ä" #'eudc-expand-inline mu4e-compose-mode-map))

(setq eudc-server-hotlist
      '(("ldap://localhost:1389" . ldap)))
(eudc-set-server "ldap://localhost:1389" 'ldap)
(setq eudc-expansion-overwrites-query t)

(defun aj/display-eudc-info-at-point ()
  (interactive)
  (if-let ((email (or (get-text-property (point) 'email)
                      (thing-at-point 'email t))))
      (aj/display-eudc-info-other-buffer (s-chop-prefix "<" (s-chop-suffix ">" email)))
    (user-error "No address found at point")))

;;TODO, try to parse address around point also ^

(defvar aj/interesting-ldap-fields '(cn title department mail telephonenumber mobile uid manager))

(dolist (i '((title . "Title")
             (department . "Institution")
             (mail . "Mail")
             (mobile . "Mobil")
             (uid . "ID")
             (manager . "Chef")))
  (add-to-list 'eudc-user-attribute-names-alist i))

(defun aj/display-eudc-info-other-buffer (email)
  (interactive "sEmail: ")
  (if-let ((results (eudc-query `((mail . ,email)))))
      (let ((buf (get-buffer-create "*aj-eudc*")))
        (unless (eq buf (current-buffer))
          (view-buffer-other-window buf)
          (with-current-buffer buf
            (let* ((inhibit-read-only t)
                   (fields (cl-loop for f in aj/interesting-ldap-fields
                                    collect
                                    (cons f (eudc-format-attribute-name-for-display f))))
                   (fieldlength (cl-loop for f in fields maximize (length (cdr f)))))
              (erase-buffer)
              (cl-loop for result in results
                       do
                       (cl-loop for f in fields
                                do
                                (when-let (ff (alist-get (car f) result))
                                  (eudc-print-record-field
                                   (cons (cdr f)
                                         (decode-coding-string ff 'utf-8))
                                   fieldlength))
                                )
                       (insert "\n"))))))
    (user-error "No results found for address %s" email)))


;; TODO. Gör "Chef", klickbar. Kanske går att göra med en lämplig
;; funktion för den (och för id, men det är nog mer meningslöst) i:
;; eudc-attribute-display-method-alist
#+end_src

** View mode settings
*** Standard settings
#+begin_src emacs-lisp
(add-hook 'mu4e-view-mode-hook #'variable-pitch-mode)
(add-hook 'mu4e-view-mode-hook #'visual-line-mode)
;; with visual-line-mode, no need to fill headers
(setq mu4e-view-fill-headers nil)

;; (add-to-list 'mu4e-view-actions '("Webkit-widget" . mu4e-action-view-with-xwidget))
(setq mu4e-html2text-command 'mu4e-shr2text)
#+end_src

*** Clean up headers in gnus-view, shorten addresses
It is good to be able to see that the address we get an email from is correct, but we don’t need to see the full address. This little patching to ~mu4e~view-construct-contacts-header~  displays the domain name or possibly a short symbol fetched from the list ~aj/mail-domain~.

Secure and economical.


#+begin_src emacs-lisp
(advice-add 'mu4e~view-render-buffer :after #'aj/article-prettify-addresses)

(defmacro aj/with-article-narrowed-to-header (header &rest body)
  "If HEADER field is found, execute BODY with buffer narrowed to it."
  (declare (indent 1))
  `(let ((case-fold-search t)
         ;; start end
         )
     (article-narrow-to-head)
     (when
         (re-search-forward (concat "^" ,header ": ") nil t)
       (narrow-to-region
        (point)
        (progn
          (forward-line 1)
          (if (re-search-forward "^[^ \n\t]" nil t)
	          (1- (point-at-bol))
            (point-max))))
       ,@body)
     (widen)))

(defun aj/article-prettify-addresses (&rest _ignore)
  "Remove line-breaks in address headers and prettify adresses."
  (save-excursion
    (save-restriction
      (let ((inhibit-read-only t))
        (cl-loop for (h . fun) in '(("From" . gnus-button-reply)
                                    ("To" . gnus-msg-mail)
                                    ("CC" . gnus-msg-mail))
                 do
                 (aj/with-article-narrowed-to-header h
                   (let ((new (aj/prettify-address-header
                               (buffer-substring-no-properties
                                (point-min) (point-max))
                               fun)))
                     (delete-region (point-min) (point-max))
                     (insert new))
                   (put-text-property (point-min) (1- (point-max))
                                      'wrap-prefix
                                      `(space :align-to ,(+ 2 (length h))))))))))

(defun aj/prettify-address-header (addresses &optional gnus-callback)
  "Prettify ADDRESSES string, make buttons using GNUS-CALLBACK function."
  (let (gnus-article-button-face
        ;; A hack for making mail-header-parse-addresses work with an
        ;; already decoded (non-ascii) list of addresses. Otherwise
        ;; names like ”Elin Ågren” gets "translated" to “Elin gren”,
        ;; because ‘ietf-drums-parse-address’ assumes first letters in
        ;; name-words should be ascii (but not the full string, which
        ;; is why “Hrvoje Nikšić <hniksic@srce.hr>”, given in the
        ;; example in Info node `(emacs-mime)Interface Functions',
        ;; works.
        (ietf-drums-atext-token (concat ietf-drums-atext-token "[:alpha:]")))
    (string-join
     (cl-loop for (email . name) in (mail-header-parse-addresses addresses)
              collect
              (with-temp-buffer
                (insert (if name
                            (format "%s%s"
                                    (propertize name 'face 'message-header-cc)
                                    (aj/mu4e-mail-domain-symbol email))
                          email))
                (gnus-article-add-button (point-min) (point-max) gnus-callback
                                         (if name
                                             (format "%s <%s>" name email)
                                           email))
                (buffer-string)))
     ", ")))


(defun aj/mu4e-mail-domain-symbol (email)
  (let ((maildomain (cadr (split-string email "@")))
        (mailstring (concat "<" email ">")))
    (cl-loop for (d . s) in aj/mail-domains
             when (string-match-p d maildomain)
             return
             (cond
              ((null s) (propertize (concat " " mailstring) 'display ""))
              ((stringp s)
               (propertize (concat " " mailstring) 'display
                           (concat " " (propertize s 'face 'aj/shadow-fringe))))
              ((listp s)
               (concat " "
                       (propertize mailstring
                                   'display
                                   (create-image
                                    (car s) nil nil
                                    :height (round (* (or (cadr s) 0.8)
                                                      (line-pixel-height)))
                                    :ascent 'center)))
               ))
             finally return
             (propertize
              (concat " " mailstring)
              'display
              (propertize (concat " (" maildomain ")") 'face 'shadow)))))

(defcustom aj/mail-domains nil
  "Alist of mappings between regexps for an email domain and display string.

If found, the display string is shown instead of the full domain when displaying emails in mu4e.
The display string can also be a list with a path to an image.
Examples:
((\"chalmers.se$\" . \"🅒\")
 (\"uu.se$\" . \"🅤\")))
"
  :group 'aj
  :type '(alist :key-type regexp :value-type (choice string (const nil) (list file))))
#+end_src

*** View shortened addresses :ARCHIVE:
It is good to be able to see that the address we get an email from is correct, but we don’t need to see the full address. This little patching to ~mu4e~view-construct-contacts-header~  displays the domain name or possibly a short symbol fetched from the list ~aj/mail-domain~.

Secure and economical.

#+begin_src emacs-lisp
(setq mu4e-view-fields '(:from :to :cc :date :maildir :mailing-list :tags
                               :attachments :signature :decryption :subject))

(defface aj/mu4e-header-subject-face '((t . (:height 1.2 :inherit (mu4e-highlight-face))))
  "Face for subject in ‘mu4e-view’")

(setq mu4e-view-show-addresses t)

(el-patch-feature mu4e-view-old)
(with-eval-after-load 'mu4e-view-old
  (el-patch-defun mu4e~view-construct-contacts-header (msg field)
    "Add a header for a contact field (ie., :to, :from, :cc, :bcc)."
    (mu4e~view-construct-header
     field
     (mapconcat
      (lambda(c)
        (let* ((name (when (car c)

                       (replace-regexp-in-string "[[:cntrl:]]" "" (car c))))
               (email (when (cdr c)
                        (replace-regexp-in-string "[[:cntrl:]]" "" (cdr c))))
               (short (el-patch-wrap 1 2
                        (propertize
                         (or name email)  ;; name may be nil
                         'face 'mu4e-contact-face)))
               (long (if name
                         (el-patch-swap
                           (format "%s <%s>" name email)
                           (format "%s%s"
                                   (propertize name 'face 'mu4e-contact-face)
                                   (aj/mu4e-mail-domain-symbol email)))
                       email)))
          (propertize
           (if mu4e-view-show-addresses long short)
           'long long
           'short short
           'email email
           'keymap mu4e-view-contacts-header-keymap
           (el-patch-remove 'face 'mu4e-contact-face)
           'mouse-face 'highlight
           'help-echo (format "<%s>\n%s" email
                              "[mouse-2] or C to compose a mail for this recipient"))))
      (mu4e-message-field msg field) ", ") t))

  (el-patch-defun mu4e~view-construct-header (field val &optional dont-propertize-val)
    "Return header field FIELD (as in `mu4e-header-info') with value
VAL if VAL is non-nil. If DONT-PROPERTIZE-VAL is non-nil, do not
add text-properties to VAL."
    (let* ((info (cdr (assoc field
                             (append mu4e-header-info mu4e-header-info-custom))))
           (key (plist-get info :name))
           (val (if val (propertize val 'field 'mu4e-header-field-value
                                    'front-sticky '(field))))
           (help (plist-get info :help)))
      (if (and val (> (length val) 0))
          (with-temp-buffer
            (insert (propertize (el-patch-swap
                                  (concat key ":")
                                  (concat (if (< 7 (length key))
                                              (concat (substring key 0 6) ".")
                                            key)
                                          ":"))
                                'field 'mu4e-header-field-key
                                'front-sticky '(field)
                                'keymap mu4e-view-header-field-keymap
                                'face 'mu4e-header-key-face
                                'help-echo help)
                    (el-patch-swap " " (propertize " " 'display '(space :align-to 7)))
                    (el-patch-wrap 1 2
                      (propertize
                       (if dont-propertize-val
                           val
                         (propertize val 'face (if (eq field :subject)
                                                   'aj/mu4e-header-subject-face
                                                 'mu4e-header-value-face)))
                       'wrap-prefix '(space :align-to 7)))
                    (el-patch-swap "\n" (propertize "\n" 'line-spacing 0.1)))
            (when mu4e-view-fill-headers
              ;; temporarily set the fill column <margin> positions to the right, so
              ;; we can indent the following lines correctly
              (let* ((margin 1)
                     (fill-column (max (- fill-column margin) 0)))
                (fill-region (point-min) (point-max))
                (goto-char (point-min))
                (while (and (zerop (forward-line 1)) (not (looking-at "^$")))
                  (indent-to-column margin))))
            (buffer-string))
        ""))))

(defun aj/mu4e-mail-domain-symbol (email)
  (let ((maildomain (cadr (split-string email "@")))
        (mailstring (concat "<" email ">")))
    (cl-loop for (d . s) in aj/mail-domains
             when (string-match-p d maildomain)
             return
             (cond
              ((null s) (propertize (concat " " mailstring) 'display ""))
              ((stringp s)
               (propertize (concat " " mailstring) 'display
                           (concat " " (propertize s 'face 'aj/shadow-fringe))))
              ((listp s)
               (concat " "
                       (propertize mailstring
                                   'display
                                   (create-image
                                    (car s) nil nil
                                    :height (round (* (or (cadr s) 0.8)
                                                      (line-pixel-height)))
                                    :ascent 'center)))
               ))
             finally return
             (propertize
              (concat " " mailstring)
              'display
              (propertize (concat " (" maildomain ")") 'face 'shadow)))))


;; (defun aj/mu4e-mail-domain-symbol (email)
;;   (let ((maildomain (cadr (split-string email "@")))
;;         (size (round (* 0.9 (line-pixel-height)))))
;;     (propertize (concat "<" email ">")
;;                 'display
;;                 (cl-loop for (d . s) in aj/mail-domains
;;                          when (string-match-p d maildomain)
;;                          return
;;                          (if (stringp s)
;;                              (propertize s 'face 'aj/shadow-fringe)
;;                            (create-image (car s) nil nil :height size :ascent 'center))
;;                          finally return (propertize (concat "(" maildomain ")") 'face 'shadow)))))

(defcustom aj/mail-domains nil
  "Alist of mappings between regexps for an email domain and display string.

If found, the display string is shown instead of the full domain when displaying emails in mu4e.
The display string can also be a list with a path to an image.
Examples:
((\"chalmers.se$\" . \"🅒\")
 (\"uu.se$\" . \"🅤\")))
"
  :group 'aj
  :type '(alist :key-type regexp :value-type (choice string (const nil) (list file))))



;;; do this for gnus-view
;; (add-to-list 'gnus-header-button-alist
;;              '("^\\(From\\|Reply-To\\):" ": *\\(.+\\)$"
;;                1 (>= gnus-button-message-level 0) compose-mail 1)
;;              t)

;; (add-to-list 'gnus-header-button-alist
;;              '("^\\(Cc\\|To\\):" "[^ \t\n,]+"
;;                0 (>= gnus-button-message-level 0) compose-mail 0)
;;              t)

;; För att matcha Namn namn <epost>. Typ..

;; "\\(\"?\\(\\([_[:alnum:]]+\\)\\b.*\\b\\)\"?[[:space:]]\\)?<?\\([^[:space:]]+@[^[:space:]]+\\.[^[:space:]]+\\)>?"

;; typ funkande pcre: (?:(?:"?((\w+)\b.*\b)"?)\s)?(?:(?:<?((\S+)@((\S+)\.\S+))>?))

;; (setq gnus-header-button-alist
;;       '(("^\\(References\\|Message-I[Dd]\\|^In-Reply-To\\):" "<[^<>]+>" 0
;;          (>= gnus-button-message-level 0)
;;          gnus-button-message-id 0)
;;         ("^\\(From\\|Reply-To\\):" ": *\\(.+\\)$" 1
;;          (>= gnus-button-message-level 0)
;;          gnus-button-reply 1)
;;         ("^\\(Cc\\|To\\):" "[^
;; <>,()\"]+@[^
;; <>,()\"]+" 0
;; (>= gnus-button-message-level 0)
;; gnus-msg-mail 0)
;;         ("^X-[Uu][Rr][Ll]:" gnus-button-url-regexp 0
;;          (>= gnus-button-browse-level 0)
;;          browse-url 0)
;;         ("^Subject:" gnus-button-url-regexp 0
;;          (>= gnus-button-browse-level 0)
;;          browse-url 0)
;;         ("^[^:]+:" gnus-button-url-regexp 0
;;          (>= gnus-button-browse-level 0)
;;          browse-url 0)
;;         ("^OpenPGP:.*url=" gnus-button-url-regexp 0
;;          (>= gnus-button-browse-level 0)
;;          gnus-button-openpgp 0)
;;         ("^[^:]+:" "\\bmailto:\\([-a-z.@_+0-9%=?&/]+\\)" 0
;;          (>= gnus-button-message-level 0)
;;          gnus-url-mailto 1)
;;         ("^[^:]+:" "\\(<\\(url: \\)?\\(nntp\\|news\\):\\([^>
;;  ]*\\)>\\)" 1
;;   (>= gnus-button-message-level 0)
;;   gnus-button-message-id 4)))



;; (setq gnus-header-button-alist
;;       '(("^\\(References\\|Message-I[Dd]\\|^In-Reply-To\\):" "<[^<>]+>" 0
;;          (>= gnus-button-message-level 0)
;;          gnus-button-message-id 0)
;;         ("^X-[Uu][Rr][Ll]:" gnus-button-url-regexp 0
;;          (>= gnus-button-browse-level 0)
;;          browse-url 0)
;;         ("^Subject:" gnus-button-url-regexp 0
;;          (>= gnus-button-browse-level 0)
;;          browse-url 0)
;;         ("^[^:]+:" gnus-button-url-regexp 0
;;          (>= gnus-button-browse-level 0)
;;          browse-url 0)
;;         ("^OpenPGP:.*url=" gnus-button-url-regexp 0
;;          (>= gnus-button-browse-level 0)
;;          gnus-button-openpgp 0)
;;         ("^[^:]+:" "\\bmailto:\\([-a-z.@_+0-9%=?&/]+\\)" 0
;;          (>= gnus-button-message-level 0)
;;          gnus-url-mailto 1)
;;         ("^[^:]+:" "\\(<\\(url: \\)?\\(nntp\\|news\\):\\([^>
;;  ]*\\)>\\)" 1
;;   (>= gnus-button-message-level 0)
;;   gnus-button-message-id 4)
;;         ("^\\(Cc\\|To\\):" "\\([^,]+\\),?"
;;          0 (>= gnus-button-message-level 0) compose-mail 0)
;;         ))



;; (defun aj/gnus-article-fold-adresses ()
;;   (interactive)
;;   (let ((mail-re (concat " " thing-at-point-email-regexp)))
;;     (save-excursion
;;       (gnus-with-article-headers
;;         (cl-loop
;;          for h in '("From:" "To:" "Cc:")
;;          do
;;          (goto-char (point-min))
;;          (when (search-forward h nil t)
;;            (while (search-forward-regexp mail-re (point-at-eol) t)
;;              (let* ((disp-beg (1+ (match-beginning 0)))
;;                     (disp-end (match-end 0))
;;                     (maildomain (substring (cadr (split-string (match-string 0) "@")) 0 -1 ))
;;                     (disp (cl-loop
;;                            for (d . s) in aj/mail-domains
;;                            when (string-match-p d maildomain)
;;                            return
;;                            (cond
;;                             ((null s)
;;                              (setq disp-beg (1- disp-beg))
;;                              "")
;;                             ((stringp s)
;;                              (propertize s 'face 'aj/shadow-fringe))
;;                             ((listp s)
;;                              (create-image
;;                               (car s) nil nil
;;                               :height (round (* (or (cadr s) 0.8)
;;                                                 (line-pixel-height)))
;;                               :ascent 'center)))
;;                            finally return
;;                            (propertize (concat "(" maildomain ")") 'face 'shadow))))
;;                (put-text-property disp-beg disp-end 'display disp)))))))))


;; (defvar aj/mu4e-gnus-treatment-function-alist
;;   '((gnus-treat-buttonize-head gnus-article-add-buttons-to-head)
;;     (gnus-treat-highlight-headers gnus-article-highlight-headers)))

;; (defun mu4e~view-gnus-display-mime (msg)
;;   "Same as `gnus-display-mime' but add a mu4e headers to MSG."
;;   (lambda (&optional ihandles)
;;     (gnus-display-mime ihandles)
;;     (unless ihandles
;;       (save-restriction
;;         (article-goto-body)
;;         (forward-line -1)
;;         (narrow-to-region (point) (point))
;;         ;; (dolist (field mu4e-view-fields)
;;         ;;   (let ((fieldval (mu4e-message-field msg field)))
;;         ;;     (cl-case field
;;         ;;       ((:path :maildir :user-agent :mailing-list :message-id)
;;         ;;        (mu4e~view-gnus-insert-header field fieldval))
;;         ;;       ((:flags :tags)
;;         ;;        (let ((flags (mapconcat (lambda (flag)
;;         ;;                                  (if (symbolp flag)
;; 	    ;;                                      (symbol-name flag)
;; 	    ;;                                    flag)) fieldval ", ")))
;;         ;;          (mu4e~view-gnus-insert-header field flags)))
;;         ;;       (:size (mu4e~view-gnus-insert-header
;;         ;;               field (mu4e-display-size fieldval)))
;;         ;;       ((:subject :to :from :cc :bcc :from-or-to :date :attachments
;;         ;;                  :signature :decryption)) ; handled by Gnus
;;         ;;       (t
;;         ;;        (mu4e~view-gnus-insert-header-custom msg field))
;;         ;;       )))
;;         (let ((gnus-treatment-function-alist
;;                aj/mu4e-gnus-treatment-function-alist))
;;           (gnus-treat-article 'head))))))
#+end_src

** Command for quick check of new mails
#+begin_src emacs-lisp
;;(defvar aj/mu4e-get-mail-command-quick "mbsync --new -qq uu-inbox gmail-inbox ajf-inbox")
(defvar aj/mu4e-get-mail-command-quick "aj-mailsync-quick")

(defun aj/mu4e-update-mail-and-index (full?)
  (interactive "P")
  (if full?
      (mu4e-update-mail-and-index t)
    (let ((mu4e-get-mail-command aj/mu4e-get-mail-command-quick))
      (mu4e-update-mail-and-index t))))

(bind-key "C-c C-u" #'aj/mu4e-update-mail-and-index mu4e-headers-mode-map)
#+end_src

** Composing and sending

*** Remove ~Sv:~, ~Aw:~ or other localized variants of ~Re:~ when replying.
This is used in ~message-strip-subject-re~, which cleans the subject up before replying.
#+begin_src emacs-lisp
(setq message-subject-re-regexp "^[ 	]*\\(\\(?:A[Ww]\\|R\\(?:EF\\|ef\\|[Ee]\\)\\|S[Vv]\\)\\(\\[[0-9]*\\]\\)* ?:[ 	]*\\)*[ 	]*")

;; generated by (regexp-opt '("Re" "RE" "Sv" "SV" "REF" "Ref" "AW" "Aw"))
#+end_src

*** Format=flowed, but with long lines
As most clients (outlook etc.) don’t support format=flowed correctly anyway. Sending as long lines as possible will mostly make it look ok.
https://vxlabs.com/2019/08/25/format-flowed-with-long-lines/
#+begin_src emacs-lisp
(setq mu4e-compose-format-flowed t
      fill-flowed-encode-column 998)
#+end_src

*** Some compose settings
#+begin_src emacs-lisp
(setq mail-user-agent 'mu4e-user-agent
      mu4e-compose-hidden-headers '("^Face:" "^X-Face:" "^X-Draft-From:" "^User-agent:" "References:"))

;; in case write is invoked before mu4e is loaded
(add-hook 'mu4e-compose-pre-hook #'mu4e--start)

;; (with-eval-after-load "helm-mode"
;;   (add-to-list 'helm-mode-no-completion-in-region-in-modes 'mu4e-compose-mode))
#+end_src

*** Make header separator a thin line
The line ~--text follows this line--~ that separaters headers from the message doesn’t look that nice. We can improve on it!
We set the face for it to a thin line with the same background and foreground.
Then, we also want it to extend to the end of line, so we’ll have to patch ~mu4e~draft-insert-mail-header-separator~ to insert an extra line break.

#+begin_src emacs-lisp
(set-face-attribute 'mu4e-compose-separator-face nil
                    :background "#e0e0e0" :foreground "#e0e0e0"
                    :height 0.2 :box nil :extend t)
(el-patch-feature mu4e-draft)
(with-eval-after-load 'mu4e-draft
  (el-patch-defun mu4e~draft-insert-mail-header-separator ()
    "Insert `mail-header-separator' in the first empty line of the message.
`message-mode' needs this line to know where the headers end and
the body starts. Note, in `mu4e-compose-mode', we use
`before-save-hook' and `after-save-hook' to ensure that this
separator is never written to the message file. Also see
`mu4e-remove-mail-header-separator'."
    ;; we set this here explicitly, since (as it has happened) a wrong
    ;; value for this (such as "") breaks address completion and other things
    (set (make-local-variable 'mail-header-separator) "--text follows this line--")
    (put 'mail-header-separator 'permanent-local t)
    (save-excursion
      ;; make sure there's not one already
      (mu4e~draft-remove-mail-header-separator)
      (let ((sepa (propertize (el-patch-wrap 1 1 (concat mail-header-separator "\n"))
                              'intangible t
                              ;; don't make this read-only, message-mode
                              ;; seems to require it being writable in some cases
                              ;;'read-only "Can't touch this"
                              'rear-nonsticky t
                              'font-lock-face 'mu4e-compose-separator-face)))
        (widen)
        ;; search for the first empty line
        (goto-char (point-min))
        (if (search-forward-regexp "^$" nil t)
            (progn
              (replace-match sepa)
              ;; `message-narrow-to-headers` searches for a
              ;; `mail-header-separator` followed by a new line. Therefore, we
              ;; must insert a newline if on the last line of the buffer.
              (when (= (point) (point-max))
                (insert "\n")))
          (progn ;; no empty line? then prepend one
            (goto-char (point-max))
            (insert "\n" sepa)))))))
#+end_src

*** KOLLA Allow and handle context change while composing
I often open a compose buffer without checking the context. The functions below make sure that switching context in a compose buffer works as expected. A function to switch address and signature when switching context is defined. However, several compose buffers may be open at once, and this will only switch for the current buffer (which I believe is the most reasonable behaviour). To ensure that we don’t attempt to send a message with the wrong context active, a function to check if the context matches with the from address is added to ~message-send-hook~.
#+begin_src emacs-lisp
(defun aj/mu4e-compose-context-switch (&rest _ignore)
  "When switching context in a compose buffer, switch “from” and signature."
  (when (eq major-mode 'mu4e-compose-mode)
    (message-replace-header "From" (mu4e~draft-from-construct))
    (message-replace-header "Reply-to" mu4e-compose-reply-to-address)
    (setq-local message-signature mu4e-compose-signature)
    (setq aj/message-sig-cycle 0)
    (aj/message-remove-signature)
    (save-excursion (message-insert-signature))))

(advice-add 'mu4e-context-switch :after #'aj/mu4e-compose-context-switch)

(defun aj/message-remove-signature ()
  "Find and remove signature."
  (save-excursion
    (when (message-goto-signature)
      (forward-line -1)
      (delete-region (1- (point)) (point-max)))))

(defun aj/message-send-check-context ()
  "Check that from address and context matches, and ask to change if required.

This is to avoid making mistakes in trying to send the current
message from the wrong account"
  ;; this may be a too strict check
  (when (not
         (or
          (null mu4e-contexts)
          (string= (message-fetch-field "from")
                   (mu4e~draft-from-construct))))
    (let ((context (mu4e-context-determine nil nil)))
      (cond ((and context
                  (y-or-n-p
                   (format
                    "Attempt to send via mismatching context. Switch to [%s] and send? "
                    (mu4e-context-name context))))
             (mu4e-context-switch t (mu4e-context-name context)))
            ((not context)
             (mu4e-context-switch
              t
              (mu4e-context-name  ; throws an error if no context found:
               (mu4e~context-ask-user
                "Attempt to send via mismatching context! Send after switching to: "))))
            (t (signal 'quit nil))))))

(add-hook 'message-send-hook #'aj/message-send-check-context)
#+end_src

*** Signature cycling
I have long and "official" signatures defined for my accounts, but often I want to just include my name, or nothing at all. This function allows me to cycle through the signature set in the context (variable ~message-context~), a list of shorter ones, and localized signatures when writing in different languages (English and Swedish really).

Also commented below is a function for switching signature language automatically with guess-language. I found it too unpredictable however (for example when replying in a different language) and just switching manually gives better control.
#+begin_src emacs-lisp
(defvar aj/message-simple-signatures '((none . ""))
  "Alist of signature names (symbol) and signatures (strings).")
(defvar aj/mu4e-compose-localized-signatures nil
  "Alist of language symbols and signature strings.
Set in my private mail config, possibly with mu4e context.")

(defvar-local aj/message-sig-cycle 0)

(defun aj/message-signature-cycle ()
  (interactive)
  (let ((sigs (cl-remove nil
                         (cl-remove-duplicates
                          (append (list (cons 'initial message-signature))
                                  aj/message-simple-signatures
                                  aj/mu4e-compose-localized-signatures)
                          :test #'equal :key #'cdr :from-end t))))
    (setq aj/message-sig-cycle
          (mod (1+ aj/message-sig-cycle)
               (length sigs)))
    (aj/message-change-signature (nth aj/message-sig-cycle sigs) t)))

(bind-key "C-c C-p" #'aj/message-signature-cycle mu4e-compose-mode-map)

(cl-defun aj/message-change-signature ((name . sig) &optional show)
  (save-excursion
    (aj/message-remove-signature)
    (let ((message-signature sig))
      (unless (or (not sig) (string= message-signature ""))
        (message-insert-signature))
      (message "Switched to signature %s"
               (propertize (symbol-name name) 'face 'bold)))
    (when show
      ;; to be able to see what happens in a long message:
      (sit-for 0.6))))

;; Switch signature with guess-language?

;; (with-eval-after-load 'guess-language
;;   (add-to-list 'guess-language-after-detection-functions
;;                #'aj/message-switch-signature-language))

;; (defun aj/message-switch-signature-language (lang _beg _end)
;;   (when (eq major-mode 'mu4e-compose-mode)
;;     (aj/message-change-signature
;;      (alist-get lang aj/mu4e-compose-localized-signatures))))
#+end_src

*** Context cycling
I want to use a single binding to switch (cycle through) contexts when composing.
#+begin_src emacs-lisp
(defun aj/mu4e-cycle-contexts ()
  "Cycle through `mu4e-contexts'."
  (interactive)
  (when mu4e-contexts
    (let* ((names (mapcar #'mu4e-context-name mu4e-contexts))
           (currentname (ignore-errors (mu4e-context-name mu4e~context-current))))
      (mu4e-context-switch t
                           (nth
                            (mod (if currentname
                                     (1+ (cl-position currentname names :test #'equal))
                                   0)
                                 (length names))
                            names)))))

(bind-key "C-c C-i" #'aj/mu4e-cycle-contexts mu4e-compose-mode-map)
#+end_src

*** Ask for confirmation before sending mail
#+begin_src emacs-lisp
(setq message-confirm-send t)
#+end_src

*** Let flyspell only check relevant regions
#+begin_src emacs-lisp
(put 'mu4e-compose-mode 'flyspell-mode-predicate #'mail-mode-flyspell-verify)
#+end_src
**** Home grown  :ARCHIVE:
#+begin_src emacs-lisp
(defun aj/mu4e-compose-flyspell-ignore ()
  "Function used for `flyspell-generic-check-word-predicate' to ignore headers in message-mode"
  (or (and (message-in-body-p) (not (aj/message-in-signature-p)))
      (and (save-excursion (beginning-of-line)
                           (looking-at-p "^Subject: "))
           (not (org-in-regexp "Subject:")))))

(autoload 'org-in-regexp "org")

(defun aj/message-in-signature-p ()
  (save-excursion
    (save-match-data
      (re-search-backward message-signature-separator nil t))))

(put 'mu4e-compose-mode 'flyspell-mode-predicate #'aj/mu4e-compose-flyspell-ignore)
#+end_src
*** Identity switching in compose buffer :ARCHIVE:
#+begin_src emacs-lisp
(bind-keys
 :map mu4e-compose-mode-map
 ("C-c C-i" . aj/message-switch-uu-identity)
 ("C-c C-p" . aj/message-signature-cycle))

(defvar aj/message-current-uu-identity "Physics")

(defun aj/message-switch-uu-identity ()
  (interactive)
  (setq aj/message-current-uu-identity
        (if (string= aj/message-current-uu-identity "Physics")
            "Gender"
          "Physics")
        aj/message-sig-cycle 0)
  (let* ((cv (mu4e-context-vars
              (aj/mu4e-context-get-context
               aj/message-current-uu-identity)))
         (user-mail-address (cdr (assoc 'user-mail-address cv)))
         (message-signature-file (cdr (assoc 'message-signature-file cv)))
         (message-signature t))
    (save-excursion
      (aj/message-change-from (message-make-from))
      (aj/message-remove-signature)
      (message-insert-signature))))
#+end_src
*** Automatically refile message efter reply or forward :ARCHIVE:
When I have acted upon a message I refile it from the inbox. Replying or forwarding almost certainly means I want to do this.

I have never gotten this to work though.
#+begin_src emacs-lisp
;; (defvar aj/mu4e-rep-msg-tmp nil)
;; (defun aj/mu4e~compose-set-parent-flag (path)
;;  "Also refile the replied message to archive"
;;  (let ((buf (find-file-noselect path)))
;;    (when buf
;;      (with-current-buffer buf
;;        (message-narrow-to-headers-or-head)
;;        (let ((in-reply-to (message-fetch-field "in-reply-to"))
;;              (forwarded-from)
;;              (references (message-fetch-field "references"))
;;              (mu4e-view-func (lambda (msg) (setq aj/mu4e-rep-msg-tmp msg))))
;;          (unless in-reply-to
;;            (when references
;;              (with-temp-buffer ;; inspired by `message-shorten-references'.
;;                (insert references)
;;                (goto-char (point-min))
;;                (let ((refs))
;;                  (while (re-search-forward "<[^ <]+@[^ <]+>" nil t)
;;                    (push (match-string 0) refs))
;;                  ;; the last will be the first
;;                  (setq forwarded-from (first refs))))))
;;          ;; remove the <>
;;          (when (and in-reply-to (string-match "<\\(.*\\)>" in-reply-to))
;;            (mu4e~proc-view (match-string 1 in-reply-to))
;;            (mu4e--server-move (match-string 1 in-reply-to)
;;                            (and (accept-process-output mu4e~proc-process 1)
;;                                 (aj/mu4e-refile-folder aj/mu4e-rep-msg-tmp t))
;;                            "+R-N-F"))
;;          (when (and forwarded-from (string-match "<\\(.*\\)>" forwarded-from))
;;            (mu4e~proc-view (match-string 1 forwarded-from))
;;            (mu4e--server-move (match-string 1 forwarded-from)
;;                            (and (accept-process-output mu4e~proc-process 1)
;;                                 (aj/mu4e-refile-folder aj/mu4e-rep-msg-tmp t))
;;                            "+P-N-F"))))))
;;  (setq aj/mu4e-rep-msg-tmp nil))


;; variant:
;; (defun aj/mu4e~compose-set-parent-flag (path)
;;  "Also refile the replied message to archive"
;;  (let ((buf (find-file-noselect path)))
;;    (when buf
;;      (with-current-buffer buf
;;        (message-narrow-to-headers-or-head)
;;        (let ((in-reply-to (message-fetch-field "in-reply-to"))
;;              (forwarded-from)
;;              (references (message-fetch-field "references"))
;;              (mu4e-view-func (lambda (msg) (setq aj/mu4e-rep-msg-tmp msg))))
;;          (unless in-reply-to
;;            (when references
;;              (with-temp-buffer ;; inspired by `message-shorten-references'.
;;                (insert references)
;;                (goto-char (point-min))
;;                (let ((refs))
;;                  (while (re-search-forward "<[^ <]+@[^ <]+>" nil t)
;;                    (push (match-string 0) refs))
;;                  ;; the last will be the first
;;                  (setq forwarded-from (first refs))))))
;;          ;; remove the <>
;;          (when (and in-reply-to (string-match "<\\(.*\\)>" in-reply-to))
;;            (let ((msgid (match-string 1 in-reply-to)))
;;              (mu4e~proc-view msgid)
;;              ;; (accept-process-output mu4e~proc-process 10 nil)
;;              (message "AJ: %s" aj/mu4e-rep-msg-tmp)
;;              ;; (mu4e--server-move msgid
;;              ;;                 (and aj/mu4e-rep-msg-tmp
;;              ;;                      (aj/mu4e-refile-folder aj/mu4e-rep-msg-tmp t))
;;              ;;                 "+R-N-F")
;;              ))
;;          (when (and forwarded-from (string-match "<\\(.*\\)>" forwarded-from))
;;            (mu4e~proc-view (match-string 1 forwarded-from))
;;            ;;(accept-process-output mu4e~proc-process 1 nil t)
;;            (mu4e--server-move (match-string 1 forwarded-from)
;;                            (and aj/mu4e-rep-msg-tmp
;;                                 (aj/mu4e-refile-folder aj/mu4e-rep-msg-tmp t))
;;                            "+P-N-F"))))))
;;  (setq aj/mu4e-rep-msg-tmp nil))
;; (advice-add 'mu4e~compose-set-parent-flag :override #'aj/mu4e~compose-set-parent-flag)

#+end_src

*** Yank adressess
#+begin_src emacs-lisp
;; (defun aj/message-yank-adressess ()
;;   (interactive)
;;   (let* ((ck (current-kill 0))
;;          (cksp (split-string ck "\n" t "[ 	]+")))
;;     (if (< 1 (safe-length cksp))
;;         (insert (mapconcat 'substring-no-properties cksp ", "))
;;       (insert-for-yank ck))))

;; (bind-key "C-c M-y" #'aj/message-yank-adressess mu4e-compose-mode-map)

(define-key mu4e-compose-mode-map [remap yank] #'aj/message-yank-addressess)

(defun aj/message-yank-addressess ()
  "Yank addresses correctly if we are in address field, otherwise yank."
  (interactive)
  (if (save-excursion (beginning-of-line) (looking-at-p "\\(To\\|Cc\\Bcc\\):"))
      (let* ((ck (current-kill 0))
             (cksp (split-string ck "\n" t "[ 	]+")))
        (if (< 1 (safe-length cksp))
            (insert (mapconcat 'substring-no-properties cksp ", "))
          (insert-for-yank ck)))
    (yank)))
#+end_src

*** Don’t return to mu4e buffers when mail has been sent
I often invoke a compose buffer in a window where I’m doing something else, and when mu4e then wants to helpfully switch back to the headers buffer or something, my window config gets messed up. This is better.
#+begin_src emacs-lisp
(advice-add 'mu4e~switch-back-to-mu4e-buffer :override #'ignore)
#+end_src

*** Mail greetings
Quickly insert a "Hi NN" with correct name
#+begin_src emacs-lisp
(defvar reftex-cite-punctuation)
(defun aj/mail-insert-greeting (&optional firstname)
  "Insert a language dependent (informal) greeting when composing a mail.
Recipient names are fetched from the To field. Prefix-argument
FIRSTNAME greet only first recipient."
  (interactive "P")
  (require 'reftex-cite)
  (when-let ((names
              (save-excursion
                (save-restriction
                  (widen)
                  (message-narrow-to-headers-or-head)
                  (cl-loop for (name _email) in (mail-extract-address-components
                                                 (message-fetch-field "To" t) t)
                           collect (car (split-string name)))))))
    (let* ((sv (eq 'sv (aj/buffer-language-or-guess)))
           (reftex-cite-punctuation (if sv '(", " " och " "") '(", " " and " ""))))
      (insert
       (if sv "Hej" "Hi")
       " "
       (if firstname
           (car names)
         (reftex-format-names names 100))
       ",\n"))))

(defun aj/buffer-language-or-guess ()
  "Return symbol sv if we should write in Swedish, else assume english, en."
  (if ispell-current-dictionary
      (if (aj/writing-swedish-p) 'sv 'en)
    (guess-language-buffer)))

(bind-key "C-c C-å" #'aj/mail-insert-greeting 'mu4e-compose-mode-map)
#+end_src

*** Customize cite string
#+begin_src emacs-lisp
;; TODO, anropet till message-cite-original i mu4e-draft (vilken
;; funktion?) är ju helt verkningslöst då message-reply-buffer verkar
;; vara odefinierad (iaf vid forward). Kolla närmare
(with-eval-after-load 'mu4e-draft
  (defun aj/mu4e-draft-cite-original (fun origmsg)
    (let ((mu4e-view-show-addresses t)
          ;; (message-reply-buffer t)
          )
      (funcall fun origmsg)))
  (advice-add 'mu4e~draft-cite-original :around #'aj/mu4e-draft-cite-original)
  ;; customize the reply-quote-string
  (setq message-citation-line-format "On %A %-e %b %Y at %R, %f wrote:\n")
  ;; choose to use the formatted string, with some language guessing
  (setq message-citation-line-function #'aj/message-insert-formatted-citation-line)

  (autoload #'guess-language-buffer "guess-language")
  (defun aj/message-insert-formatted-citation-line (&rest args)
    "Guess language and maybe force date formats to Swedish, else English"
    (let* ((sv (eq 'sv (guess-language-buffer)))
           (system-time-locale (if sv "sv_SE" "C"))
           (message-citation-line-format
            (if sv
                "%a %-e %b %Y %R, skrev %f:\n"
              message-citation-line-format)))
      (apply #'message-insert-formatted-citation-line args))))
#+end_src

*** Attachments
**** Put attachments at end of buffer
From: http://mbork.pl/2015-11-28_Fixing_mml-attach-file_using_advice
#+begin_src emacs-lisp
(defun aj/mml-attach-file--go-to-eob (orig-fun &rest args)
  "Go to the end of buffer before attaching files."
  (save-excursion
    (save-restriction
      (widen)
      (goto-char (point-max))
      (search-backward-regexp message-signature-separator (- (point) 500) t) ;; 500 chars reasonable limit for signature
      (apply orig-fun args))))

(advice-add 'mml-attach-file :around #'aj/mml-attach-file--go-to-eob)
#+end_src

**** Use custom command to invert prefix argument logic of ~mml-attach-file~
#+begin_src emacs-lisp
(defun aj/mml-attach-file (arg)
  (interactive "P")
  (let ((current-prefix-arg (not arg)))
    (call-interactively #'mml-attach-file)))

(bind-key "C-c C-a" 'aj/mml-attach-file mu4e-compose-mode-map)
#+end_src

**** Attach with dired
#+begin_src emacs-lisp
(with-eval-after-load "dired"
  (require 'gnus-dired)
  ;; make the `gnus-dired-mail-buffers' function also work on
  ;; message-mode derived modes, such as mu4e-compose-mode
  (defun aj/gnus-dired-mail-buffers ()
    "Return a list of active message buffers."
    (let (buffers)
      (save-current-buffer
        (dolist (buffer (buffer-list t))
          (set-buffer buffer)
          (when (and (derived-mode-p 'message-mode)
                     (null message-sent-message-via))
            (push (buffer-name buffer) buffers))))
      (nreverse buffers)))
  (advice-add 'gnus-dired-mail-buffers :override #'aj/gnus-dired-mail-buffers)

  (setq gnus-dired-mail-mode 'mu4e-user-agent)
  (add-hook 'dired-mode-hook 'turn-on-gnus-dired-mode))
#+end_src

**** Attach via dropbox-link
#+begin_src emacs-lisp
(defun aj/copy-to-dropbox-return-link (file)
  "Copies a file to public dropbox folder and returns public url"
  (let ((newfile (expand-file-name (file-name-nondirectory file) "~/Dropbox/delning-publikt")))
    (copy-file file newfile 1)
    (aj/dropbox-get-link newfile)))

(defun aj/dropbox-get-link (filename)
  "Puts dropbox public link to FILENAME in kill ring.

Non-interactive use returns link"
  (interactive "f")
  (let ((link (replace-regexp-in-string
               "dl=0" "dl=1"
               (shell-command-to-string
                (format "dropbox-cli sharelink %s" (shell-quote-argument filename))))))
    (if (called-interactively-p)
        (kill-new link)
      link)))

(defun aj/mml-attach-file-dropbox-link ()
  "Attach file by inserting dropbox link."
  (interactive)
  (let ((file (mml-minibuffer-read-file "Dropbox link file: ")))
    (insert (aj/copy-to-dropbox-return-link file))))
#+end_src

**** Add a recipient filename to attachment at point
#+begin_src emacs-lisp
(defun aj/mml-add-attachment-recipient-filename ()
  "Add a recipient filename to attachment at point"
  (interactive)
  (save-excursion
    (goto-char (point-at-bol))
    (when (and (looking-at-p "<#part")
               (search-forward-regexp "filename=\"\\([^\"]+\\)\"" (point-at-eol) t))
      (goto-char (match-beginning 0))
      (when-let ((filename (read-string
                            "Recipient filename: "
                            (file-name-nondirectory
                             (substring-no-properties
                              (match-string 1))))))
        (insert (format "recipient-filename=\"%s\" " filename))))))
#+end_src

**** Warning when forgetting to include attachments
Adapted from https://www.topbug.net/blog/2016/12/09/attachment-reminder-in-emacs-message-mode/,
http://disq.us/p/158wrxo, and http://mbork.pl/2016-02-06_An_attachment_reminder_in_mu4e

#+begin_src emacs-lisp
(defcustom aj/message-attachment-intent-re
  (regexp-opt '("attached"
		        "attachment"
                "pdf"
                "bifogad"
                "bifogar"
                "bilaga"))
  "A regex which - if found in the message, and if there is no
attachment - should launch the no-attachment warning.")

(defun aj/message-says-attachment-p ()
  "Return t if the message suggests there can be an attachment."
  (save-excursion
    (mail-text)
    (save-match-data
      (let (search-result)
        (while
            (and (setq search-result
                       (re-search-forward
                        aj/message-attachment-intent-re nil t))
                 ;; old mu4e-cited-regexp
                 (org-match-line "^\\(\\([[:alpha:]]+\\)\\|\\( *\\)\\)\\(\\(>+ ?\\)+\\)")))
        search-result))))

(defun aj/message-has-attachment-p ()
  "Return t if the message has an attachment."
  (save-excursion
    (mail-text)
    (save-match-data
      (search-forward "<#part" nil t))))

(defun aj/message-pre-send-check-attachment ()
  (when (and (aj/message-says-attachment-p)
             (not (aj/message-has-attachment-p)))
    (unless
        (y-or-n-p "Är du säker på att du inte glömde en bilaga?!")
      (keyboard-quit))))

(add-hook 'message-send-hook 'aj/message-pre-send-check-attachment -50)

#+end_src

**** Detach attachments :ARCHIVE:
#+begin_src emacs-lisp
;;TODO, fixa! (kolla på mm- funktionerna (mime-biblioteket))
;; (defun aj/mu4e-remove-attachment (msg num)
;;   "Remove attachment."
;;   (let* ((attach (mu4e~view-get-attach msg num))
;;           (path (mu4e-msg-field msg :path))
;;           (filename (and attach (plist-get attach :name)))
;;           (cmd (format "remove-mime-attachment --filename=\"%s\" < \"%s\" > \"%s\".lock && mv \"%s\".lock \"%s\""
;;                        filename path path path path path path))
;;           ;; (cmd (format "altermime --input=%s --remove='%s'"  path filename))
;;           )
;;     (when (and filename
;;             (yes-or-no-p
;;          (format "Are you sure you want to remove '%s'?" filename)))
;;       (shell-command cmd "*SHELL_REMOVE_CMD*")
;;       (message cmd))))

;; (add-to-list 'mu4e-view-attachment-actions
;;   '("remove-attachment" . aj/mu4e-remove-attachment))

(defun aj/mu4e-detach-attachments (&optional msg)
  "Detach all files"
  (interactive)
  (let* ((msg (or msg (mu4e-message-at-point)))
         (count (hash-table-count mu4e~view-attach-map))
         (attachnums (mu4e-split-ranges-to-numbers "a" count))
         (attachdir "/home/aj/Hämtningar/mejl-extrakt/")
         ;; (bodytext (or (mu4e-message-field msg :body-txt)
         ;;               (mu4e-message-field msg :body-html)))
         ;; (textpart (cl-find-if
         ;;            (lambda (part)
         ;;              (and (not (mu4e-message-part-field part :attachment))
         ;;                   (member
         ;;                    (mu4e-message-part-field part :mime-type)
         ;;                    '("text/plain" "text/html"))))
         ;;              (mu4e-message-field msg :parts)))
         )
    (dolist (num attachnums)
      (let* ((att (mu4e~view-get-attach msg num))
             (fname  (plist-get att :name))
             (index (plist-get att :index))
             (retry t)
             fpath)
        (while retry
          (setq fpath (concat attachdir fname))
          (setq retry
                (and (file-exists-p fpath)
                     (not (y-or-n-p
                           (mu4e-format "Overwrite '%s'?" fpath))))))
        (mu4e~proc-extract
         'save (mu4e-message-field msg :docid)
         index mu4e-decryption-policy fpath)))))
#+end_src


*** Mail templates :ARCHIVE:
#+begin_src emacs-lisp
(defcustom aj/mu4e-templates-dir "~/.emacs.d/mu4e-templates"
  "Directory for mail templates"
  :type 'directory
  :group 'aj)

(defun aj/weekly-report-mail ()
  ""
  (interactive)
  ;; ((mu4e-compose-mode-hook
       ;;       (remq 'mu4e-helm-contact-hook-insert mu4e-compose-mode-hook))
       ;;      ;; (symbol-function 'mu4e~draft-newmsg-construct
       ;;      ;; #'aj/weekreport-msg-construct))
       ;;      )
  (mu4e~compose-handler 'new)
  (delete-region (point-min) (point-max))
  (insert (format (aj/read-string-from-file
                   (expand-file-name "weekly-report.eml"  aj/mu4e-templates-dir))
                  (aj/weekly-report-copy-link))))
#+end_src

** Headers settings

*** Thread folding :ARCHIVE:
#+begin_src emacs-lisp
(use-package mu4e-thread-folding
  :straight '(mu4e-thread-folding :host github :repo "rougier/mu4e-thread-folding")
  ;; :custom
  ;; (mu4e-thread-folding-root-prefix-position '(0 . 1))
  ;; (mu4e-thread-folding-root-folded-prefix-string ".")
  ;; (mu4e-thread-folding-root-unfolded-prefix-string ".")
  ;; (mu4e-thread-folding-child-prefix-position '(0 . 1))
  ;; (mu4e-thread-folding-child-prefix-string "⋮")
  :config
  ;; (add-to-list 'mu4e-header-info-custom
  ;;              '(:empty . (:name "Empty"
  ;;                                :shortname ""
  ;;                                :function (lambda (&rest _ignore) "  "))))

  ;; ;; should add to hook?
  (with-eval-after-load 'modus-operandi-theme
    ;; (set-face-attribute 'mu4e-thread-folding-root-unfolded-face nil
    ;;                     :background 'unspecified
    ;;                     :inherit 'modus-themes-nuanced-blue
    ;;                     :overline nil)
    ;; (set-face-attribute 'mu4e-thread-folding-root-folded-face nil)
    (set-face-attribute 'mu4e-thread-folding-root-unfolded-face nil :inherit 'shadow)
    (set-face-attribute 'mu4e-thread-folding-child-face nil :inherit 'shadow)
    )
  )


#+end_src

*** Variable pitch in mu4e-headers-mode
#+begin_src emacs-lisp
(setq mu4e-headers-precise-alignment t)
(add-hook 'mu4e-headers-mode-hook #'variable-pitch-mode)

(defun aj/mu4e-header-line-format ()
  "Empty header line"
  "")

(advice-add 'mu4e~header-line-format :override #'aj/mu4e-header-line-format)

(add-hook 'mu4e-headers-mode-hook #'aj/mu4e-remap-header-line-face)

(defun aj/mu4e-remap-header-line-face ()
  (face-remap-add-relative 'header-line
                           :foreground 'unspecified
                           :background 'unspecified
                           :inherit 'fringe
                           :height 0.5))


;; (defun aj/mu4e~header-line-format ()
;;   "Get the format for the header line."
;;   (let ((uparrow   (if mu4e-use-fancy-chars " ▲" " ^"))
;;         (downarrow (if mu4e-use-fancy-chars " ▼" " V")))
;;     (cons
;;      (propertize " " 'display '(space :align-to 0))
;;      ;; (make-string
;;      ;;  (+ mu4e~mark-fringe-len (floor (fringe-columns 'left t))) ?\s)
;;      (mapcar
;;       (lambda (item)
;;         (let* ((field (car item)) (width (cdr item))
;;                (info (cdr (assoc field
;;                                  (append mu4e-header-info mu4e-header-info-custom))))
;;                (require-full (plist-get info :require-full))
;;                (sortable (plist-get info :sortable))
;;                ;; if sortable, it is either t (when field is sortable itself)
;;                ;; or a symbol (if another field is used for sorting)
;;                (sortfield (when sortable (if (booleanp sortable) field sortable)))
;;                (help (plist-get info :help))
;;                ;; triangle to mark the sorted-by column
;;                (arrow
;;                 (when (and sortable (eq sortfield mu4e-headers-sort-field))
;;                   (if (eq mu4e-headers-sort-direction 'descending) downarrow uparrow)))
;;                (name (concat (plist-get info :shortname) arrow))
;;                (map (make-sparse-keymap)))
;;           (when require-full
;;             (mu4e-error "Field %S is not supported in mu4e-headers-mode" field))
;;           (when sortable
;;             (define-key map [header-line mouse-1]
;;               (lambda (&optional e)
;;                 ;; getting the field, inspired by `tabulated-list-col-sort'
;;                 (interactive "e")
;;                 (let* ((obj (posn-object (event-start e)))
;;                        (field
;;                         (and obj (get-text-property 0 'field (car obj)))))
;;                   ;; "t": if we're already sorted by field, the sort-order is
;;                   ;; changed
;;                   (mu4e-headers-change-sorting field t)))))
;;           (concat
;;            (propertize
;;             (if width
;;                 (mu4e~headers-truncate-field field name (- width 1))
;;               name)
;;             'face (if arrow '(:inherit (variable-pitch bold)) 'variable-pitch)
;;             'help-echo help
;;             'mouse-face (when sortable 'highlight)
;;             'keymap (when sortable map)
;;             'field field) " ")))
;;       mu4e-headers-fields))))
#+end_src

*** Set face of subject field to variable-pitch :ARCHIVE:
#+begin_src emacs-lisp
(defun aj/mu4e-headers-field-set-subject-face (msg field)
  "Set face of VAL to variable-pitch if FIELD is :subject."
  (when (member field '(:thread-subject :subject))
    '(:inherit variable-pitch)))

(setq mu4e-headers-field-properties-function
      #'aj/mu4e-headers-field-set-subject-face)
#+end_src

*** Small stupid fix for first space in headers headline :ARCHIVE:
#+begin_src emacs-lisp
(advice-add 'mu4e~header-line-format :around #'aj/mu4e-fix-header-space)

(defun aj/mu4e-fix-header-space (fn &rest r)
  (let ((mu4e~mark-fringe-len 3))
    (apply fn r)))
#+end_src

*** Headers fields
**** Set headers fields to view depending on what maildir is viewed
#+begin_src emacs-lisp
(setq aj/mu4e-headers-fields
      '(:gmail
        (;;(:empty . 2)
         (:aj-human-date . 12)
         (:flags . 6)
         (:from-or-to . 22)
         (:gmailtags . 5)
         ;; (:othermaildir . 10)
         ;; (:mailing-list . 7)
         (:thread-subject))
        :chalmers
        (;;(:empty . 3)
         (:aj-human-date . 12)
         (:flags . 6)
         (:from-or-to . 22)
         (:ajtags . 3)
         (:othermaildir . 5)
         (:ajlists . 8)
         (:thread-subject))
        nil
        (;;(:empty . 2)
         (:aj-human-date . 12)
         (:flags . 6)
         (:from-or-to . 22)
         ;; (:ajtags . 3)
         (:gmailtags . 5)
         (:othermaildir . 10)
         (:mailing-list . 7)
         (:thread-subject))))

(autoload 's-match-strings-all "s")
(autoload '--all? "dash")
(defun aj/mu4e-set-headers-fields (query)
  "Set ‘mu4e-headers-fields’ depending on which maildir is viewed."
  (when (buffer-live-p mu4e-headers-buffer-name)
    (with-current-buffer mu4e-headers-buffer-name
      (let* ((mdm
              (s-match-strings-all
               "maildir:\\(?2:\\\"\\(?1:[^\\\"]+\\)\\\"\\|\\(?1:[^[:space:]]+\\)\\)"
               query))
             (maildirs (mapcar #'cadr mdm))
             (headers-fields
              (plist-get
               aj/mu4e-headers-fields
               ;; select based on what maildirs are shown.
               (when maildirs
                 (cond
                  ((--all? (string-match-p "^/chalmers" it) maildirs)
                   :chalmers)
                  ((--all? (string-match-p "^/\\(mejla\\|ajf\\)" it) maildirs)
                   :gmail))))))

        (setq mu4e-headers-fields
              ;; If only a single maildir, no need for :othermaildir, remove it
              (if (and (= 1 (length maildirs))
                       (let ((md (car maildirs)))
                         (not (or (string-suffix-p "/" md)
                                  (string-suffix-p "*" md)))))
                  (assq-delete-all :othermaildir headers-fields)
                headers-fields)

              ;; no need now that I don’t display it.
              ;; header-line-format (mu4e~header-line-format)
              )))))


(add-hook 'mu4e-headers-search-hook #'aj/mu4e-set-headers-fields)
;;(remove-hook 'mu4e-headers-search-hook #'aj/mu4e-set-headers-fields)

(setq mu4e-headers-fields (plist-get aj/mu4e-headers-fields nil)
      ;; mu4e-headers-from-or-to-prefix '("" . "⯈")
      mu4e-headers-include-related nil
      mu4e-headers-visible-columns nil)

#+end_src

**** My custom headers fields
#+begin_src emacs-lisp
(add-to-list 'mu4e-header-info-custom
             '(:gmailtags .
                          (:name "Labels"
                                 :shortname "GL"
                                 :help "Gmail labels"
                                 :function aj/mu4e-gmail-labels-display)))

(defvar aj/mu4e-gmail-labels
  '(("\\Inbox" (color . "#076678") (symbol . "↓"))
    ("\\Sent" (color . "#665c54") (symbol . "↑"))
    ("\\Important" (color . "#b57614") (symbol . "❧"))
    ("\\Draft" (color . "#665c54") (symbol . "□"))))

(defun aj/mu4e-gmail-labels-display (msg)
  (let ((tags (mu4e-message-field msg :tags)))
    (cl-loop for (label . props) in aj/mu4e-gmail-labels
             concat
             (if (member label tags)
                 (let ((symb (alist-get 'symbol found tag))
                       (color (alist-get 'color found)))
                   (if color
                       (propertize symb 'face (list :foreground color))
                     symb))
               " "))))

(add-to-list 'mu4e-header-info-custom
             '(:othermaildir . (:name "Maildir"
                                      :shortname "M"
                                      :help "Maildir"
                                      :function aj/mu4e-other-maildir)))

(autoload 's-chop-prefix "s")
(autoload 's-shared-start "s")
(autoload 's-replace-all "s")
(defun aj/mu4e-other-maildir (msg)
  "Returns a possibly shortened indication of MSGs maildir
Returns the empty string if this is the \"current\" maildir."
  (let ((mmd (mu4e-message-field msg :maildir))
        (lq (mu4e-last-query)))
    (if (string-match  "maildir:\\\"\\(.+\\)\\\"" lq)
        (let ((smd (match-string 1 lq)))
          (if (string= smd mmd)
              ""
            (s-chop-prefix (s-shared-start mmd smd) mmd)))
      ;; only first letter of base maildir, in bold:
      (replace-regexp-in-string
       "^/[^/]+" (lambda (s) (propertize (substring s 1 2) 'face 'bold)) mmd))))

(add-to-list 'mu4e-header-info-custom
             '(:aj-human-date .
                              (:name "Date"
                                     :shortname "Date"
                                     :help "Date/time when the message was written."
                                     :function aj/mu4e~headers-human-date)))

(defsubst aj/mu4e~headers-human-date (msg)
  "Show a 'human' date.
If the date is today, yesterday or, show the time, otherwise, show the
date. The formats used for date and time are
`mu4e-headers-date-format' and `mu4e-headers-time-format'."
  (let ((date (mu4e-msg-field msg :date)))
    (propertize
     (if (equal date '(0 0 0))
         "None"
       (let* ((days1 (time-to-days date))
              (days2 (time-to-days (current-time))))
         (cond
          ((eq days1 days2)
           (format-time-string "     %H:%M" date))
          ((eq days1 (1- days2)) ;;yesterday
           (format-time-string "igår %H:%M" date))
          ((< (- days2 days1) 5)
           (format-time-string "%a  %H:%M" date))
          (t (format-time-string "%x" date)))))
     'face 'fixed-pitch)))
#+end_src

**** Custom header, tags
#+begin_src emacs-lisp
(add-to-list 'mu4e-header-info-custom
             '(:ajtags .
                       (:name "Tags"
                              :shortname "🏷"
                              :help "Tags"
                              :function aj/mu4e-header-tags)))

(defun aj/mu4e-header-tags (msg)
  (let ((tags (sort (mu4e-message-field msg :tags) 'string<)))
    (cl-loop with found
             for tag in tags
             if (setq found (assoc tag aj/mail-tags))
             concat
             (let ((symb (alist-get 'symbol found tag))
                   (color (alist-get 'color found)))
               (if color
                   (propertize symb 'face (list :foreground color))
                 symb)))))
#+end_src

**** COMMENT Custom flags including calendar :ARCHIVE:
#+begin_src emacs-lisp
(add-to-list 'mu4e-header-info-custom
             '(:ajflags .
                        (:name "Flags"
                               :shortname "Flags"
                               :help "Flags"
                               :function aj/mu4e-headers-flags)))

(defun aj/mu4e-headers-flags (msg)
  (let* ((flags (mu4e-message-field msg :flags))
         (flags-str (mu4e~headers-flags-str flags))
         (cal (cl-loop for part in (mu4e-message-field msg :parts)
                       if (equal (plist-get part :mime-type) "text/calendar")
                       return "📅")))
    (propertize (concat flags-str cal)
                'help-echo (format "%S" flags)))))
#+end_src

**** Custom field for lists
#+begin_src emacs-lisp
(add-to-list 'mu4e-header-info-custom
             '(:ajlists .
                        (:name "List"
                               :shortname "List"
                               :help "List"
                               :function aj/mu4e-headers-list)))

(defcustom aj/mu4e-mailing-lists nil
  "Alist with shortnames of mailing lists based on list address.
Like ‘mu4e-user-mailing-lists’."
  :group 'aj
  :type '(alist :key-type string :value-type string))

(defun aj/mu4e-headers-list (msg)
  "Show a mailing list"
  (if-let ((list (mu4e-msg-field msg :mailing-list)))
      (mu4e~headers-mailing-list list)
    (string-join
     (cl-loop for (list . short) in aj/mu4e-mailing-lists
              when (mu4e-message-contact-field-matches
                    msg '(:to :from :cc :bcc) list)
              collect short)
     ", ")))
#+end_src

*** Load next 500 messages
#+begin_src emacs-lisp
(defvar aj/mu-page 1)

(defun aj/mu-reset-page (&rest _r)
  (setq aj/mu-page 1))

;; We need to reset it for the "standard searches", but also when
;; invoking an interactive search
(add-hook 'mu4e-headers-search-bookmark-hook #'aj/mu-reset-page)
(advice-add 'mu4e~headers-jump-to-maildir :before #'aj/mu-reset-page)

(defun aj/mu-next-messages-for-query ()
  (interactive)
  (when (and (buffer-live-p mu4e-headers-buffer-name) (not mu4e-headers-full-search))
    (with-current-buffer mu4e-headers-buffer-name
      (when-let ((query (mu4e-last-query)))
        (cl-incf aj/mu-page)
        (let ((mu4e-headers-results-limit
               (* aj/mu-page mu4e-headers-results-limit))
              (last-msg (save-excursion
                          (goto-char (point-max))
                          (forward-line -1)
                          (plist-get
                           (mu4e-message-at-point)
                           :message-id))))
          (mu4e-headers-search query nil nil t last-msg)
          ;; (mu4e-mark-handle-when-leaving)
          ;;(mu4e~headers-search-execute expr ignore-history)
          ;; (run-hook-with-args 'mu4e-headers-search-hook expr)
          )))))

(bind-key "N" #'aj/mu-next-messages-for-query mu4e-headers-mode-map)
#+end_src


** Dynamic folders for refile etc. + special functions for gmail-relabeling
One could think that it would be reasonable to put this in the contexts, but no, these settings are mostly per message, and is therefore better dynamically matched on the current message.

The most complex part is for choosing refile folders, depending on account and special functions in ~aj/mu4e-refile-fns~.
#+begin_src emacs-lisp
;; Utility function
;; In its current form kind of repetitive. But I could want special
;; conditions, so I will not abstract it more now.

(cl-defmacro aj/mu4e-msg-account (msg &key chalmers mejla ajf default gmail)
  (declare (indent 1))
  `(cond
    ((and ,msg ,chalmers (string-match-p "^/chalmers/" (mu4e-message-field ,msg :maildir)))
     ,chalmers)
    ((and ,msg ,mejla (string-match-p "^/mejla/" (mu4e-message-field ,msg :maildir)))
     ,mejla)
    ((and ,msg ,ajf (string-match-p "^/ajf/" (mu4e-message-field ,msg :maildir)))
     ,ajf)
    ((and ,msg ,gmail (or
                       (string-match-p "^/mejla/" (mu4e-message-field ,msg :maildir))
                       (string-match-p "^/ajf/" (mu4e-message-field ,msg :maildir))))
     ,gmail)
    (t ,default)))

(setq mu4e-sent-folder "/chalmers/Skickat" ; gmail is set to delete sent mails
                                        ; (because it recreates them on the
                                        ; server from the mails sent via its
                                        ; smtp server.)
      mu4e-drafts-folder "/UTKAST" ; Don’t care about syncing these
                                        ; to the server
      mu4e-trash-folder (lambda (msg)
                          (aj/mu4e-msg-account msg
                            :chalmers "/chalmers/Borttagna objekt"
                            :mejla "/mejla/Papperskorgen"
                            :ajf "/ajf/Papperskorgen"))
      mu4e-refile-folder #'aj/mu4e-refile-folder)


(defvar aj/mu4e-refile-sender-hash (make-hash-table :test 'equal))
(add-to-list 'savehist-additional-variables 'aj/mu4e-refile-sender-hash)

(defun aj/mu4e-refile-guess-by-sender (msg)
  (cl-loop with current-max = 0
           with current-mf = nil
           for (folder . count) in
           (gethash (cdar (mu4e-msg-field msg :from))
                    aj/mu4e-refile-sender-hash)
           if (< current-max count) do
           (setq current-mf folder)
           finally return (when current-mf (list current-mf))))

(defun aj/mu4e-refile-store-history (msg folder)
  "Stores history and returns FOLDER."
  (cl-incf (alist-get
            folder
            (gethash (cdar (mu4e-msg-field msg :from))
                     aj/mu4e-refile-sender-hash
                     '())
            0))
  folder)

(add-to-list 'aj/mu4e-refile-fns #'aj/mu4e-refile-guess-by-sender t)


(defun aj/mu4e-refile-folder (msg &optional force-choice)
  "Guess or offer to select a refile folder for MSG.
Chooses depending on account functions in ‘aj/mu4e-refile-fns’
No automatic guess if FORCE-CHOICE is non-nil."
  (let* ((user-has-chosen nil)
         (found
          (or (cl-loop for fn in aj/mu4e-refile-fns do
                       (when-let ((res (funcall fn msg)))
                         (cond
                          ((stringp res) (cl-return res))
                          ((listp res) (cl-return (prog1 (aj/mu4e-choose-refile (car res) msg)
                                                    (setq user-has-chosen t)))))))
              (aj/mu4e-msg-account msg
                :chalmers "/chalmers/Arkiv"
                ;; Only for show, they get changed labels via custom action
                :mejla "/mejla/Alla mail"
                :ajf "/ajf/Alla mail"))))
    (aj/mu4e-refile-store-history
     msg
     (if (and found
              (or user-has-chosen (not force-choice)))
         found
       (aj/mu4e-choose-refile found msg)))))

;; (defvar aj/mu4e-helm-refile-history nil)
(defun aj/mu4e-choose-refile (startdir msg)
  "Choose a refile directory for MSG, starting search from STARTDIR"
  (let* ((subject (mu4e-message-field msg :subject))
         (subject (substring subject 0 (min 18 (length subject))))
         (case-fold-search t)
         (dir (completing-read (format "Refile \"%s\":" subject)
                               (mu4e-get-maildirs)
                               nil
                               t
                               startdir)))
    (unless (string= " " dir)
      dir)))

;; gmail is treated with labels instead of folder moves

(add-hook 'mu4e-mark-execute-pre-hook #'aj/mu4e-gmail-mark-pre-hook)
(remove-hook 'mu4e-mark-execute-pre-hook #'aj/mu4e-gmail-mark-pre-hook)


;; For forcing gmail-refiled messages to be removed from headers listing.

(defvar aj/mu4e-treat-as-move nil)

;; (defun aj/mu4e-gmail-mark-pre-hook (mark msg)
;;   (aj/mu4e-msg-account msg
;;     :mejla (aj/mu4e-gmail-retag mark msg)
;;     :ajf (aj/mu4e-gmail-retag mark msg)))

;; (defun aj/mu4e-gmail-retag (mark msg)
;;   (cond ;; ((equal mark 'refile)
;;    ;;  (setq aj/mu4e-treat-as-move t)
;;    ;;  (mu4e-action-retag-message msg "-\\Inbox"))
;;    ;; this moves to trash directory as well:
;;    ((equal mark 'trash) (mu4e-action-retag-message msg "-\\Inbox,-\\Starred"))
;;    ;; ((equal mark 'flag) (mu4e-action-retag-message msg "\\Starred"))
;;    ;; ((equal mark 'unflag) (mu4e-action-retag-message msg "-\\Starred"))
;;    ))


(advice-add 'mu4e-mark-execute-all :before (lambda (&rest _ignore) (setq aj/mu4e-treat-as-move nil)))

(setq mu4e-update-func #'aj/mu4e-headers-update-handler)
(defun aj/mu4e-headers-update-handler (msg is-move maybe-view)
  "Wrapper around ‘mu4e~headers-update-handler’ to remove
messages “refiled” in gmail accounts from the inbox listing."
  (let ((docid (plist-get msg :docid)))
    (mu4e~headers-update-handler
     msg
     (or
      (memq docid aj/mu4e-treat-as-move)
      is-move)
     maybe-view)
    (setq aj/mu4e-treat-as-move (delq docid aj/mu4e-treat-as-move))))

(defun aj/mu4e-retag-as-move (msg tagchange)
  (push (plist-get msg :docid) aj/mu4e-treat-as-move)
  (mu4e-action-retag-message msg tagchange))


;; Redefine refile to work with gmail
(setf (cl-getf (alist-get 'refile mu4e-marks) :action)
      #'aj/mu4e-refile-action)

(defun aj/mu4e-refile-action (docid msg target)
  (funcall
   (aj/mu4e-msg-account msg
     :gmail (lambda (_docid msg _target) (aj/mu4e-retag-as-move msg "-\\Inbox"))
     :default (lambda (docid _msg target)
                (mu4e--server-move docid (mu4e~mark-check-target target) "-N+S")))
   docid msg target))

;; Redefine move to trash
(setf (cl-getf (alist-get 'trash mu4e-marks) :action)
      #'aj/mu4e-trash-action)

(defun aj/mu4e-trash-action (docid msg target)
  "Move to trash, mark as read, possibly change gmail labels"
  (when-let ((retagfn
              (aj/mu4e-msg-account msg
                :gmail (lambda (msg) (mu4e-action-retag-message msg "-\\Inbox,-\\Starred,-\\Important")))))
    (funcall retagfn msg))
  (mu4e--server-move docid (mu4e~mark-check-target target) "+T+S-N"))
#+end_src

** Marks
*** Custom marks
**** Add tag
#+begin_src emacs-lisp
(defun aj/mu4e-choose-tag ()
  (let ((tags
         (cl-loop for (tag . props) in (append aj/mail-tags aj/mu4e-gmail-labels)
                  collect
                  (cons (let ((color (alist-get 'color props))
                              (display (concat (alist-get 'symbol props " ") " " tag )))
                          (if color
                              (propertize display 'face (list :foreground color))
                            display))
                        tag)))

        (case-fold-search t))
    (completing-read "Add tag: " tags)))
(add-to-list 'mu4e-marks
             '(tag
               :char       ("g" . "🏷")
               :prompt     "tag"
               :ask-target aj/mu4e-choose-tag
               :action      (lambda (docid msg target)
                              (mu4e-action-retag-message msg (concat "+" target)))))

(mu4e~headers-defun-mark-for tag)
(define-key 'mu4e-headers-mode-map (kbd "ö") 'mu4e-headers-mark-for-tag)
;; (mu4e~view-defun-mark-for tag)
;; (define-key 'mu4e-view-mode-map (kbd "C-ö") 'mu4e-headers-mark-for-tag)


#+end_src

**** Refile + mark as read :ARCHIVE:
At times, I can safely refile messages without reading them and at the same time marking them read.
#+begin_src emacs-lisp
(add-to-list 'mu4e-marks
             '(refile-read
               :char ("f" . "⧐")
               :prompt "refile"
               :dyn-target (lambda (target msg)
                             (aj/mu4e-refile-folder msg))
               :action aj/mu4e-refile-read-action))

(defun aj/mu4e-refile-read-action (docid msg target)
  (funcall
   (aj/mu4e-msg-account msg
     :gmail (lambda (docid msg target)
              (mu4e-action-retag-message msg "-\\Inbox")
              (mu4e--server-move docid (mu4e~mark-check-target target) "-N+S"))
     :default (lambda (docid _msg target)
                (mu4e--server-move
                 docid (mu4e~mark-check-target target) "-N+S")))
   docid msg target))


(mu4e~headers-defun-mark-for refile-read)
(define-key 'mu4e-headers-mode-map "ä" 'mu4e-headers-mark-for-refile-read)
#+end_src


*** Mark all duplicates in current view for deletion
#+begin_src emacs-lisp
(defun aj/mu-mark-duplicates-for-deletion ()
  (interactive)
  (mu4e-headers-mark-for-each-if
   '(delete)
   #'aj/mu-message-is-duplicate))

(defun aj/mu-message-is-duplicate (msg &optional _param)
  (plist-get (mu4e-message-field msg :thread) :duplicate))

;; (defun aj/mu-find-stupid-duplicates ()
;;   (interactive)
;;   (let ((mu4e-headers-results-limit -1)
;;         (mu4e-headers-skip-duplicates nil)
;;         (mu4e-headers-found-hook '(aj/mu-mark-duplicates-for-deletion)))
;;     (mu4e-headers-search "maildir:/uu/* date:20171001..now ")))
#+end_src

*** COMMENT Directly applied marks :ARCHIVE:
Here I define my own variant of ~mu4e~headers-defun-mark-for~ which defines functions taking a prefix argument to optionally execute the mark immediately.
Some of the functions are redefined.
#+begin_src emacs-lisp
(defmacro aj/mu4e~headers-defun-mark-for (mark)
  "Define a function mu4e~headers-mark-MARK, which takes a prefix argument to execute the mark immediately."
  (let ((funcname (intern (format "mu4e-headers-mark-for-%s" mark)))
        (docstring (format "Mark header at point with %s." mark)))
    `(progn
       (defun ,funcname (arg) ,docstring
              (interactive "P")
              (if arg
                  (let* ((msg (mu4e-message-at-point))
                         (markdescr (assq ',mark mu4e-marks))
                         (docid (plist-get msg :docid))
                         (ask-target (mu4e~mark-ask-target ',mark))
                         (target (mu4e~mark-get-dyn-target ',mark ask-target)))
                    (if markdescr
                        (funcall (plist-get (cdr markdescr) :action) docid msg target)
                      (mu4e-error "Unrecognized mark %S" ',mark)))
                (mu4e-headers-mark-and-next ',mark)))
       (put ',funcname 'definition-name ',mark))))

;; (aj/mu4e~headers-defun-mark-for refile)
;; (aj/mu4e~headers-defun-mark-for something)
;; (aj/mu4e~headers-defun-mark-for delete)
(aj/mu4e~headers-defun-mark-for flag)
;;  (aj/mu4e~headers-defun-mark-for move)
(aj/mu4e~headers-defun-mark-for read)
(aj/mu4e~headers-defun-mark-for trash)
(aj/mu4e~headers-defun-mark-for unflag)
;;  (aj/mu4e~headers-defun-mark-for untrash)
(aj/mu4e~headers-defun-mark-for unread)
;;  (aj/mu4e~headers-defun-mark-for action)
#+end_src


** Actions for toggling tags :ARCHIVE:
#+begin_src emacs-lisp
(defvar aj/mu4e-tagchange-history nil)
(defun aj/mu4e-change-tags ()
  "Add or remove tags for current message"
  (interactive)
  (let ((msg (mu4e-message-at-point)))
    (when msg
      (mu4e-action-retag-message
       msg
       (read-from-minibuffer "Add or remove tags: "
                             nil nil nil 'aj/mu4e-tagchange-history)))))

;; Tag-toggle commands
(defun aj/mu4e-defun-toggle-tags (taglist)
  "Defines and binds functions for toggling up to ten tags in mu4e-headers"
  ;;(let ((cutlist (cl-subseq taglist 0 (min 10 (safe-length taglist)))))
  (dotimes (i (min 10 (safe-length taglist)))
    (let* ((tag (nth i taglist))
           (tagname (if (listp tag) (car tag) tag))
           (fname (intern (concat "aj/mu4e-toggle-tag-" tagname))))
      (eval
       `(defun ,fname () ,(format "Toggle the %s-tag in mu4e-headers-mode" tagname)
               (interactive)
               (let ((msg (mu4e-message-at-point)))
                 (when msg
                   (if (member ,tagname (mu4e-message-field msg :tags))
                       (mu4e-action-retag-message msg ,(concat "-" tagname))
                     (mu4e-action-retag-message msg ,(concat "+" tagname)))))))
      (bind-key (number-to-string (mod (1+ i) 10))
                fname
                mu4e-headers-mode-map))))

(aj/mu4e-defun-toggle-tags aj/mail-tags)
#+end_src

** Action for View in external browser
#+begin_src emacs-lisp
(add-to-list 'mu4e-view-actions '("View in external browser" . mu4e-action-view-in-browser))
#+end_src

** Contacts
#+begin_src emacs-lisp
(defvar aj/mu4e-contacts-exclude-pattern
  (regexp-opt
   '("no-reply" "noreply" "github.com" "donotreply" "newsletter" "launchpad.net"
     "notification")))

(setq mu4e-contact-process-function #'aj/mu4e-contact-process-function)

(defun aj/mu4e-contact-process-function (c)
  (unless (string-match-p aj/mu4e-contacts-exclude-pattern c)
    c))
#+end_src
* Provide statement
#+begin_src emacs-lisp
(provide 'aj-mail-config)

;; Local Variables:
;; byte-compile-warnings: '(not free-vars)
;; End:
#+end_src

* Local Variables :ARCHIVE:

# Local Variables:
# eval: (progn (require 'use-package) (variable-pitch-mode -1))
# aj/inhibit-flyspell: t
# End:
