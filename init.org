# -*-coding: utf-8; -*-
#+TITLE: Emacs init file
#+AUTHOR: Anders Johansson
#+PROPERTY: header-args :tangle yes :comments no :no-expand t
#+TODO: CHECK TODO | DONE

This is my init file. Kept as an org file which is tangled and compiled to ~init.elc~

Additional configuration is in [[file:lisp/aj-org-config.org][aj-org-config.org]] and [[file:lisp/aj-mail-config.org][aj-mail-config.org]], and some of my configurations have been put in separate packages which are generally available in gitlab or github repositories.

Hopefully some of this could be useful to others.

* Lexical-binding
#+begin_src emacs-lisp
;; -*- lexical-binding: t -*-
#+end_src

* All configuration
** Meta
*** Tangling
Inspired by: https://github.com/larstvei/dot-emacs/blob/master/init.org

Emacs can only load =.el=-files. We can use =C-c C-v t= to run =org-babel-tangle=, which extracts the code blocks from the current file into a source-specific file (in this case a =.el=-file).

To avoid doing this each time a change is made we can add a function to the =after-save-hook= ensuring to always tangle and byte-compile the =org=-document after changes. But this generally annoys me, it’s easier to just choose when it should be done.

These functions possibly create two files from each org-file. When doing org-mode asynchronous exports, a small init file should be loaded, and this is automatically generated through tangling all trees tagged with "org_async". Even more specificity can be achieved with the tag "org_async_exclude" (which means a subtree of an "org_async"-tree can still be excluded). Additionally, "no_default_tangle" excludes trees from the standard init-files, and archived trees are always excluded (I use it for "commenting out" stuff). All to make as small and lean init files as possible.

#+begin_src emacs-lisp
(defvar aj/org-init-files
  (list (expand-file-name "init.org" user-emacs-directory)
        (expand-file-name "aj-org-config.org" (concat user-emacs-directory "lisp"))
        (expand-file-name "aj-mail-config.org" (concat user-emacs-directory "lisp"))))

(defun aj/tangle-init (&optional file)
  (interactive)
  "If the current file is listed in aj/org-init-files the
code-blocks are tangled, and the tangled file is compiled.

Two files are possibly created, one with all trees, and one for
org mode async exports, using only trees tagged with “org_async”."
  (let* ((file (or file (buffer-file-name)))
         (file-noext (file-name-sans-extension file)))
    (when (or (called-interactively-p 'interactive)
              (and (member file aj/org-init-files)
                   ;; (y-or-n-p-with-timeout "Tangle+compile file?" 3 nil)
                   ))

	  (let* ((file-el (concat file-noext ".el"))
             ;; (file-async (concat file-noext "-org-async.el"))
             (prog-mode-hook nil)
             ;; avoid garbage-collection for this
             (gc-cons-threshold most-positive-fixnum))
        (aj/org-tangle-matching "-no_default_tangle-ARCHIVE" file file-el)
        ;; FIXME, I almost never use org-async export, so commenting
        ;; this out for now:
        ;; (aj/org-tangle-matching "org_async-org_async_exclude-ARCHIVE" file file-async)
        )
      ;; (load file-noext)
      )))

(defun aj/org-tangle-matching (match origin-file target-file)
  (with-current-buffer
      (find-file-noselect origin-file)
    (let* ((todo-only nil)
           (trees (string-join
                   (org-scan-tags #'aj/org-return-entry
                                  (cdr (org-make-tags-matcher match))
                                  todo-only) "\n\n"))
           (ofile (make-temp-file "org-init-tangle" nil ".org"))
           (ofb (find-file-noselect ofile t))
           (byte-compile-warnings '(not free-vars)))
	  (with-current-buffer ofb
        (with-silent-modifications ;; TODO, could we do it in a
          ;; temp-buffer? org-babel-tangle expects a file for
          ;; reporting, but only there.
          (insert trees)
          (let ((text-mode-hook nil)
                (outline-mode-hook nil)
                (org-mode-hook nil)
                (org-startup-indented nil)
                (org-agenda-inhibit-startup t)
                (org-inhibit-startup t))
            (org-mode)
            (org-babel-tangle nil target-file "emacs-lisp"))))
      (kill-buffer ofb)
      (when (and (file-exists-p target-file) (file-writable-p target-file))
        (chmod target-file 333)

        ;; TODO, as I have so many defuns in here, the docstrings will
        ;; be looked up at runtime causing spurious reloads of
        ;; init.elc, which causes lots of problems.
        ;; The solution would be to move all kind of defuns out to
        ;; packages, or make it less of a problem to reload init. (now
        ;; it reloads custom.el etc. and that’s not good)

        ;; (byte-compile-file target-file)
        ))))

(defun aj/org-return-entry ()
  (buffer-substring-no-properties
   (org-entry-beginning-position)
   (org-entry-end-position)))


;; attempts at doing this async

;; this is difficult, because it seems I need to have all my
;; load-paths initiated. In particular it didn’t work with
;; pdf-zotxt-quote which couldn’t find org-zotxt in the compilation.
;; But why was this needed?

;; tried to add only the neccesary stuff to init-async, but ...

;; (async-start
;;  ;; What to do in the child process
;;  (lambda ()
;;    (load-file "~/.emacs.d/init-async.elc")
;;    (aj/tangle-init "~/.emacs.d/init.org")
;;    (sleep-for 1)
;;    (message "hej!")
;;    (with-current-buffer "*Messages*"
;;      (buffer-string)))

;;  ;; What to do when it finishes
;;  (lambda (result)
;;    (message "Async process done, result should be 222: %s"
;;             result)))



;; (let ((weal (aj/org-get-weal)))
;;   (concat
;;    (when weal
;;      (format "#+begin_src emacs-lisp\n ;;(with-eval-after-load '%s\n#+end_src
;; " weal))

;;    (when weal "#+begin_src emacs-lisp\n;;)\n#+end_src")))

;; (defun aj/org-get-weal ()
;;   (save-excursion
;;     (save-match-data
;;       (when (search-forward-regexp
;;              ":weal_\\([a-z_]+\\):"
;;              (point-at-eol) t)
;;         (replace-regexp-in-string "_" "-" (match-string 1))))))
#+end_src

*** Autoloading in all custom load-paths :ARCHIVE:
Some of my own packages or libraries added in /lisp don’t normally get their autoloads parsed (like happens for libraries included in emacs or those handled via ~package.el~). This is my solution for that problem.
**** Loaddefs file :org_async:
To be loaded [[*Load custom loaddefs][at the end of init]].
#+begin_src emacs-lisp
(defvar aj/custom-loaddefs-file (expand-file-name "custom-loaddefs.el" user-emacs-directory))
#+end_src
**** Functions
#+begin_src emacs-lisp
(defvar aj/original-load-path load-path) ;; has to be initialized early

(defun aj/generate-custom-loaddefs ()
  (cl-letf ((generated-autoload-file aj/custom-loaddefs-file)
            (ignored-local-variables
             (cons 'generated-autoload-file ignored-local-variables))
            ((symbol-function 'file-relative-name) #'aj/identity-first)
            ((symbol-function 'autoload-file-load-name) #'aj/autoload-file-load-name))
    (apply #'update-directory-autoloads (aj/custom-load-paths))))

(defun aj/identity-first (arg &rest _r)
  arg)

(defun aj/autoload-file-load-name (name)
  (if (string-match "\\.elc?\\(\\.\\|\\'\\)" name)
      (substring name 0 (match-beginning 0))
    name))

(defun aj/custom-load-paths ()
  "Returns load paths added in init file, outside package area"
  (cl-remove-if
   (apply-partially #'string-match-p ".emacs.d/elpa")
   (cl-set-difference
    load-path aj/original-load-path :test 'equal)))

(defun aj/generate-loaddefs-after-byte-compile (filename &rest rest)
  (when (and
         ;; no autoloads in my config files
         (not (string-match-p "-config" filename))
         (cl-some (apply-partially #'file-in-directory-p filename)
                  (aj/custom-load-paths)))
    (aj/generate-custom-loaddefs)))

(advice-add 'byte-compile-file :after #'aj/generate-loaddefs-after-byte-compile)
#+end_src

** Early settings and loading
*** garbage-collection settings
Avoid garbage collection when initializing and in minibuffer.
https://bling.github.io/blog/2016/01/18/why-are-you-changing-gc-cons-threshold/
#+begin_src emacs-lisp
(defun aj/set-no-gc ()
  (setq gc-cons-threshold most-positive-fixnum))

(defun aj/set-normal-gc ()
  (setq gc-cons-threshold 8000000))

(add-hook 'minibuffer-setup-hook #'aj/set-no-gc)
(add-hook 'minibuffer-exit-hook #'aj/set-normal-gc)

(aj/set-no-gc)
(add-hook 'after-init-hook #'aj/set-normal-gc)
#+end_src

*** Native compilation :ARCHIVE:
When using the experimental ~feature/native-comp~ branch of emacs, loaded libraries are lazily compiled, but we want to avoid doing this for some files.
#+begin_src emacs-lisp
(setq comp-deferred-compilation-deny-list
      '("init\\.el$"
        "aj-org-config\\.el$"
        "aj-mail-config\\.el$"
        ;; "pdf-[-a-z]+\\.el$"
        "mu4e-query-helper\\.el$"))
#+end_src

*** Remove unnecessary GUI-elements
#+begin_src emacs-lisp
(setq inhibit-startup-message t)

(when window-system
  (setq frame-title-format '"%b")

  (defun aj/deactivate-gui (mode on)
    "Activate or deactivate MODE depending on ON, and defines a variable stating my choice."
    (when (fboundp mode)
      (funcall mode (or on -1))
      (eval `(defconst ,(intern (concat "aj/" (symbol-name mode) "-on")) ,on))))

                                        ; I always want it to the right
  (dolist (mm '((menu-bar-mode nil) (tool-bar-mode nil) (mouse-wheel-mode t)))
    (aj/deactivate-gui (car mm) (cadr mm))))
#+end_src

*** Fontset stuff, color emojis (emacs 27, yay!)
#+begin_src emacs-lisp
;; Not needed.
;;(set-fontset-font t nil (font-spec :name "Noto Sans") nil 'append)
;; (set-fontset-font ft 'cjk-misc (font-spec :name "Noto Sans CJK") nil)

;; Fonts for some emojis:
;; Emoticons
(set-fontset-font t '(#x1f600 . #x1f64f) "Noto Color Emoji")
;; Misc symbols
;; (set-fontset-font t '(#x1f300 . #x1F5ff) "Noto Color Emoji")
#+end_src

*** Determine which of my two computers we are running on
#+begin_src emacs-lisp
(defvar aj/ajeb (string= "ajeb" (system-name)))
#+end_src

*** My own custom variables, utility hooks and functions
Some variables are not suitable to keep in the init-file, I add these via customize to the custom-file, which is not checked in.
#+begin_src emacs-lisp
(defgroup aj nil "Group for my private variables"
  :group 'emacs)

(defvar aj/large-screen-min-width 1500
  "The minimum pixel-width for a screen to be considered large.
  Used by `aj/frame-to-left'")

(defvar aj/face-definitions-hook nil
  "Extra functions for defining faces after loading themes etc.")
#+end_src

*** Add /lisp to load-path :org_async:
#+begin_src emacs-lisp
(eval-and-compile
  (add-to-list 'load-path  "~/.emacs.d/lisp"))
#+end_src

*** Package-manager setup (use straight.el) :org_async:
#+begin_src emacs-lisp
(setq straight-use-package-by-default t
      straight-vc-git-default-clone-depth 1
      straight-cache-autoloads t
      straight-fix-flycheck t
      straight-repository-branch "develop"
      ;; no need to native-compile already when building.
      ;; native compilation will be done on loading, and there are
      ;; for example lots of files in org (ob-.*) that I never load.
      straight-disable-native-compilation t)

(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))

(setq straight-recipe-repositories '(melpa gnu-elpa-mirror emacsmirror-mirror))
#+end_src

*** Fix recipes and stuff for loading some packages
#+begin_src emacs-lisp
;; Define how to build org and mu4e already here, so that dependencies work out
(straight-use-package `(org :repo "https://git.savannah.gnu.org/git/emacs/org-mode.git"
                            :local-repo "org"
                            :host nil
                            :branch "ajfixes"
                            :pre-build (("make" "autoloads" ,(concat "EMACS=" invocation-directory invocation-name)))
                            :build (:not autoloads)
                            :files (:defaults
                                    "lisp/*.el"
                                    ("etc/styles/" "etc/styles/*"))))

(straight-use-package '(mu4e :host github
                             :repo "djcb/mu"
                             :branch "master"
                             :files ("mu4e/*.el" "mu4e/mu4e.info" "build/mu4e/mu4e-config.el" "build/mu/mu")
                             ;; straight is too eager rebuilding
                             ;; (every small change), and
                             ;; compiling mu is slow!!! I’ll do it
                             ;; manually when needed
                             ;; :pre-build (("meson build") ("ninja -C build"))
                             ))

;; Don’t do any stupid options saving for eudc, my options are defined in mail-config.org
(setq-default eudc-options-file "nonononononononono.el") ;; see eudc.el::1157
(with-eval-after-load 'eudc
  (advice-add 'eudc-save-options :override #'ignore))
#+end_src

*** Bootstrap ~use-package~ :org_async:
#+begin_src emacs-lisp
;; (setq use-package-compute-statistics t)

(straight-use-package 'use-package)
(require 'use-package) ;; because of the theme stuff https://github.com/jwiegley/use-package/issues/902

(use-package validate
  :demand t)
(use-package bind-key
  :demand t)
#+end_src


*** Edit definitions with el-patch
#+begin_src emacs-lisp
(use-package el-patch)
#+end_src

*** Custom file :org_async:
#+begin_src emacs-lisp
(setq custom-file "~/.emacs.d/custom.el")
(load custom-file)
#+end_src

*** No littering! :org_async:
#+begin_src emacs-lisp
(use-package no-littering
  :demand t
  :init
  (setq no-littering-etc-directory
        (expand-file-name "config/" user-emacs-directory)
        no-littering-var-directory "~/.emacs.data/")
  :config
  (with-eval-after-load 'recentf
    (add-to-list 'recentf-exclude no-littering-var-directory)
    (add-to-list 'recentf-exclude no-littering-etc-directory))
  (setq auto-save-file-name-transforms
        `((".*" ,(no-littering-expand-var-file-name "auto-save/") t))))
#+end_src

*** Hydra (used for definitions later on) :org_async:
#+begin_src emacs-lisp
(use-package hydra
  :demand t)
#+end_src

*** Savehist (don't use session, but save many useful history variables)
#+begin_src emacs-lisp
(setq history-delete-duplicates t)

;; ‘savehist-additional-variables’, is set via customize so it is
;; loaded before this

(savehist-mode)

(defun aj/unpropertize-hist-vars (oldfun &rest args)
  "Remove text properties for some history variables for smaller savehist."
  (let ((vars-to-mod
         (seq-filter
          (lambda (el) (and (boundp el)
                       (listp (symbol-value el))
                       (stringp (car (symbol-value el)))))
          (append savehist-additional-variables
                  savehist-minibuffer-history-variables))))
    (cl-progv
        vars-to-mod
        (cl-loop for var in vars-to-mod
                 collect (mapcar 'substring-no-properties (symbol-value var)))
      (apply oldfun args))))

(advice-add 'savehist-save :around #'aj/unpropertize-hist-vars)
#+end_src


*** Center frame (but doesn’t work with pgtk under Wayland anyway)
Code adapted from ime-frame
#+begin_src emacs-lisp
(defun aj/center-frame (&optional frame)
  "Center a frame on the screen."
  (interactive)
  (apply 'set-frame-position
         (let* ((frame (or (and (boundp 'frame) frame) (selected-frame)))
                (center (aj/center-frame--get-center frame)))
           `(,frame ,@center))))

(defun aj/center-frame--get-center (frame)
  "Return the center position of FRAME on it's display."
  (let ((screengeometry (assq 'geometry (frame-monitor-attributes frame))))
    (aj/center-frame--box-get-center
     (frame-pixel-width frame)
     (frame-pixel-height frame)
     (nth 3 screengeometry)
     (nth 4 screengeometry))))

(defun aj/center-frame--box-get-center (w h cw ch)
  "Center a box inside another box.

Returns a list of `(TOP LEFT)' representing the centered position
of the box `(w h)' inside the box `(cw ch)'."
  (list (/ (- cw w) 2) (/ (- ch h) 2)))
#+end_src


*** all the icons
**** Base package
#+begin_src emacs-lisp
(use-package all-the-icons)
#+end_src

**** All the icons dired
Pretty icons in dired!

Also a hack to make it work with ~dired-subtree~, however this adds double icons when reverting a buffer with inserted subtrees.
#+begin_src emacs-lisp
(use-package all-the-icons-dired
  :init (add-hook 'dired-mode-hook #'all-the-icons-dired-mode)
  :custom (all-the-icons-dired-monochrome nil)
  :config
  (add-hook 'dired-subtree-after-insert-hook #'all-the-icons-dired--refresh)
  (add-hook 'dired-subtree-after-remove-hook #'all-the-icons-dired--refresh))
#+end_src

*** Completion
**** New completion frameworks
***** Selectrum for the interface and prescient for matching :ARCHIVE:
#+begin_src emacs-lisp
(use-package selectrum
  :custom
  (selectrum-max-window-height 0.45)
  (selectrum-fix-vertical-window-height t)
  (selectrum-files-select-input-dirs t)
  :init (selectrum-mode)
  :config

  ;; to easily navigate backwards in file system completions.
  (add-hook 'minibuffer-setup-hook
            (defun aj/selectrum-set-file-bindings ()
              (when (and selectrum-is-active
                         minibuffer-completing-file-name)
                (define-key (current-local-map)
                  (kbd "<C-backspace>") 'backward-kill-sexp))))

  ;; I use consult-completing-read-multiple
  (advice-remove 'completing-read-multiple #'selectrum-completing-read-multiple))


(use-package selectrum-prescient
  :custom
  (prescient-sort-full-matches-first t)
  (prescient-sort-length-enable nil) ; many of my sources return
                                        ; things already sorted
  ;; (prescient-filter-method 'fuzzy)
  :init
  (selectrum-prescient-mode +1)
  (prescient-persist-mode +1))
#+end_src

***** Vertico for the interface and prescient as completion style
#+begin_src emacs-lisp
(use-package vertico
  :straight (vertico :host github
                     :repo "minad/vertico"
                     :includes (vertico-directory vertico-repeat vertico-multiform vertico-buffer)
                     :files (:defaults
                             "extensions/vertico-directory.el"
                             "extensions/vertico-repeat.el"
                             "extensions/vertico-multiform.el"
                             "extensions/vertico-buffer.el"))
  :bind (("M-r" . #'vertico-repeat)
         :map vertico-map
         ("<backspace>" . #'vertico-directory-delete-char)
         ("C-<backspace>" . #'vertico-directory-delete-word))
  :init
  (vertico-mode)
  (add-hook 'minibuffer-setup-hook #'vertico-repeat-save)
  (vertico-multiform-mode)
  :custom
  (vertico-count 20)
  (vertico-count-format (cons "%-7s " "%s/%s"))
  (vertico-cycle t)
  (vertico-multiform-commands
   '((aj/run-cmd-in-small-frame buffer)
     (message-tab (vertico-sort-function . identity))))
  (vertico-buffer-display-action
   '(magit--display-buffer-fullframe)))


;; (use-package vertico-posframe
;;   :custom
;;   (vertico-posframe-size-function #'aj/vertico-posframe-get-size)
;;   (vertico-posframe-poshandler #'aj/posframe-poshandler-almost-frame-top-center)
;;   :config
;;   (defun aj/vertico-posframe-get-size ()
;;     "The default functon used by `vertico-posframe-size-function'."
;;     (list :height nil :width nil
;;           :min-height (or vertico-posframe-min-height
;;                           (let ((height (+ vertico-count 1)))
;;                             (min height (or vertico-posframe-height height))))
;;           :min-width (round (* (frame-width) 0.95))))

;;   (defun aj/posframe-poshandler-almost-frame-top-center (info)
;;     "Posframe's position handler.

;;   Let posframe(0.5, 0) align to frame(0.5, 0).  The structure of
;;   INFO can be found in docstring of `posframe-show'."
;;     (cons (/ (- (plist-get info :parent-frame-width)
;;                 (plist-get info :posframe-width))
;;              2)
;;           100))
;;   )

;; see ;; https://github.com/minad/vertico/wiki#using-prescientel-filtering-and-sorting

(use-package prescient
  :after vertico
  :demand t
  :init (setq completion-styles '(prescient basic))
  :custom
  (prescient-filter-method '(literal initialism prefix regexp))
  (prescient-history-length 500)
  (prescient-use-char-folding t)
  (prescient-use-case-folding 'smart)
  (prescient-sort-full-matches-first t) ; Works well with `initialism'.
  (prescient-sort-length-enable t)
  :config
  ;; Use `prescient-completion-sort' after filtering.
  (setq vertico-sort-function #'prescient-completion-sort)

  (defun vertico-prescient-remember ()
    "Remember the chosen candidate with Prescient."
    (when (>= vertico--index 0)
      (prescient-remember
       (substring-no-properties
        (nth vertico--index vertico--candidates)))))
  (advice-add #'vertico-insert :after #'vertico-prescient-remember)


  (prescient-persist-mode 1))

;; (use-package orderless
;;   :custom (orderless-component-separator #'orderless-escapable-split-on-space)
;;   :init
;;   (setq completion-styles '(orderless)
;;         completion-category-defaults nil
;;         ;; completion-category-overrides '((file (styles partial-completion)))

;;         ;; we do have ‘orderless-smart-case’, but it doesn‘t seem to apply to
;;         ;; file-name completion for some reason
;;         read-file-name-completion-ignore-case t
;;         read-buffer-completion-ignore-case t))

;; Configure a custom style dispatcher (see the Consult wiki)
;; (setq orderless-style-dispatchers '(+orderless-dispatch))

;; Do not allow the cursor in the minibuffer prompt
(setq minibuffer-prompt-properties
      '(read-only t cursor-intangible t face minibuffer-prompt))
(add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)
#+end_src

***** Marginalia for enabling richer annotations
#+begin_src emacs-lisp
(use-package marginalia
  ;; Either bind `marginalia-cycle` globally or only in the minibuffer
  :bind (:map minibuffer-local-map
              ("M-A" . marginalia-cycle))
  :init
  (marginalia-mode))
#+end_src

***** Consult for all the extra-loaded commands, groups + narrowing, etc.
****** Consult settings
#+begin_src emacs-lisp
(use-package consult
  :bind (("<f1> a" . consult-apropos)
         ("M-y" . consult-yank-pop)
         ("C-x C-b" . consult-buffer)
         ("C-x b" . consult-buffer)
         ("<f2>" . consult-imenu)
         :map org-mode-map
         ("<f2>" . consult-org-heading))
  :custom
  (consult-ripgrep-args
   "rga --no-ignore --null --line-buffered --color=never --max-columns=10000 --path-separator / --smart-case --no-heading --line-number .")

  (consult-preview-key (kbd "C-ä"))
  :init

  ;; gives us completion at point using the ordinary minibuffer
  ;; completion (vertico):
  (setq completion-in-region-function #'consult-completion-in-region
        ;; also can use cycling when it’s easy.
        completion-cycle-threshold 3)

  :config
  ;; (setq consult-preview-key 'any)
  (setq consult-narrow-key (kbd "<"))

  ;; ;; like "C-s" from helm’s find-file.
  ;; (define-key embark-file-map "s" #'aj/consult-ripgrep-from-dir)
  ;; (defun aj/consult-ripgrep-from-dir (file)
  ;;   (consult-ripgrep (file-name-directory file)))

  ;; disable automatic preview for some commands
  ;; (consult-customize
  ;;  consult-ripgrep consult-git-grep consult-grep
  ;;  consult-bookmark consult-recent-file consult-xref
  ;;  consult--source-file consult--source-project-file consult--source-bookmark
  ;;  :preview-key (kbd "M-."))


  ;; https://github.com/minad/consult/wiki#cycle-through-narrowing-keys

  ;; (define-key consult-narrow-map [C-left] #'consult-narrow-cycle-backward)
  ;; (define-key consult-narrow-map [C-right] #'consult-narrow-cycle-forward)
  (bind-key "C-o" #'consult-narrow-cycle-forward consult-narrow-map)

  ;; (defun consult-narrow-cycle-backward ()
  ;;   "Cycle backward through the narrowing keys."
  ;;   (interactive)
  ;;   (when consult--narrow-keys
  ;;     (consult-narrow
  ;;      (if consult--narrow
  ;;          (let ((idx (seq-position consult--narrow-keys
  ;;                                   (assq consult--narrow consult--narrow-keys))))
  ;;            (unless (eq idx 0)
  ;;              (car (nth (1- idx) consult--narrow-keys))))
  ;;        (caar (last consult--narrow-keys))))))

  (defun consult-narrow-cycle-forward ()
    "Cycle forward through the narrowing keys."
    (interactive)
    (when consult--narrow-keys
      (consult-narrow
       (if consult--narrow
           (let ((idx (seq-position consult--narrow-keys
                                    (assq consult--narrow consult--narrow-keys))))
             (unless (eq idx (1- (length consult--narrow-keys)))
               (car (nth (1+ idx) consult--narrow-keys))))
         (caar consult--narrow-keys)))))

  ;; mark ring

  ;;; mark-ring extra
  (defun aj/pop-to-mark-invoke-consult (fun)
    (interactive)
    (if (eq last-command 'pop-to-mark-command)
	    (consult-mark)
      (funcall fun)))


  (setq set-mark-command-repeat-pop t)

  (advice-add 'pop-to-mark-command :around #'aj/pop-to-mark-invoke-consult)
  )

#+end_src

****** Consult buffer
Add recent directories and xdg recent files to consult-buffer
#+begin_src emacs-lisp
(require 'dom)
(require 'url-util)
(require 'xml)
(require 'xdg)

(defun aj/consult--xdg-recent-file-list (&optional mime-filter exclude)
  "Get a list of recently used files on XDG-compliant systems.

This function extracts a list of files from the file
`recently-used.xbel' in the folder `xdg-data-home'.

Optional regexp MIME-FILTER filters by mime type. EXCLUDE non-nil
means matches to MINE-FILTER are excluded.

For more information on this specification, see
https://www.freedesktop.org/wiki/Specifications/desktop-bookmark-spec/"
  (let ((data-file (expand-file-name "recently-used.xbel" (xdg-data-home)))
        (xml-parsing-func (if (libxml-available-p)
                              #'libxml-parse-xml-region
                            #'xml-parse-region)))
    (if (file-readable-p data-file)
        (thread-last
            (cl-loop for bookmark-node in
                     (dom-by-tag
                      (with-temp-buffer
                        (insert-file-contents data-file)

                        (funcall xml-parsing-func
                                 (point-min)
                                 (point-max)))
                      'bookmark)
                     when (or (not mime-filter)
                              (and mime-filter
                                   (xor exclude
                                        (string-match-p
                                         mime-filter
                                         (dom-attr
                                          (dom-by-tag bookmark-node 'mime-type)
                                          'type)))))
                     collect
                     (when-let ((local-path (string-remove-prefix
                                             "file://"
                                             (dom-attr bookmark-node 'href)))
                                (visited (encode-time
                                          (iso8601-parse
                                           (dom-attr bookmark-node 'visited)))))
                       (let ((full-file-name (decode-coding-string
                                              (url-unhex-string local-path)
                                              'utf-8)))
                         (when (file-exists-p full-file-name)
                           (cons visited full-file-name)))))
          (delq nil)
          (seq-sort-by #'car #'time-less-p)
          (mapcar #'cdr))

      (message "consult: List of XDG recent files not found"))))


;; (defun aj/consult--recent-files-sort (file-list)
;;   "Sort the FILE-LIST by modification time, from most recent to least recent."
;;   (thread-last
;;       file-list
;;     ;; Use modification time, since getting file access time seems to count as
;;     ;; accessing the file, ruining future uses.
;;     (mapcar (lambda (f)
;;               (cons f (file-attribute-modification-time (file-attributes f)))))
;;     (seq-sort (pcase-lambda (`(,f1 . ,t1) `(,f2 . ,t2))
;;                 ;; Want existing, most recent, local files first.
;;                 (cond ((or (not (file-exists-p f1))
;;                            (file-remote-p f1))
;;                        nil)
;;                       ((or (not (file-exists-p f2))
;;                            (file-remote-p f2))
;;                        t)
;;                       (t (time-less-p t2 t1)))))
;;     (mapcar #'car)))


;; (defun aj/consult--xdg-recent-files ()
;;   "Return a list of files recently used by the system.

;; These files are sorted by modification time, from most recent to least."
;;   (aj/consult--recent-files-sort
;;    (seq-difference (aj/consult--xdg-recent-file-list)
;;                    recentf-list)))


(defvar aj/consult--source-system-file
  `( :name     "System file"
     :narrow   ?F
     :category file
     :face     consult-file
     :history  file-name-history
     :action      ,#'consult--file-action
     :items
     ,(lambda ()
        (let ((ht (consult--buffer-file-hash)))
          (mapcar #'abbreviate-file-name
                  (seq-remove (lambda (x) (gethash x ht))
                              (aj/consult--xdg-recent-file-list "inode/directory" t))))))
  "Recent system file candidate source for `consult-buffer'.")

;; (defvar aj/consult--source-dired-recent
;;   `( :name "Recent directories"
;;      :narrow ?d
;;      :category file
;;      ;; :state consult--directory-state
;;      :action consult--file-action
;;      ;; :history  dired-recent-history
;;      :items    ,(lambda () dired-recent-directories)
;;      :enabled ,(lambda () dired-recent-mode)))


;; (consult--define-state directory)

;; (defun consult--directory-preview ())

;; (defun consult--directory-action (dir)
;;   "Open FILE via `consult--buffer-action'."
;;   (consult--buffer-action (find-file-noselect dir)))


(setq consult-buffer-sources
      '(consult--source-hidden-buffer
        consult--source-buffer
        consult--source-recent-file
        consult--source-project-buffer
        consult--source-project-recent-file
        ;; aj/consult--source-dired-recent
        aj/consult--source-system-file
        ))
#+end_src

****** Consult-dir, jump to or change directories in minibuffer or anywhere
#+begin_src emacs-lisp
(use-package consult-dir
  :straight (:host github :repo "karthink/consult-dir")
  :bind ("C-x C-d" . consult-dir)
  :custom
  (consult-dir-shadow-filenames nil)
  (consult-dir-sources
   '(consult-dir--source-bookmark
     consult-dir--source-default
     consult-dir--source-project         ;projectile if available, project.el otherwise
     consult-dir--source-recentf
     consult-dir--source-tramp-local
     consult-dir--source-tramp-ssh
     aj/consult-dir--source-xdg))

  :config
  (defun aj/consult-dir-xdg-directories ()
    (consult-dir--filter-hashed
     (aj/consult--xdg-recent-file-list "inode/directory")))

  (defvar aj/consult-dir--source-xdg
    `( :name "Xdg dirs"
       :narrow ?x
       :category file
       :face consult-file
       :history file-name-history
       :items ,#'aj/consult-dir-xdg-directories)
    "Xdg directory source for `consult-dir--pick'."))
#+end_src

****** Pre-select nearest heading for ~consult-org-heading~ and ~consult-outline~ using vertico
From: https://github.com/minad/consult/wiki#pre-select-nearest-heading-for-consult-org-heading-and-consult-outline-using-vertico
#+begin_src emacs-lisp
(defvar aj/consult-previous-point nil
  "Location of point before entering minibuffer.
Used to preselect nearest headings and imenu items.")

(defun aj/consult-set-previous-point ()
  "Set location of point. Used before entering the minibuffer."
  (setq aj/consult-previous-point (point)))

(advice-add #'consult-org-heading :before #'aj/consult-set-previous-point)
(advice-add #'consult-outline :before #'aj/consult-set-previous-point)

;;Advise vertico--update-candidates to select the nearest candidate if applicable.

(advice-add #'vertico--update-candidates :after #'aj/vertico--update-candidates-choose)

(defun aj/vertico--update-candidates-choose (&rest _)
  "Pick the nearest candidate rather than the first after updating candidates."
  (when (and aj/consult-previous-point
             (memq current-minibuffer-command
                   '(consult-org-heading consult-outline)))
    (setq vertico--index
          (max 0 ; if none above, choose the first below
               (1- (or (seq-position
                        vertico--candidates
                        aj/consult-previous-point
                        (lambda (cand point-pos) ; counts on candidate list being sorted
                          (> (cl-case current-minibuffer-command
                               (consult-outline
                                (car (consult--get-location cand)))
                               (consult-org-heading
                                (get-text-property 0 'consult--candidate cand)))
                             point-pos)))
                       (length vertico--candidates))))))
  (setq aj/consult-previous-point nil))
#+end_src

***** Embark for doing actions on selections, both in minibuffer (completions) and normal buffers
#+begin_src emacs-lisp
(use-package embark
  :demand t
  :straight (:files ("embark.el" "embark-org.el"))
  :custom
  (embark-mixed-indicator-delay 2)
  ;; recommended in embark README:
  (y-or-n-p-use-read-key t)
  :bind (("C-." . embark-act)
         ("M-." . embark-dwim))
  :config
  (with-eval-after-load 'org
    (require 'embark-org)))

;; Consult users will also want the embark-consult package.
(use-package embark-consult
  :after (embark consult)
  :demand t ; only necessary if you have the hook below
  ;; if you want to have consult previews as you move around an
  ;; auto-updating embark collect buffer
  :hook
  (embark-collect-mode . consult-preview-at-point-mode)
  :config

  ;; Export grep to org.
  (setf (alist-get 'consult-grep embark-exporters-alist)
        #'aj/embark-consult-export-grep-choose)

  (defun aj/embark-consult-export-grep-choose (lines)
    (if (y-or-n-p "Use org?")
        (aj/embark-consult-export-grep-org lines)
      (embark-consult-export-grep lines)))

  (defun aj/embark-consult-export-grep-org (lines)
    "Create a org mode buffer listing LINES."
    (let ((buf (generate-new-buffer "*Embark Export Grep Org*"))
          (lastfile))
      (with-current-buffer buf
        (insert "* Exported grep results\n")
        (dolist (line lines)
          (if (string-match "^\\([^:]+\\):\\([^:]+\\):\\(.+\\)$" line)
              (let ((fn (match-string 1 line)))
                (unless (equal lastfile fn)
                  (insert (format "** [[file:%s]]\n" fn)))
                (setq lastfile fn)
                (insert (format "*** [[file:%s::%s]]\n#+begin_quote\n%s\n#+end_quote\n"
                                fn
                                (match-string 2 line)
                                (replace-regexp-in-string
                                 "^\*"
                                 "​*" ; zero-width space + *
                                 (match-string 3 line)))))
            (insert "** " line "\n")))
        (goto-char (point-min))
        (org-mode)
        (use-local-map (make-composed-keymap
                        embark-consult-revert-map
                        (current-local-map))))
      (pop-to-buffer buf)))

  )
#+end_src

***** all-the-icons-completion, for some eye candy
#+begin_src emacs-lisp
(use-package all-the-icons-completion
  :init (all-the-icons-completion-mode))
#+end_src

**** Open zotero library files
#+begin_src emacs-lisp
(defcustom aj/zotero-library nil
  "Directory of Zotero library files"
  :group 'aj
  :type 'directory)

(defvar aj/zoterofile-history nil)

(defun aj/open-zoterofile-new-frame ()
  (aj/run-cmd-in-small-frame 100 20 #'aj/zoterofile "Zotero file" t))

(autoload #'consult--multi "consult")

(defun aj/zoterofile-open (file)
  "Open FILE in emacs or externally."
  (if aj/running-cmd-in-small-frame
      (consult-file-externally file)
    (find-file file)))

(defvar aj/zoterofile-options
  '( :category file
     :history aj/zoterofile-history
     :action aj/zoterofile-open))

(defun aj/zoterofile ()
  "Act on a zotero file."
  (interactive)
  (consult--multi
   (list (append (list :name "Zotero recently modified"
                       :items #'aj/zotero-recently-modified
                       :narrow ?m)
                 aj/zoterofile-options)
         (append (list :name "Zotero recentf"
                       :items #'aj/zotero-recentf
                       :narrow ?r)
                 aj/zoterofile-options)
         (append (list :name "Zotero files"
                       :items #'aj/zotero-files
                       :narrow ?f)
                 aj/zoterofile-options))
   :prompt "Zotero file: "))

(defun aj/zotero-recently-modified ()
  (when (file-accessible-directory-p aj/zotero-library)
    (with-temp-buffer
      (call-process "ls" nil t nil "-t" "-1" aj/zotero-library)
      (goto-char (point-min))
      (cl-loop with i = 0
               while
               (and (< i 20) (search-forward-regexp "^.+\\.\\(pdf\\|epub\\|vue\\)$"))
               collect (expand-file-name (match-string 0) aj/zotero-library)
               and do (cl-incf i)))))

(defun aj/zotero-recentf ()
  (seq-filter
   (lambda (f) (string-match-p
           (concat "^" aj/zotero-library ".+\\.\\(pdf\\|epub\\|vue\\)$")
           f))
   recentf-list))

(defun aj/zotero-files ()
  (when (file-accessible-directory-p aj/zotero-library)
    (directory-files aj/zotero-library t "\\.\\(pdf\\|djvu\\|vue\\)$")))
#+end_src

**** Launch in small frame
#+begin_src emacs-lisp
(defvar aj/running-cmd-in-small-frame nil)

(defun aj/run-cmd-in-small-frame (width height cmd name &optional forcecleanup frame-params face-customizations)
  (unwind-protect
      (let ((ocframe
             (make-frame
              `(,@frame-params
                (width . ,width) (height . ,height) (name . ,name)
                (undecorated . t) (fullscreen . nil))))
            (aj/running-cmd-in-small-frame t)
            (this-command 'aj/run-cmd-in-small-frame))
        (select-frame-set-input-focus ocframe)
        (aj/center-frame ocframe)
        (cl-loop for (f . c) in face-customizations
                 do (apply #'set-face-attribute f ocframe c))
        (funcall cmd))
    (when forcecleanup
      (sit-for 0.01) ;; to allow other commands (for example via embark-act)
      (delete-frame))))
#+end_src

*** Org init
**** Load with org
***** orgqda
#+begin_src emacs-lisp
;; don’t install old versions with melpa repository and git.
(straight-use-package '(hierarchy :type built-in))

(use-package orgqda
  :straight ( :depth full :host gitlab :repo "andersjohansson/orgqda"
              :files ("orgqda.el" "orgqda-completion.el"))
  :defer t
  :after org
  :init (put 'orgqda-csv-dir 'safe-local-variable #'file-directory-p)
  :hook (orgqda-mode . orgqda-completion-mode)
  :bind ( :map vertico-map
          ("C-ä" . #'orgqda-completion-cycle-sorting))
  :custom
  (orgqda-tagcount-show-files t)
  (orgqda-completion-include-excluded t)
  (orgqda-completion-include-persistent t)
  :config (setq orgqda-exclude-tags
                (append (mapcar #'car org-tag-persistent-alist)
                        '("ARCHIVE" "Reflektion" "Observation" "Forskningsdagbok")))


  ;; Clean up filenames
  (defun aj/orgqda-remove-filename-num (filename)
    "Clean up initial numbers from FILENAME."
    (replace-regexp-in-string "^[0-9]+-" "" filename))

  (add-to-list 'orgqda-tagcount-files-transform-functions
               #'aj/orgqda-remove-filename-num
               t)

  ;; Add quote block around extracts
  (setq orgqda-transform-collected-paragraph-function #'aj/orgqda-transform-quotewrap)
  (defun aj/orgqda-transform-quotewrap (extract)
    "Add org quote block and interviewee name to EXTRACT."
    (let ((name (unless (string-match
                         (rx (seq bol (repeat 1 15 alpha) ":"))
                         extract)
                  (orgqda--tagcount-transform-file-name (buffer-file-name)))))
      (concat "#+begin_quote\n"
              (string-trim extract)
              (when name (concat "\\\\\n(" name ")"))
              "\n#+end_quote")))

  ;; some custom fontification,
  (org-link-set-parameters "otag" :face 'mu4e-header-key-face)
  (org-link-set-parameters "otag" :activate-func #'aj/orgqda-otag-activate)

  (defun aj/orgqda-otag-activate (start end path _br)
    "Fontify otag tags with prefixes dimmed."
    (save-match-data
      (save-excursion
        (goto-char start)
        (when (search-forward "][" end t) ;; we have description
          (when (looking-at (rx (seq (group-n 1 (+ (seq (+ alnum) "_"))))))
            (add-face-text-property (match-beginning 1) (match-end 1)
                                    'shadow))))))

  ;; Special function for inserting or modifying tags
  (define-key orgqda-mode-map [remap org-set-tags-command] #'orgqda-code-headline-or-paragraph)

  ;; (defun aj/orgqda-tag-or-code (arg)
  ;;     "Insert inlinetask and tag, except if on headline, then add tag
  ;; ARG is passed through."
  ;;     (interactive "P")
  ;;     (let ((inhibit-read-only t))
  ;;       (if (org-at-heading-p)
  ;;           (org-set-tags-command arg)
  ;;         (orgqda-insert-inlinetask-coding arg))))
  ;;   (add-to-list 'marginalia-command-categories '(aj/orgqda-tag-or-code . org-tags))

  ;; Word-wrap long tag strings correctly.
  (add-hook 'orgqda-mode-hook #'aj/word-wrap-colons)
  (defun aj/word-wrap-colons ()
    (setq word-wrap-by-category t)
    (modify-category-entry ?: ?|)))

(use-package orgqda-transient
  :straight ( :depth full :host gitlab :repo "andersjohansson/orgqda"
              :files ( "orgqda-transient.el"))
  :after orgqda
  :bind ( :map orgqda-mode-map
          ("C-c C-ö" . #'orgqda-transient)
          :map orgqda-codebook-mode-map
          ("C-c C-ö" . #'orgqda-transient)
          :map orgqda-list-mode-map
          ("C-c C-ö" . #'orgqda-transient)
          :map orgqda-view-mode-map
          ("C-c C-ö" . #'orgqda-transient)))


#+end_src

***** Org-pomodoro :ARCHIVE:
#+begin_src emacs-lisp
(use-package org-pomodoro
  :after org)
#+end_src

***** Org-download
#+begin_src emacs-lisp
(use-package org-download
  :after org)
#+end_src

***** ox-pandoc (and zotero)
For exporting via pandoc and to zotero
#+begin_src emacs-lisp
(use-package ox-pandoc
  :custom (org-pandoc-options-for-odt
           '((lua-filter . "/home/aj/lib/bbt-pandoc-zotero.lua")
             (metadata . "zotero_author_in_text=true")
             (reference-doc . "~/.emacs.d/pandoc-reference.odt")
             ;; (metadata . "zotero_csl_style=apa")
             ))
  (org-pandoc-menu-entry
   '((?n "to native and open." org-pandoc-export-to-native-and-open)
     (?N "as native." org-pandoc-export-as-native)
     (?o "to odt and open." org-pandoc-export-to-odt-and-open)
     (?O "to odt." org-pandoc-export-to-odt)
     (?x "to docx and open." org-pandoc-export-to-docx-and-open)
     (?X "to docx." org-pandoc-export-to-docx)
     (?k "to markdown." org-pandoc-export-to-markdown)
     (?K "to markdown and open." org-pandoc-export-to-markdown-and-open)
     (?m "as markdown." org-pandoc-export-as-markdown)
     ))
  :config

  (org-cite-register-processor 'pandoc
    :export-citation #'oc-pandoc-export-citation
    :export-bibliography #'oc-pandoc-export-bibliography)

  (defun oc-pandoc-export-citation (citation _style _ _info)
    "Export CITATION object in org format."
    (org-element-citation-interpreter
     citation
     (mapconcat (lambda (r) (org-element-citation-reference-interpreter r nil))
                (org-cite-get-references citation))))

  (defun oc-pandoc-export-bibliography (_k _f _s _p _b _i)
    "Generate a #+print_bibliography:"
    "#+print_bibliography:"))
#+end_src

***** ox-md-pandoc-zotero :ARCHIVE:
For exporting and converting to zotero.
#+begin_src emacs-lisp
(use-package ox-md-pandoc-zotero
  :straight (:host gitlab :repo "andersjohanssson/ox-md-pandoc-zotero"))
#+end_src

***** Citeproc
#+begin_src emacs-lisp
(use-package citeproc)
#+end_src

**** org init
#+begin_src emacs-lisp
(use-package org
  :bind (("C-c a" . org-agenda) ("C-c c" . org-capture))
  :commands org-mode
  :demand t
  :init
  (setq org-directory "~/org"
        org-ellipsis " ↴"
        org-export-backends '(org odt ascii html icalendar latex pandoc)
        org-modules '(org-protocol org-habit org-inlinetask org-id org-pdfview)
        org-list-allow-alphabetical t
        org-id-method 'ts
        org-id-ts-format "%Y-%m-%d.%H:%M:%S.%3N"
        org-id-prefix "aj"
        org-id-link-to-org-use-id 'use-existing
        org-agenda-files (expand-file-name "agenda-files" org-directory))
  (defcustom aj/org-work-agenda-files nil
    "Agenda files connected to work"
    :group 'aj
    :type '(repeat file))
  :custom
  (org-special-ctrl-k t)
  (org-fontify-done-headline nil)
  (org-adapt-indentation nil)
  (org-yank-adjusted-subtrees t)

  (org-cycle-level-after-item/entry-creation nil)

  ;; we always want noexport etc. to be offered
  (org-tag-persistent-alist '(("noexport") ("outline") ("ignoreheading") ("ignoreheadinglocal") ("read_only")))
  ;; I mostly don’t use fast-tag-selection, perhaps in special files
  ;; with specially defined tags
  (org-use-fast-tag-selection 'auto)
  ;; then it should be really quick
  (org-fast-tag-selection-single-key t)

  ;; display stuff
  (org-catch-invisible-edits 'show)
  (org-blank-before-new-entry '((heading . auto) (plain-list-item . auto)))
  (org-cycle-separator-lines 0)
  (org-pretty-entities t)
  (org-pretty-entities-include-sub-superscripts nil)
  (org-hide-emphasis-markers t)
  (org-image-actual-width 600)

  ;; (org-fontify-whole-heading-line t)
  ;; (org-level-color-stars-only t)

  ;; avoid this for performance:
  (org-highlight-latex-and-related nil) ;; '(latex script entities)

  (org-M-RET-may-split-line '((headline . t) (default . t)))

  (org-startup-folded nil)
  (org-startup-indented nil)
  (org-indent-indentation-per-level 2)

  ;;refile
  (org-refile-allow-creating-parent-nodes 'confirm)

  ;;faces
  (org-fontify-quote-and-verse-blocks t)

  ;; footnotes (the sane way minimizing problems)
  (org-footnote-define-inline t)

  ;; org-src
  (org-src-tab-acts-natively t)
  (org-src-window-setup 'current-window)
  (org-edit-src-content-indentation 0)
  (org-edit-src-turn-on-auto-save t)

  ;; org-agenda
  (org-agenda-window-setup 'other-frame)
  (org-agenda-skip-scheduled-if-done t)
  (org-agenda-skip-scheduled-if-deadline-is-shown t)
  (org-agenda-scheduled-leaders '("Planerad: " "Planerad %2d×"))
  (org-agenda-deadline-leaders '("Deadline:  " "Om %3d d.: " "%2d d. sen: "))
  ;;org-capture
  (org-capture-use-agenda-date t)

  :config
  (load-library "aj-org-config")

  ;; (setq org-agenda-text-search-extra-files
  ;;       (let ((org-agenda-files (expand-file-name "kodningsfiler" org-directory)))
  ;;         (org-read-agenda-file-list)))

  )
#+end_src
**** org init async                             :org_async:no_default_tangle:
#+begin_src emacs-lisp
(use-package org
  :demand t
  :commands org-mode
  :init (progn
          (setq org-directory "~/org"
                org-export-backends '(beamer odt ascii html icalendar latex)
                org-modules '(org-inlinetask org-zotxt org-id)
                org-list-allow-alphabetical t))
  :config (require 'ox) (require 'aj-org-config-org-async))
#+end_src


**** Things to load after org
***** org clock hydra
#+begin_src emacs-lisp
(bind-key "C-c w" #'hydra-org-clock/body)
;; make byte-compiler happy?
(dolist (x '(org-clock-in org-clock-out org-clock-in-last org-clock-modify-effort-estimate org-clock-cancel org-clock-goto org-clock-display org-clock-report org-clocking-p))
  (autoload x "org-clock"))

(defhydra hydra-org-clock (:color blue :hint nil)
  "
 In/out^        ^Edit^         ^Summary     (_?_)
---------------------------------------------
 _i_n, select    _e_dit effort  _g_oto entry
 _I_n here       _E_ffort here  _d_isplay
 _c_ontinue      _C_ancel
 _o_ut           _r_eport
 _D_one
 _p_omodoro (select)
 _l_ast task pomodoro (continue)
 _P_omodoro here"
  ("i" aj/org-clock-in-list)
  ("I" aj/org-clock-in-here)
  ("o" org-clock-out)
  ("D" aj/org-mark-current-clocking-done)
  ("c" org-clock-in-last)
  ("p" (org-pomodoro '(4)))
  ("l" (org-pomodoro '(16)))
  ("P" org-pomodoro)
  ("e" org-clock-modify-effort-estimate)
  ("E" org-set-effort)
  ("C" org-clock-cancel)
  ("g" org-clock-goto)
  ("d" org-clock-display)
  ("r" org-clock-report)
  ("ö" (aj/org-id-todo-state "aj:read-habit" 'done))
  ("?" (org-info "Clocking commands")))

(defun aj/org-clock-in-list ()
  (interactive) (org-clock-in '(4)))

(defun aj/org-clock-in-here ()
  (interactive)
  (cond
   ((eq major-mode 'org-mode)
    (org-clock-in))
   ((eq major-mode 'org-agenda-mode)
    (org-agenda-clock-in))
   (t (message "Not in org file or agenda"))))

(defun aj/org-mark-current-clocking-done ()
  (interactive)
  (when (org-clocking-p)
    (save-window-excursion
      (org-clock-goto)
      (org-todo 'done))))
#+end_src

*** Swallow
#+begin_src emacs-lisp

#+end_src

*** Flymake :ARCHIVE:
#+begin_src emacs-lisp
(use-package flymake
  :hook
  (prog-mode . flymake-mode)
  ;; (org-src-mode . aj/flymake-remove-checkdoc)
  :config
  ;; (defun aj/flymake-remove-checkdoc ()
  ;;   (remove-hook 'flymake-diagnostic-functions #'elisp-flymake-checkdoc t)
  ;;   )
  )
#+end_src

*** Flycheck
#+begin_src emacs-lisp
(use-package flycheck
  :commands (global-flycheck-mode)
  :init (add-hook 'after-init-hook #'global-flycheck-mode)
  :defer 5
  :custom
  (flycheck-global-modes '(not text-mode org-mode))
  (flycheck-emacs-lisp-load-path 'inherit)
  (flycheck-emacs-lisp-initialize-packages nil)
  :config
  (advice-add 'flycheck-ephemeral-buffer-p :around
              #'aj/flycheck-ephemeral-advice)

  (defun aj/flycheck-ephemeral-advice (origfun)
    (or
     (string-prefix-p "*Org Src " (buffer-name))
     (string-prefix-p "*scratch*" (buffer-name))
     (funcall origfun))))
#+end_src

*** Eglot-ltex, for grammarcheck with languagetool and eglot
#+begin_src emacs-lisp
;; (use-package flycheck-languagetool
;;   :init
;;   (setq flycheck-languagetool-server-command
;;         '("java" "-cp" "\"/usr/share/java/languagetool/*\"" "org.languagetool.server.HTTPServer")
;;         flycheck-languagetool-server-port "8099")

;;   ;; (setq flycheck-languagetool-server-jar "/usr/share/java/languagetool/languagetool-server.jar")
;;   )

(use-package eglot-ltex
  :straight (:host 'github :repo "emacs-languagetool/eglot-ltex")
  :custom (eglot-languagetool-server-path "/opt/ltex-ls/"))
#+end_src

*** Saveplace is neccessary
#+begin_src emacs-lisp
(require 'saveplace)
(setq save-place-limit 1000)
(save-place-mode 1)
#+end_src

*** Calendar setup
#+begin_src emacs-lisp
(setq holiday-christian-holidays nil
      holiday-general-holidays nil
      holiday-hebrew-holidays nil
      holiday-islamic-holidays nil
      holiday-bahai-holidays nil
      holiday-oriental-holidays nil)

(load "swedish-holidays.el")

(setq calendar-day-name-array ["Söndag" "Måndag" "Tisdag" "Onsdag" "Torsdag" "Fredag" "Lördag"]
      calendar-day-abbrev-array ["Sön" "Mån" "Tis" "Ons" "Tor" "Fre" "Lör"]
      calendar-day-header-array ["Sö" "Må" "Ti" "On" "To" "Fr" "Lö"]
      calendar-month-name-array ["Januari" "Februari" "Mars" "April" "Maj"
	                             "Juni" "Juli" "Augusti" "September"
				                 "Oktober" "November" "December"])

;; show iso-week in calendar (we often use week numbers in Sweden)
(copy-face 'calendar-weekday-header 'calendar-iso-week-face)
(set-face-attribute 'calendar-iso-week-face nil :height 0.75)
(setq calendar-intermonth-text
      '(propertize "   "
                   'display
                   (propertize (format
                                " %2d "
                                (car
                                 (calendar-iso-from-absolute
                                  (calendar-absolute-from-gregorian (list month day year)))))
                               'font-lock-face 'calendar-iso-week-face)))

;; spaces in the same face here for getting the alignment right
;; it is right up to one pixel at places
(setq calendar-intermonth-header
      (propertize "   " 'display (propertize "    " 'font-lock-face 'calendar-iso-week-face)))
#+end_src

** Some optimizations for long lines
https://200ok.ch/posts/2020-09-29_comprehensive_guide_on_handling_long_lines_in_emacs.html
I very seldom happen upon right-to-left text in Emacs, and couldn’t read it in any case. We can avoid some scanning work by forcing left-to-right. Then there’s also ~so-long-mode~.
#+begin_src emacs-lisp
(setq-default bidi-paragraph-direction 'left-to-right)
(setq bidi-inhibit-bpa t)

;; not needed with optimizations in 29?
;;(global-so-long-mode t)
#+end_src

** Debugging
#+begin_src emacs-lisp
(use-package profiler
  :bind (("<C-f7>" . aj/start-profiler)
         ("<C-f8>" . profiler-report))
  :init
  (defun aj/start-profiler () (interactive)
         (profiler-start 'cpu)))
#+end_src

** Better ~keyboard-quit~
Inspired by https://www.with-emacs.com/posts/tips/quit-current-context/
#+begin_src emacs-lisp
(defun aj/keyboard-quit-context ()
  "Quit current context.

This function is a combination of `keyboard-quit' and
`keyboard-escape-quit' with some parts omitted and some custom
behavior added."
  (interactive)
  (cond ((region-active-p)
         ;; Avoid adding the region to the window selection.
         (setq saved-region-selection nil)
         (let (select-active-regions)
           (deactivate-mark)))
        ((eq last-command 'mode-exited) nil)
        (current-prefix-arg
         nil)
        (defining-kbd-macro
          (message
           (substitute-command-keys
            "Quit is ignored during macro defintion, use \\[kmacro-end-macro] if you want to stop macro definition"))
          (cancel-kbd-macro-events))
        ((active-minibuffer-window)
         ;; (abort-recursive-edit)
         (if (bound-and-true-p ctrlf--active-p)
             (ctrlf-cancel)
           (abort-recursive-edit))
         )
        (t
         ;; if we got this far just use the default so we don't miss
         ;; any upstream changes
         (keyboard-quit))))

(global-set-key [remap keyboard-quit] #'aj/keyboard-quit-context)
#+end_src

** Mail-config (mu4e)
Use mu4e, the extensive config is in an [[file:lisp/aj-mail-config.org][external file]].
#+begin_src emacs-lisp
(use-package mu4e
  :bind (("C-x ö" . mu4e)
         ("C-x m" . mu4e-compose-new)
         ("C-x i" . mu4e~headers-jump-to-maildir)
         ("C-x å" . mu4e-search-bookmark))
  :defer 5
  :custom ((mu4e-mu-binary (expand-file-name "mu" (straight--build-dir "mu4e")))
           (mu4e-confirm-quit nil)
           (mu4e-context-policy 'pick-first)
           (mu4e-compose-context-policy 'ask-if-none)
           (mu4e~update-buffer-height 4)
           (mu4e-split-view 'vertical)
           (mu4e-get-mail-command "aj-mailsync") ; bash script
                                        ; running several offlineimap
                                        ; processes for syncing
                                        ; different mailboxes
           (mu4e-update-interval 600)
           (mu4e-view-show-images t)
           (mu4e-use-fancy-chars t)
           (mu4e-headers-results-limit 500) ; easier on my slow computer
           (mu4e-attachment-dir "~/Hämtningar")
           ;; mu4e-change-filenames-when-moving t ;;for mbsync
           (mu4e-completing-read-function #'completing-read))
  :config (require 'aj-mail-config)
  (setq message-kill-buffer-on-exit t)
  (mu4e t) ;; start delayed in background
  )
#+end_src

*** Fix parse-time-string :ARCHIVE:
Why do I need this? For something with mu4e emailing? I don’t remember. It messes with ~org-read-date-analyze~, which is smarter anyway.

Disable it for now.
#+begin_src emacs-lisp
(declare-function parse-iso8601-time-string "parse-time" (str)) ; make byte-compiler happy

(defun aj/parse-time-string (oldfun &rest r)
  "Filter `parse-time-string' to additionally try parsing iso8601 strings"
  (let ((ptret (apply oldfun r)))
    (when (cl-every #'null ptret)
      (if-let ((ip (ignore-errors (parse-iso8601-time-string (car r)))))
          (decode-time ip)
        ptret))))

(advice-add 'parse-time-string :around #'aj/parse-time-string)
#+end_src
** Elfeed (feed-reader)
#+begin_src emacs-lisp
(use-package elfeed
  :bind ("C-x y" . elfeed)
  :config (add-hook 'elfeed-show-mode-hook #'visual-line-mode))

;;just the split-pane part extracted from the elfeed-goodies package
;; (use-package elfeed-goodies-split-pane
;;   :straight (elfeed-goodies-split-pane
;;              :host github
;;              :repo "algernon/elfeed-goodies"
;;              :files ("elfeed-goodies-split-pane.el"))
;;   :after elfeed
;;   :demand t
;;   :bind (:map elfeed-show-mode-map
;;               ("n" . elfeed-goodies/split-show-next)
;;               ("p" . elfeed-goodies/split-show-prev))
;;   :config
;;   (setq elfeed-goodies/entry-pane-size 0.5
;;         elfeed-show-entry-switch #'elfeed-goodies/switch-pane
;;         elfeed-show-entry-delete #'elfeed-goodies/delete-pane))

#+end_src

** News
#+begin_src emacs-lisp
(setq gnus-select-method '(nntp "news.gmane.io"))
#+end_src
** Filetypes etc
*** Don’t warn about large pdfs
Patch ~abort-if-file-too-large~ to not complain about pdfs (which are generally handled well by pdf-tools no matter the size).
#+begin_src emacs-lisp
(el-patch-feature files)
(with-eval-after-load 'files
  (el-patch-defun abort-if-file-too-large (size op-type filename &optional offer-raw)
    "If file SIZE larger than `large-file-warning-threshold', allow user to abort.
OP-TYPE specifies the file operation being performed (for message
to user).  If OFFER-RAW is true, give user the additional option
to open the file literally.  If the user chooses this option,
`abort-if-file-too-large' returns the symbol `raw'.  Otherwise,
it returns nil or exits non-locally."
    (let ((choice (and large-file-warning-threshold size
	                   (> size large-file-warning-threshold)
                       ;; No point in warning if we can't read it.
                       (file-readable-p filename)
                       (el-patch-add (not (string= "pdf" (file-name-extension filename))))
                       (files--ask-user-about-large-file
                        size op-type filename offer-raw))))
      (when (eq choice 'abort)
        (user-error "Aborted"))
      choice)))
#+end_src

*** Add pdfbz2 and pdfgz filetypes and decompress correctly
I need this for adding files with .pdfbz2 or .pdfgz suffixes to Zotero with Zotfile, which can't handle double suffixes like .pdf.bz2.

But why do I need to compress pdf-files this way? Shouldn’t pdf-files have reasonable compression?
#+begin_src emacs-lisp
(dolist (var '("\\.pdfbz2\\'" "\\.pdfgz\\'"))
  (add-to-list 'auto-mode-alist (cons var 'pdf-view-mode)))
(add-to-list 'jka-compr-compression-info-list
             ["\\.pdfbz2\\'" "bzip2ing" "bzip2" nil "bunzip2ing" "bzip2"
              ("-d")
              nil t "BZh"])
(add-to-list 'jka-compr-compression-info-list
             ["\\.pdfgz\\'" "compressing" "gzip"
              ("-c" "-q")
              "uncompressing" "gzip"
              ("-c" "-q" "-d")
              t t "\213"])
(jka-compr-update)
#+end_src

** File management
*** Sudo-edit
#+begin_src emacs-lisp
(use-package sudo-edit
  :after embark
  :config
  (sudo-edit-indicator-mode t)
  :bind
  (:map embark-file-map
        ("z" . sudo-edit-find-file))
  (:map embark-become-file+buffer-map
        ("z" . sudo-edit-find-file)))
#+end_src
*** Dired
**** Some settings
#+begin_src emacs-lisp
(use-package dired
  :straight (:type built-in)
  :bind (:map dired-mode-map
              ;; because ^ is a dead key in my Swedish keyboard
              ;; layout and has to be typed twice. "å" is next to it.
              ("å" . dired-up-directory)
              ;; from nautilus:
              ("C-S-n" . mkdir)
              ("<f2>" . dired-do-rename))
  :custom
  (dired-recursive-deletes 'always)
  (dired-recursive-copies 'always)
  (dired-dwim-target t))
#+end_src

**** dired: use ~hl-line-mode~ and hide cursor
But show cursor in ~wdired-mode~
#+begin_src emacs-lisp
(add-hook 'dired-mode-hook #'hl-line-mode)

(defun aj/dired-no-cursor ()
  (setq cursor-type nil))

(add-hook 'dired-mode-hook #'aj/dired-no-cursor)

(defun aj/reset-cursor ()
  (kill-local-variable 'cursor-type))

(add-hook 'wdired-mode-hook #'aj/reset-cursor)

(advice-add 'wdired-change-to-dired-mode :after #'aj/dired-no-cursor)
#+end_src

**** De-emphasize dired details
#+begin_src emacs-lisp
(with-eval-after-load 'dired
  (add-to-list 'dired-font-lock-keywords
               (cons directory-listing-before-filename-regexp
                     '(0 'shadow append))
               t))
#+end_src

**** dired-git-info
#+begin_src emacs-lisp
(use-package dired-git-info
    :bind (:map dired-mode-map
                (")" . dired-git-info-mode)))
#+end_src
**** Dired collapse
#+begin_src emacs-lisp
(use-package dired-collapse
  ;; :after dired
  :defer t
  :init (add-hook 'dired-mode-hook #'dired-collapse-mode))
#+end_src
**** dired-hide-dotfiles
#+begin_src emacs-lisp
(use-package dired-hide-dotfiles
  :bind (:map dired-mode-map
              ("." . dired-hide-dotfiles)))
#+end_src
**** Dired subtree
#+begin_src emacs-lisp
(use-package dired-subtree
  :defer t
  :after dired
  :config (setq dired-subtree-use-backgrounds nil)
  :bind (:map dired-mode-map
              ("TAB" . dired-subtree-cycle)))
#+end_src

**** Dired-narrow
#+begin_src emacs-lisp
(use-package dired-narrow
  :commands dired-narrow)
#+end_src

**** Dired-du
#+begin_src emacs-lisp
(use-package dired-du
  :defer t
  :config (validate-setq dired-du-size-format t
                         dired-du-update-headers t))
#+end_src

**** COMMENT Extract archives from dired
A simple command to run ~file-roller -h~ for extracting archives in current directory
#+begin_src emacs-lisp
(defun aj/dired-extract-archive-here (&optional arg)
  (interactive "P")
  ;; (dolist (f (dired-map-over-marks
  ;;             (cons (dired-get-filename) (point)) arg))
  ;;   (call-process "file-roller" nil nil nil "-h" f))
  )
#+end_src

**** Sorting and listing-switches (dired-quick-sort)
https://gitlab.com/xuhdev/dired-quick-sort/
But also my branch for persistent per-directory options.
https://gitlab.com/andersjohansson/dired-quick-sort/tree/dir-save
(including some other unmerged fixes).
#+begin_src emacs-lisp
(setq dired-listing-switches "-lhA")
(use-package dired-quick-sort
  :straight (:depth full :host gitlab :repo "xuhdev/dired-quick-sort"
                    :fork (:host gitlab :repo "andersjohansson/dired-quick-sort" :branch "dir-save"))
  :load-path "~/kodat/elisp/dired-quick-sort"
  :after dired
  :custom
  (dired-quick-sort-use-per-directory-options t)
  (dired-quick-sort-default-options '("version" ?n ?y "default"))
  (dired-quick-sort-key "s")
  :config
  (dired-quick-sort-setup))
#+end_src

But some of the options for listing-switches doesn’t work with remote sessions in tramp. Avoid this!
#+begin_src emacs-lisp
(add-hook 'dired-before-readin-hook #'aj/dired-no-remote-lsv)

(defun aj/dired-no-remote-lsv ()
  (when (file-remote-p default-directory)
    (setq-local
     dired-listing-switches "-al")
    (setq-local
     dired-actual-switches "-al")))
#+end_src

**** dired-toggle-sudo
#+begin_src emacs-lisp
(use-package dired-toggle-sudo
  :commands dired-toggle-sudo
  :bind (:map dired-mode-map
              ("C-c C-s" . dired-toggle-sudo)))
#+end_src

**** Dired-recent
Store visited directories in a list
#+begin_src emacs-lisp
(use-package dired-recent
  :custom
  (dired-recent-max-directories 300)
  :bind (:map dired-recent-mode-map
              ("C-x C-d" . nil))
  :config

  ;; (setq dired-recent-mode-map (make-sparse-keymap))
  (dired-recent-mode 1)
  ;; cleanup once a day or something (emacs is often running at 16:10)
  (run-at-time "16:10" nil #'dired-recent-cleanup)

  ;;add source to consult-dir
  (with-eval-after-load 'consult-dir
    (defun aj/consult-dir-dired-recent ()
      (consult-dir--filter-hashed dired-recent-directories))

    (defvar aj/consult-dir--source-dired-recent
      `( :name "Dired recent"
         :narrow ?r
         :category file
         :face consult-file
         :history file-name-history
         :items ,#'aj/consult-dir-dired-recent)
      "Dired recent source for `consult-dir--pick'.")

    (add-to-list 'consult-dir-sources 'aj/consult-dir--source-dired-recent 'append)))
#+end_src


*** Ignore more files for normal completion
#+begin_src emacs-lisp
(with-eval-after-load 'latex
  (dolist (ext LaTeX-clean-intermediate-suffixes)
    (add-to-list 'completion-ignored-extensions (replace-regexp-in-string "\\\\" "" ext))))
#+end_src
*** Always offer to create new directories for ~read-file-name~
Advises ~read-file-name~ to always ask if non-existent directories should be created. Adding a non-existent directory otherwise causes errors in lots of commands calling ~read-file-name~.

This works for instance in ~dired-do-rename~ or ~mu4e-view-save-attachment~.
#+begin_src emacs-lisp
(defun aj/create-non-existent-directories (filename)
  (unless (file-exists-p filename)
    (let ((dirname (file-name-directory filename)))
      (when (and (not (file-directory-p dirname))
                 (y-or-n-p (format "Directory %s doesn't exist, create it?" dirname)))
        (make-directory dirname t))))
  filename)

(advice-add 'read-file-name :filter-return #'aj/create-non-existent-directories)
#+end_src

*** Make directories as needed (overlap with above?)
#+begin_src emacs-lisp
(defun aj/ff-mkdir ()
  (let ((filename (buffer-file-name)))
	(unless (or (eq nil filename) (file-exists-p filename))
	  (let ((dir (file-name-directory filename)))
		(unless (file-exists-p dir)
		  (make-directory dir t))))))

(add-hook 'find-file-hook 'aj/ff-mkdir)
(add-hook 'before-save-hook 'aj/ff-mkdir)
#+end_src

*** Read-only-directories
Define a dir-locals class and add directories which should by default be read-only there. (most importantly ~straight/build~)
#+begin_src emacs-lisp
(dir-locals-set-class-variables 'read-only-dir '((nil (eval read-only-mode))))

(dir-locals-set-directory-class
 "~/.emacs.d/straight/build/" 'read-only-dir)
#+end_src

** Password-store
Customizations for ~password-store~ and ~pass-mode.~

I also want a function that places the newly generated password in the kill ring: ~aj/password-store-generate-and-copy.~

Last, a few functions to git push, pull and run ~magit~ on the password store.

#+begin_src emacs-lisp
(use-package auth-source-pass
  :after auth-source
  :config (auth-source-pass-enable))

(use-package password-store
  :defer t
  :custom (password-store-password-length 47)
  :config

  (defun aj/password-store-generate (oldfun entry &optional password-length _no-symbols)
    (interactive (list (aj/password-store-get-new-entry-with-completion)
                       (when current-prefix-arg
                         (abs (prefix-numeric-value current-prefix-arg)))))
    ;;we get nil when everything is fine, otherwise probably an error
    ;;is signalled
    (unless (apply oldfun entry password-length) entry))

  (advice-add 'password-store-generate :around #'aj/password-store-generate)

  (defun aj/password-store-generate-and-copy ()
    (interactive "P")
    (let ((entry (aj/password-store-get-new-entry-with-completion)))
      (password-store--run-generate entry 37 replace)
      (password-store-copy entry))
    ;; (password-store-copy
    ;;  (call-interactively #'password-store-generate))
    )

  (defun aj/password-store-generate-and-copy-simpler ()
    (interactive "P")
    (let ((entry (aj/password-store-get-new-entry-with-completion)))
      (password-store--run-generate entry 19 replace t)
      (password-store-copy entry)))

  (defun aj/password-store-generate-and-copy-words (&optional number-of-words)
    (interactive "p")
    (let ((entry (aj/password-store-get-new-entry-with-completion)))
      (password-store-insert entry
                             (aj/password-store-get-random-sv-pass
                              (cl-case number-of-words
                                (1 4)
                                (t number-of-words))))
      (password-store-copy entry)))

  (defun aj/password-store-get-random-sv-pass (&optional num)
    (with-temp-buffer
      (insert-file-contents "/usr/share/hunspell/sv_SE.dic")
      (cl-loop with max = (point-max)
               repeat (or num 4)
               collect (progn
                         (goto-char (random max))
                         (forward-line 0)
                         (when (search-forward-regexp "[^/]+" (point-at-eol))
                           (match-string 0)))
               into words
               finally return
               (string-join words "-"))))

  (defun aj/password-store-get-new-entry-with-completion ()
    (thread-last (read-file-name "Test: " "~/.password-store/")
                 (string-remove-prefix "~/.password-store/")
                 (string-remove-suffix ".gpg"))))

(use-package pass
  :defer t
  :config
  (bind-keys :map pass-mode-map
             ("P" . aj/pass-git-push)
             ("F" . aj/pass-git-pull)
             ("m" . aj/pass-magit)
             ("W" . aj/password-store-generate-and-copy)
             ("v" . aj/password-store-generate-and-copy-simpler)
             ("V" . aj/password-store-generate-and-copy-words)
             ("Q" . aj/pass-display-qr))

  (defun aj/pass-git-push ()
    (interactive)
    (password-store--run-git "push"))
  (defun aj/pass-git-pull ()
    (interactive)
    (password-store--run-git "pull"))
  (defun aj/pass-magit ()
    (interactive)
    (magit-status "~/.password-store"))

  (defun aj/pass-display-qr ()
    (interactive)
    (pass--with-closest-entry entry
                              (password-store--run "show" "-q" entry)))

  (defun aj/pass-display-header-extra ()
    (pass--display-keybindings
     '((aj/password-store-generate-and-copy . "Gen + copy")
       (aj/password-store-generate-and-copy-simpler . "Gen + copy simpler")
       (aj/password-store-generate-and-copy-words . "Gen + copy words")))
    (insert "\n")
    (pass--display-keybindings '((aj/pass-git-push . "Git push")
                                 (aj/pass-git-pull . "Git pull")
                                 (aj/pass-magit . "Launch magit")))
    (insert "\n")
    (pass--display-keybindings '((aj/pass-display-qr . "View QR-code")))
    (newline)
    (newline))

  (advice-add 'pass-display-header :after #'aj/pass-display-header-extra)
  )
#+end_src
** LaTeX
*** Config variables for latex :org_async:
#+begin_src emacs-lisp
(with-eval-after-load 'tex
  (setq TeX-process-asynchronous t
        TeX-auto-save t
        TeX-parse-self t ;parse on load
        TeX-auto-save t ;parse on save
        TeX-auto-local ".auctex-auto" ; more sensible directory name
        TeX-style-local ".auctex-auto"
        TeX-auto-private '("~/.emacs.d/auctex/.auctex-auto")
        LaTeX-babel-hyphen nil ; Disable language-specific hyphen insertion.
        LaTeX-clean-intermediate-suffixes
        '("\\.aux" "\\.bbl" "\\.blg" "\\.brf" "\\.fot" "\\.glo" "\\.gls" "\\.idx" "\\.ilg" "\\.ind" "\\.lof"  "\\.lot" "\\.nav" "\\.out" "\\.snm" "\\.toc" "\\.url" "\\.synctex\\.gz" "\\.run\\.xml" "\\.bcf" "\\.fdb_latexmk" "\\.upa" "\\.fls" "\\.lox" "\\.log")
        LaTeX-clean-output-suffixes '("\\.dvi" "\\.pdf" "\\.ps" "\\.xdv" "\\.pdfpc")
        LaTeX-csquotes-close-quote "}"
        LaTeX-csquotes-open-quote "\\enquote{"
        TeX-arg-cite-note-p t
        TeX-fold-auto nil
        TeX-fold-macro-spec-list
        '(("[f]"
           ("footnote" "marginpar"))
          ("[n:{1}]"
           ("fxnote" "fxwarning" "fxerror" "fxfatal"))
          ("[nr: {1}]"
           ("fxrnote" "fxrwarning" "fxrerror" "fxrfatal"))
          ("[nri: {1}]"
           ("fxrnoteinline" "fxrwarninginline" "fxrerrorinline" "fxrfatalinline"))
          ("[c]"
           ("cite"))
          ("[l]"
           ("label"))
          ("[r]"
           ("ref" "pageref" "eqref"))
          ("[i]"
           ("index" "glossary"))
          ("[1]:||*"
           ("item"))
          ("…"
           ("dotsppp"))
          ("(C)"
           ("copyright"))
          ("(R)"
           ("textregistered"))
          ("TM"
           ("texttrademark"))
          (1
           ("part" "subparagraph" "part*" "subparagraph*" "emph" "textit" "textsl" "textmd" "textrm" "textsf" "texttt" "textbf" "textsc" "textup"))
          ("C. {1}"
           ("chapter" "chapter*"))
          ("S. {1}"
           ("section" "section*"))
          ("SS. {1}"
           ("subsection" "subsection*"))
          ("SSS. {1}"
           ("subsubsection" "subsubsection*"))
          ("━━━━━━━━━━━━━━━━{1}"
           ("paragraph" "paragraph*"))
          ("({1}:[1])"
           ("autocite" "autocite*"))
          ("[A: {1}]"
           ("citeauthor" "citeauthor*"))
          ("[T: {1}]"
           ("citetitle" "citetitle*"))
          ((lambda
             (&rest ci)
             (setq ret nil)
             (concat "("
                     (substring
                      (dolist
                          (cc ci ret)
                        (setq ret
                              (concat ret cc ", ")))
                      0 -2)
                     ")"))
           ("autocites" "autocites*"))
          ("»{2}«"
           ("foreigntextquote" "foreignquote"))
          ("»{1}«"
           ("textquote" "enquote"))
          ("―»{3}« ({2}:[1])―"
           ("foreignblockcquote"))
          ("»{3}« ({2}:[1])[2]"
           ("foreigntextcquote"))
          ("―»{2}« ({1}:[1])―"
           ("blockcquote"))
          ("»{2}« ({1}:[1])[2]"
           ("textcquote"))
          ("[…][{1}]||[…]"
           ("textelp"))
          ("[{1}][…]||[…]"
           ("textelp*"))
          ("[{1}]"
           ("textins" "textins*"))
          ("{2}"
           ("foreignlanguage")))
        TeX-macro-private '("~/texmf/tex/" "~/texmf/bibtex/bst/" "~/.texmf-config/tex/")
        TeX-modes '(texinfo-mode latex-mode doctex-mode)
        TeX-quote-language-alist '(("swedish" "\\enquote{" "}" nil))
        TeX-style-private '("~/.emacs.d/auctex/.auctex-style")
        bibtex-dialect 'biblatex
        cdlatex-command-alist
        '(("bra" "Insert bra, place point inside" "\\bra{?}" cdlatex-position-cursor nil nil t)
          ("ket" "Insert ket, place point inside" "\\ket{?}" cdlatex-position-cursor nil nil t)
          ("braket" "Insert bracket, point inside" "\\braket{?}" cdlatex-position-cursor nil nil t))
        cdlatex-math-symbol-alist '((43 ("\\cup" "\\dagger")))
        flyspell-tex-command-regexp
        "\\(\\(begin\\|end\\)[ 	]*{\\|\\(cite[a-z*]*\\|label\\|ref\\|eqref\\|input\\|usepackage\\|documentclass\\)[ 	]*\\(\\[[^]]*\\]\\)?{[^{}]*\\)"
        font-latex-math-environments
        '("display" "displaymath" "equation" "eqnarray" "gather" "multline" "align" "alignat" "xalignat" "dmath")
        font-latex-user-keyword-classes
        '(("fxnote"
           (("fxnote" "[{")
            ("fxrnote" "{"))
           font-lock-comment-face command)
          ("fxwarningerrorfatal"
           (("fxfatal" "[{")
            ("fxerror" "[{")
            ("fxwarning" "[{")
            ("fxrfatal" "{")
            ("fxrerror" "{")
            ("fxrwarning" "{"))
           font-latex-warning-face command)
          ("autocites"
           (("autocites" "[[{[[{")
            ("autocites" "[[{[[{[[{")
            ("autocites" "[[{[[{[[{[[{")
            ("autocites" "[[{[[{[[{[[{[[{"))
           font-lock-constant-face command))
        reftex-bibliography-commands '("bibliography" "nobibliography" "addbibresource")))

(setq-default TeX-master 'dwim
              TeX-PDF-mode t) ;PDF by default


;; replacing \\par with a non-displaying character is just stupid
(with-eval-after-load "tex-mode"
  (setq tex--prettify-symbols-alist (delete '("\\par" . ? 
) tex--prettify-symbols-alist)))
#+end_src

*** Use pdf-tools
#+begin_src emacs-lisp
(defun th/pdf-view-revert-buffer-maybe (file)
  (when-let ((buf (find-buffer-visiting file)))
    (with-current-buffer buf
      (when (derived-mode-p 'pdf-view-mode)
        (pdf-view-revert-buffer t t)))))

(with-eval-after-load 'tex-buf
  ;; only care about pdf
  (setq TeX-view-program-selection '((output-pdf "PDF Tools")))
  (add-hook 'TeX-after-compilation-finished-functions
            #'th/pdf-view-revert-buffer-maybe))


;; (with-eval-after-load 'pdf-sync
;;   (defun aj/locate-synctex-file (pdffile)
;;     (let ((default-directory
;;             (concat (file-name-directory pdffile) "/.tex-aux"))
;;           (basename (file-name-sans-extension
;;                      (file-name-nondirectory pdffile))))
;;       (cl-labels ((file-if-exists-p (file)
;;                                     (and (file-exists-p file)
;;                                          file)))
;;         (or (file-if-exists-p
;;              (expand-file-name (concat basename ".synctex.gz")))
;;             (file-if-exists-p
;;              (expand-file-name (concat basename ".synctex")))
;;             ;; Some pdftex quote the basename.
;;             (file-if-exists-p
;;              (expand-file-name (concat "\"" basename "\"" ".synctex.gz")))
;;             (file-if-exists-p
;;              (expand-file-name (concat "\"" basename "\"" ".synctex")))))))

;;   (add-hook 'pdf-sync-locate-synctex-file-functions #'aj/locate-synctex-file))
#+end_src
*** Open pdf in emacsclient in async mode :org_async:no_default_tangle:
DONE?:
skriva wrapper/alternativ funktion till TeX-pdf-tools-sync-view, som tar ett filnamn och sedan binder den så att TeX-pdf-tools-sync-view ser den, alt gör motsvarande saker. Denna funktion ska köras i normala emacsclient.

Filnamnet måste skickas med till "processen" emacsclient, hur inline en emacsvariabel i ett emacs-process-call?

#+begin_src emacs-lisp
(with-eval-after-load 'tex
  (setq TeX-view-program-list
        '(("emacsclient pdft"
           "emacsclient -e \"(progn (pop-to-buffer (or (find-buffer-visiting \\\"%o\\\") (find-file-noselect \\\"%o\\\"))) (revert-buffer) (alert \\\"Latexmk klar\\\" :title \\\"Org export latexmk\\\" :style 'libnotify))\"")))
  (setq TeX-view-program-selection '((output-pdf "emacsclient pdft"))))
#+end_src

*** Extra latex bindings
#+begin_src emacs-lisp
(with-eval-after-load 'latex
  (bind-keys
   :map LaTeX-mode-map
   ("C-c ä" . TeX-next-error)
   ("C-c w" . latex-word-count)
   ("C-<f1>" . TeX-doc)
   ("C-c C-a" . TeX-command-two-paragraphs)))
#+end_src

*** Extra latex commands
**** latex word count
#+begin_src emacs-lisp
(with-eval-after-load 'latex
  (defun latex-word-count (&optional arg)
    (interactive "P")
    (let*
        ((this-file (buffer-file-name))
         (this-dir default-directory)
         (enc-str (symbol-name buffer-file-coding-system))
         (enc-opt
          (cond
           ((string-match "utf-8" enc-str) "-utf8")
           ((string-match "latin" enc-str) "-latin1")
           ("-encoding=guess")
           )))
      (if arg
          ;; (shell-command (concat "texcount" " -inc" " -v2 " "-opt=$HOME/.texcount "
          ;;                         enc-opt " \"" this-file
          ;; "\""))
          (let ((tcb (generate-new-buffer "*texcount*")))
            (call-process "texcount" nil tcb nil "-inc"
                          "-v2 " (concat "-opt=" (getenv "HOME") "/.texcount") enc-opt this-file)
            (pop-to-buffer tcb)
            (ansi-color-apply-on-region (point-min) (point-max)))
        (message
         (with-output-to-string
           (with-current-buffer standard-output
             (cd this-dir) ;för att inkluderade filer ska läsas rätt
             (call-process "texcount" nil t nil "-total" "-0" "-inc"
                           "-opt=~/.texcount" enc-opt this-file))))))))
#+end_src

**** tex-command-two-paragraphs
#+begin_src emacs-lisp
(with-eval-after-load 'latex
  (defun TeX-command-two-paragraphs ()
    "Mark two sentences backward and run TeX-command-region, useful for exporting the latest text"
    (interactive)
    (save-excursion
      (mark-paragraph -2)
      (TeX-command-region))))
#+end_src

*** Extra modes to enable for latex-mode
#+begin_src emacs-lisp
(dolist (mode '(turn-on-reftex
                ;; latex-extra-mode
                TeX-fold-mode))
  (add-hook 'LaTeX-mode-hook mode))
#+end_src

*** Latexmk-command for normal export
#+begin_src emacs-lisp
(declare-function TeX-run-TeX "tex-buf")
(defvar TeX-save-query)

(with-eval-after-load 'tex-buf
  (defun aj/TeX-run-latexmk (name command file)
    (interactive)
    (let ((TeX-save-query nil))
      (TeX-save-document "")
      (TeX-run-TeX name command file)))

  (setq TeX-error-overview-open-after-TeX-run t))
#+end_src

*** Latexmk-commands for org-async export :org_async:no_default_tangle:
#+begin_src emacs-lisp
(declare-function TeX-run-TeX "tex-buf") (defvar TeX-command-buffer nil)
(with-eval-after-load 'tex-buf
  (defun aj/TeX-run-latexmk (name command file)
    (interactive)
    (let ((TeX-save-query nil)
          (TeX-process-asynchronous nil))
      (TeX-save-document "")
      (TeX-run-TeX name command file)
      (with-current-buffer TeX-command-buffer (TeX-view)))))
#+end_src

*** Customize Tex-commands :org_async:
#+begin_src emacs-lisp
(with-eval-after-load 'tex-buf
  (setq LaTeX-command-style '(("" "%(PDF)%(latex) -file-line-error %(extraopts) %S%(PDFout)")))

  (add-to-list 'TeX-command-list '("LaTeX shell-escape" "%`%l --shell-escape %(mode)%' %t" TeX-run-TeX t (latex-mode doctex-mode)))
  (add-to-list 'TeX-command-list '("Nomenclature" "makeindex %s.nlo -s nomencl.ist -o %s.nls" TeX-run-command t t))
  (add-to-list 'TeX-command-list '("cleanmk" "latexmk -c -g -pdf -e '$pdflatex=~s/pdflatex %%O %%S/%l%(mode) %%O %%S/' %s" TeX-run-discard nil t :help "Clean with latexk"))
  (add-to-list 'TeX-command-list '("xelatexmk" "latexmk -g -recorder -xelatex -pv %s" aj/TeX-run-latexmk nil nil :help "Run XeLatexmk on file"))
  (add-to-list 'TeX-command-list '("latexmk" "latexmk -g -pdf -e '$pdflatex=~s/pdflatex %%O %%S/%l%(mode) %%O %%S/' %s" aj/TeX-run-latexmk nil t :help "Run Latexmk on file")))

(setq-default TeX-command-default "latexmk")
#+end_src

*** Reftex
Add biblatex formats
#+begin_src emacs-lisp
(with-eval-after-load 'reftex-vars
  (setq reftex-cite-prompt-optional-args t
        reftex-plug-into-AUCTeX t
        reftex-cite-format
        '((?a . "\\autocite[]{%l}")
          (?\C-a . "\\autocite*[]{%l}")
          (?A . "\\autocites[]{%l}")
          (?t . "\\textcite[]{%l}")
          (?u . "\\citeauthor[]{%l}")
          (?\C-u . "\\citeauthor*{%l}")
          (?\C-t . "\\citetitle[]{%l}")
          (?l . "%l")
          (?\C-l . "[]{%l}") ;for adding more references in an autocites
          (?\C-m . "\\cite[]{%l}")
          (?f . "\\footcite[]{%l}")
          (?p . "\\parencite[]{%l}")
          (?\C-y . "\\citeyear[]{%l}")
          (?n . "\\nocite{%l}"))))
#+end_src
*** Tex-fold linebreaks
https://github.com/andersjohansson/tex-fold-linebreaks
#+begin_src emacs-lisp
(use-package tex-fold-linebreaks
  :straight (:host gitlab :repo "andersjohansson/tex-fold-linebreaks")
  :commands tex-fold-linebreaks-mode
  :config (setq tex-fold-linebreaks-non-sentence-punctuation-regexp
                "\\([0-9]\\|[[:space:]]\\([[:alpha:]]\\|t\\.ex\\|m\\.fl\\|bl\\|bl\\.a\\|e\\.g\\|i\\.e\\)?\\)$"))
#+end_src
** Window management and navigation
*** Repeat mode
#+begin_src emacs-lisp
(use-package repeat
  :custom (repeat-exit-timeout 5)
  :config (repeat-mode)

  (with-eval-after-load 'org
    (defvar aj/org-mode-navigation-repeat-map
      (let ((map (make-sparse-keymap)))
        (define-key map (kbd "C-b") #'org-backward-heading-same-level)
        (define-key map (kbd "b") #'org-backward-heading-same-level)
        (define-key map (kbd "C-f") #'org-forward-heading-same-level)
        (define-key map (kbd "f") #'org-forward-heading-same-level)
        (define-key map (kbd "C-n") #'org-next-visible-heading)
        (define-key map (kbd "n") #'org-next-visible-heading)
        (define-key map (kbd "C-p") #'org-previous-visible-heading)
        (define-key map (kbd "p") #'org-previous-visible-heading)
        (define-key map (kbd "C-u") #'outline-up-heading)
        (define-key map (kbd "u") #'outline-up-heading)
        map))

    (dolist (command '(org-backward-heading-same-level
                       org-forward-heading-same-level
                       org-next-visible-heading
                       org-previous-visible-heading))
      (put command 'repeat-map 'aj/org-mode-navigation-repeat-map))))




;; (defmacro aj/create-repeat-map (mapname &rest bindings)
;;   (declare (indent 1))
;;   `(defvar ,mapname (make-sparse-keymap))
;;   (let (exps)
;;     (cl-loop for (key command) in bindings collect
;;              `(progn (define-key ,mapname (kbd ,key) #',command)
;;                      (put #',command 'repeat-map ,mapname))
;;              into exps
;;              )
;;     `(progn ,exps))
;;   ;; `(let ((map (make-sparse-keymap)))
;;   ;;    ,(cl-loop for (key command) in bindings do
;;   ;;              `(progn (define-key 'map (kbd ,key) #',command)
;;   ;;                      (put #',command 'repeat-map ',mapname)))

;;   ;;    (defvar mapname map))
;;   )

;; (macroexpand-all (aj/create-repeat-map 'aj/test-map
;;                    ("1" aj/test-cmd-1)
;;                    ("2" aj/test-cmd-2)))

;; (defun aj/test-cmd-1
;;     (interactive)
;;   (message "1"))
;; (defun aj/test-cmd-2
;;     (interactive)
;;   (message "2"))



#+end_src
*** Bindings for ~other-window~ and ~next/previous-buffer~.

~other-window~ with ~<C-tab>~ and ~<C-S-tab>~ (like switching tabs in firefox).

Swich to  ~other-buffer~ with ~C-§~.

#+begin_src emacs-lisp
(unbind-key "C-x o") ; to get out of that habit

(bind-keys
 ("C-<tab>" . other-window)
 ("C-<iso-lefttab>" . aj/back-window))

(use-package buffer-flip
  :bind  (("C-§" . buffer-flip)
          :map buffer-flip-map
          ( "C-§" . buffer-flip-forward)
          ( "C-½" . buffer-flip-backward)
          ( "C-g" . buffer-flip-abort)))

;; (defun aj/switch-to-other-buffer ()
;;   (interactive)
;;   (switch-to-buffer nil))
;; ("C-§" . aj/switch-to-other-buffer)
;; ("C-½" . previous-buffer)

;; (bind-keys
;;  ("C-§" . iflipb-next-buffer)
;;  ("C-½" . iflipb-previous-buffer))

(defun aj/back-window ()
  (interactive)
  (other-window -1))

(defun aj/select-minibuffer-window ()
  (interactive)
  (when-let (w (active-minibuffer-window))
    (select-window w)))

(bind-key "M-§" #'aj/select-minibuffer-window)

#+end_src

*** beginend (redefine beginning and end of buffer in a smart way for special buffers)
#+begin_src emacs-lisp
(use-package beginend
  :init (beginend-setup-all))
#+end_src

*** Window management variables
#+begin_src emacs-lisp
(setq split-width-threshold 130)
#+end_src

*** Window dividers :ARCHIVE:
#+begin_src emacs-lisp
(setq window-divider-default-right-width) 2
(add-hook 'window-setup-hook #'window-divider-mode)
#+end_src

*** Window management hydra
#+begin_src emacs-lisp
(bind-key "C-'" #'hydra-window/body)

(defhydra hydra-window (:hint nil :idle 1.0)
  "
Split^^            ^Switch^       ^Resize^     ^Other^
_2_ vertical       _r_otate CW    _<left>_  ←  _o_ Pop out frame
_3_ horizontal     _e_ rotate CCW _<down>_  ↓
_1_ only this      _R_otate 180°  _<up>_    ↑
_0_ delete         _t_ranspose    _<right>_ →
_z_ undo                        _=_ balance
_Z_ redo
_F_ollow
"
  ("<left>" aj/hydra-move-splitter-left)
  ("<down>" aj/hydra-move-splitter-down)
  ("<up>" aj/hydra-move-splitter-up)
  ("<right>" aj/hydra-move-splitter-right)
  ("=" balance-windows :color blue)

  ("2" split-window-below :color blue)
  ("3" split-window-right :color blue)
  ("0" delete-window :color blue)
  ("1" delete-other-windows :color blue)

  ("C-2" split-window-below :color blue)
  ("C-3" split-window-right :color blue)
  ("C-0" delete-window :color blue)
  ("C-1" delete-other-windows :color blue)

  ("o" aj/pop-out-buffer-to-new-frame :color blue)

  ("r" rotate-frame-clockwise)
  ("e" rotate-frame-anti-clockwise)
  ("R" rotate-frame)
  ("t" transpose-frame)
  ("F" follow-mode :color blue)
  ("z" (progn
         (winner-undo)
         (setq this-command 'winner-undo)))
  ("Z" winner-redo)
  ("q" nil))

(winner-mode)

(use-package transpose-frame
  :commands ( transpose-frame flip-frame flop-frame rotate-frame
              rotate-frame-clockwise
              rotate-frame-anti-clockwise))


(defun aj/hydra-move-splitter-left (arg)
  "Move window splitter left."
  (interactive "p")
  (if (window-in-direction 'right)
      (shrink-window-horizontally arg)
    (enlarge-window-horizontally arg)))

(defun aj/hydra-move-splitter-right (arg)
  "Move window splitter right."
  (interactive "p")
  (if (window-in-direction 'right)
      (enlarge-window-horizontally arg)
    (shrink-window-horizontally arg)))

(defun aj/hydra-move-splitter-up (arg)
  "Move window splitter up."
  (interactive "p")
  (if (window-in-direction 'up)
      (enlarge-window arg)
    (shrink-window arg)))

(defun aj/hydra-move-splitter-down (arg)
  "Move window splitter down."
  (interactive "p")
  (if (window-in-direction 'up)
      (shrink-window arg)
    (enlarge-window arg)))


(defun aj/pop-out-buffer-to-new-frame ()
  "Move current buffer to a new frame."
  (interactive)
  (let ((win (selected-window)))
    (make-frame)
    (with-selected-window win
      (previous-buffer))))
#+end_src

*** Frame managment hydra (~C-x 5~ alternative)
#+begin_src emacs-lisp
(defhydra hydra-frame (:idle 1.0 :color blue)
  ("0" delete-frame "Delete frame")
  ("2" make-frame-command "New frame")
  ("M-0" delete-frame "Delete frame")
  ("M-2" make-frame-command "New frame"))

(bind-key "M-'" #'hydra-frame/body)
#+end_src

*** swap window buffers by drag and drop
#+begin_src emacs-lisp
(defun th/swap-window-buffers-by-dnd (drag-event)
  "Swaps the buffers displayed in the DRAG-EVENT's start and end
window."
  (interactive "e")
  (let ((start-win (cl-caadr drag-event))
        (end-win   (cl-caaddr drag-event)))
    (when (and (windowp start-win)
               (windowp end-win)
               (not (eq start-win end-win))
               (not (memq (minibuffer-window)
                          (list start-win end-win))))
      (let ((bs (window-buffer start-win))
            (be (window-buffer end-win)))
        (unless (eq bs be)
          (set-window-buffer start-win be)
          (set-window-buffer end-win bs))))))

(bind-key "<C-S-drag-mouse-1>" #'th/swap-window-buffers-by-dnd)
#+end_src

*** Narrowing
Do everything with ~C-x n~.
http://endlessparentheses.com/emacs-narrow-or-widen-dwim.html
#+begin_src emacs-lisp
(put 'narrow-to-region 'disabled nil)

(defun aj/narrow-or-widen-dwim (p)
  "Widen if buffer is narrowed, narrow-dwim otherwise.
Dwim means: region, org-src-block, org-subtree, or defun,
whichever applies first. Narrowing to org-src-block actually
calls `org-edit-src-code'.

With prefix P, don't widen, just narrow even if buffer is
already narrowed."
  (interactive "P")
  (declare (interactive-only))
  (cond ((and (buffer-narrowed-p) (not p)) (widen))
        ((and (boundp 'org-src-mode) org-src-mode (not p))
         (org-edit-src-exit)) ;leave org-src, we don’t narrow
                                        ;automatically there
        ((region-active-p)
         (narrow-to-region (region-beginning) (region-end)))
        ((derived-mode-p 'org-mode)
         ;; `org-edit-src-code' is not a real narrowing command.
         ;; Remove this first conditional if you don't want it.
         (cond ((ignore-errors (org-edit-src-code))
                t)
               ;; (delete-other-windows))
               ((ignore-errors (org-narrow-to-block) t))
               (t (org-narrow-to-subtree))))
        (t (narrow-to-defun))))

(define-key ctl-x-map "n" #'aj/narrow-or-widen-dwim)
(with-eval-after-load 'org-keys
  ;; override three separate C-x n * bindings
  (bind-keys :map org-mode-map
             ("C-x n s" . nil)
             ("C-x n b" . nil)
             ("C-x n e" . nil)
             ("C-x n" . aj/narrow-or-widen-dwim)))
;; (unbind-key "C-x n" org-mode-map)

;; For leaving org-src-edit, use C-c C-c, like magit-commit etc.
(with-eval-after-load 'org-src
  (define-key org-src-mode-map "\C-c\C-c" #'org-edit-src-exit))

(defun aj/narrow-clone ()
  (interactive)
  (unless (and (boundp 'org-src-mode) org-src-mode)
    (if-let ((bb (buffer-base-buffer)))
        (progn
          (kill-buffer)
          (pop-to-buffer bb))
      (clone-indirect-buffer nil t)
      (aj/narrow-or-widen-dwim nil))))

(define-key ctl-x-map "N" #'aj/narrow-clone)
#+end_src

*** Centered-cursor-mode
#+begin_src emacs-lisp
(use-package centered-cursor-mode
  :straight (:host github :repo "andre-r/centered-cursor-mode.el" :branch "dev")
  :config
  ;; Bad advice in my opinion, as it breaks info scrolling onto next node:
  (advice-remove 'Info-scroll-down #'centered-cursor-replace-scroll-down--around)
  (advice-remove 'Info-scroll-up #'centered-cursor-replace-scroll-up--around)
  )
#+end_src

** Searching and stuff

*** wgrep, for editing via grep buffers
Should also work for consult-embark exported searches
#+begin_src emacs-lisp
(use-package wgrep
  ;; a kind of autoload that should be neccessary
  :hook (grep-setup . wgrep-setup)
  :custom
  ;; like the binding for ‘dired-toggle-read-only’ for wdired
  (wgrep-enable-key "\C-x\C-q")
  (wgrep-auto-save-buffer t))
#+end_src

*** Deadgrep
Use deadgrep for control of searching. Also use [[https://github.com/phiresky/ripgrep-all][ripgrep-all]], to enable searching in pdfs etc.
#+begin_src emacs-lisp
(use-package deadgrep
  :custom (deadgrep-executable "rga"))
#+end_src

*** Search customizations
**** Isearch
#+begin_src emacs-lisp
(use-package isearch
  :straight nil
  :custom
  (isearch-lazy-count t)
  (isearch-allow-scroll t)
  (isearch-yank-on-move 'shift))
#+end_src

**** Smarter default search with char-folding
#+begin_src emacs-lisp
(setq search-default-mode #'char-fold-to-regexp)

;; In Swedish, å, ä, and ö are separate wovels (not umlauts), and
;; confusing to fold them to a and o
(use-package char-fold
  :custom (char-fold-exclude '((?a "å") (?a "ä") (?o "ö")
                               (?A "Å") (?A "Ä") (?O "Ö"))))
#+end_src

**** Anzu: Shows number of search matches in modeline, replacements inline etc.
But we only use it for the nice query-replace display. Number of search matches is given by ~isearch-lazy-count~ since 27.1.
#+begin_src emacs-lisp
(use-package anzu
  :bind (("M-%" . anzu-query-replace)
         ("C-M-%" . anzu-query-replace-regexp)))
#+end_src


*** CTRLF :ARCHIVE:
A bit nicer than isearch. I also like to use fuzzy search (words separated by whatever) by default. It is also helpful to use char-fold (é → e) by default, so I define functions for that.
#+begin_src emacs-lisp
(use-package ctrlf
  :custom (ctrlf-default-search-style 'fuzzy-char-fold)
  :config
  (ctrlf-mode t)

  (defun aj/ctrlf-translate-fuzzy-char-fold (input)
    (ctrlf-translate-fuzzy-regexp (char-fold-to-regexp input)))

  (add-to-list
   'ctrlf-style-alist
   '(fuzzy-char-fold
     . (:prompt "fuzzy CF"
                :translator aj/ctrlf-translate-fuzzy-char-fold
                :case-fold ctrlf-no-uppercase-literal-p
                :fallback (isearch-forward . isearch-backward))))

  ;; (defun aj/ctrlf-forward-fuzzy-char-fold ()
  ;;   (interactive)
  ;;   (ctrlf-forward 'fuzzy-char-fold))
  ;; (defun aj/ctrlf-backward-fuzzy-char-fold ()
  ;;   (interactive)
  ;;   (ctrlf-backward 'fuzzy-char-fold))

  (add-hook 'pdf-isearch-minor-mode-hook (lambda () (ctrlf-local-mode -1)))
  (add-hook 'Info-mode-hook (lambda () (ctrlf-local-mode -1)))
  )


;; (defun ctrlf-disable-local-mode ()
;;   "Unconditionally disable ‘ctrlf-local-mode’."
;;   (ctrlf-local-mode -1))

;; (defcustom ctrlf-deny-mode-hooks
;;   '(pdf-isearch-minor-mode-hook
;;     Info-mode-hook)
;;   "List of mode hooks where ctrlf should be disabled."
;;   :type '(repeat variable))

;; ;; where should this be done?
;; (dolist (hook ctrlf-deny-mode-hooks)
;;   (add-hook hook #'ctrlf-disable-local-mode))
#+end_src


*** COMMENT yasnippet :ARCHIVE:
#+begin_src emacs-lisp
(use-package yasnippet
  :defer 6
  :config
  (yas-global-mode 1) ;välja specifika?
  (define-key yas-minor-mode-map (kbd "<tab>") nil)
  (define-key yas-minor-mode-map (kbd "TAB") nil)
  (add-hook 'yas-before-expand-snippet-hook (lambda () (smartparens-mode -1)))
  (add-hook 'yas-after-exit-snippet-hook (lambda () (smartparens-mode 1))))
#+end_src

** Hippie expand
#+begin_src emacs-lisp
(bind-key "C-å" #'hippie-expand)

;;some kind of default
(setq hippie-expand-try-functions-list
      '(;; yas-hippie-try-expand
        try-complete-file-name
        try-expand-all-abbrevs
        try-expand-dabbrev
        try-expand-dabbrev-all-buffers
        try-expand-dabbrev-from-kill
        try-complete-lisp-symbol-partially
        try-complete-lisp-symbol
        ;; ispell-complete-word
        try-complete-file-name-partially))

(add-hook 'text-mode-hook #'aj/hippie-expand-for-text-mode)
(add-hook 'prog-mode-hook #'aj/hippie-expand-for-prog-mode)
(add-hook 'emacs-lisp-mode-hook #'aj/hippie-expand-for-elisp)

(defun aj/hippie-expand-for-text-mode ()
  (setq-local hippie-expand-try-functions-list
              '(;; yas-hippie-try-expand
                try-expand-all-abbrevs
                try-expand-dabbrev
                try-expand-dabbrev-all-buffers
                try-expand-dabbrev-from-kill
                ;; ispell-complete-word
                try-complete-file-name
                try-complete-file-name-partially
                ;; try-complete-lisp-symbol-partially
                ;; try-complete-lisp-symbol
                )))

(defun aj/hippie-expand-for-prog-mode ()
  (setq-local hippie-expand-try-functions-list
              '(;; yas-hippie-try-expand
                try-complete-file-name
                try-expand-all-abbrevs
                try-expand-list
                try-expand-line
                try-complete-lisp-symbol-partially
                try-complete-lisp-symbol
                try-expand-dabbrev
                try-expand-dabbrev-all-buffers
                try-expand-dabbrev-from-kill
                try-complete-file-name-partially)))

(defun aj/hippie-expand-for-elisp ()
  (setq-local hippie-expand-try-functions-list
              '(;; yas-hippie-try-expand
                try-complete-lisp-symbol-partially
                try-complete-lisp-symbol
                try-complete-file-name
                try-complete-file-name-partially
                try-expand-all-abbrevs
                try-expand-dabbrev
                try-expand-dabbrev-all-buffers
                try-expand-dabbrev-from-kill
                try-expand-list
                try-expand-line)))
#+end_src

** undo-tree
#+begin_src emacs-lisp
(use-package undo-tree
  :defer 3
  :bind (("C-z" . undo-tree-undo) ("S-C-z" . undo-tree-redo))
  :config (global-undo-tree-mode)
  (setq undo-tree-auto-save-history nil
        undo-tree-visualizer-timestamps t
        undo-tree-visualizer-diff t)
  (defun aj/undo-tree-compress (filename)
    (concat filename ".gz"))
  (advice-add 'undo-tree-make-history-save-file-name :filter-return
              #'aj/undo-tree-compress))
#+end_src

** Version control, git and magit
*** Magit config
#+begin_src emacs-lisp
(use-package magit
  :bind
  (("C-x g" . magit-status)
   ("C-c g" . magit-dispatch)
   ("C-x M-g" . magit-file-dispatch)
   :map magit-section-mode-map
   ;; don’t steal C-TAB, which I use for ‘other-window’
   ("<C-tab>" . nil)
   ("C-c <C-tab>" . magit-section-cycle))
  :custom
  (magit-log-auto-more t)
  (magit-diff-refine-hunk t)
  ;; (magit-bury-buffer-function #'magit-mode-quit-window)
  :config
  (magit-auto-revert-mode -1) ;; I use global-auto-revert

  (add-hook 'git-commit-setup-hook #'git-commit-turn-on-flyspell)
  (add-hook 'git-commit-setup-hook
            (lambda () (setq fill-column 70)
              (ispell-change-dictionary "en_GB,sv_SE"))
            t))
#+end_src

*** magit-todos
#+begin_src emacs-lisp
(use-package magit-todos
  :after magit
  :commands magit-todos-mode
  :config (magit-todos-mode t))
#+end_src

*** Magit + difftastic
https://tsdh.org/posts/2022-08-01-difftastic-diffing-with-magit.html
#+begin_src emacs-lisp
(with-eval-after-load 'magit
  (defun th/magit--with-difftastic (buffer command)
    "Run COMMAND with GIT_EXTERNAL_DIFF=difft then show result in BUFFER."
    (let ((process-environment
           (cons (concat "GIT_EXTERNAL_DIFF=difft --width="
                         (number-to-string (frame-width)))
                 process-environment)))
      ;; Clear the result buffer (we might regenerate a diff, e.g., for
      ;; the current changes in our working directory).
      (with-current-buffer buffer
        (setq buffer-read-only nil)
        (erase-buffer))
      ;; Now spawn a process calling the git COMMAND.
      (make-process
       :name (buffer-name buffer)
       :buffer buffer
       :command command
       ;; Don't query for running processes when emacs is quit.
       :noquery t
       ;; Show the result buffer once the process has finished.
       :sentinel (lambda (proc event)
                   (when (eq (process-status proc) 'exit)
                     (with-current-buffer (process-buffer proc)
                       (goto-char (point-min))
                       (ansi-color-apply-on-region (point-min) (point-max))
                       (setq buffer-read-only t)
                       (view-mode)
                       (end-of-line)
                       ;; difftastic diffs are usually 2-column side-by-side,
                       ;; so ensure our window is wide enough.
                       (let ((width (current-column)))
                         (while (zerop (forward-line 1))
                           (end-of-line)
                           (setq width (max (current-column) width)))
                         ;; Add column size of fringes
                         (setq width (+ width
                                        (fringe-columns 'left)
                                        (fringe-columns 'right)))
                         (goto-char (point-min))
                         (pop-to-buffer
                          (current-buffer)
                          `(;; If the buffer is that wide that splitting the frame in
                            ;; two side-by-side windows would result in less than
                            ;; 80 columns left, ensure it's shown at the bottom.
                            ,(when (> 80 (- (frame-width) width))
                               #'display-buffer-at-bottom)
                            (window-width
                             . ,(min width (frame-width))))))))))))


  (defun th/magit-show-with-difftastic (rev)
    "Show the result of \"git show REV\" with GIT_EXTERNAL_DIFF=difft."
    (interactive
     (list (or
            ;; If REV is given, just use it.
            (when (boundp 'rev) rev)
            ;; If not invoked with prefix arg, try to guess the REV from
            ;; point's position.
            (and (not current-prefix-arg)
                 (or (magit-thing-at-point 'git-revision t)
                     (magit-branch-or-commit-at-point)))
            ;; Otherwise, query the user.
            (magit-read-branch-or-commit "Revision"))))
    (if (not rev)
        (error "No revision specified")
      (th/magit--with-difftastic
       (get-buffer-create (concat "*git show difftastic " rev "*"))
       (list "git" "--no-pager" "show" "--ext-diff" rev))))

  (defun th/magit-diff-with-difftastic (arg)
    "Show the result of \"git diff ARG\" with GIT_EXTERNAL_DIFF=difft."
    (interactive
     (list (or
            ;; If RANGE is given, just use it.
            (when (boundp 'range) range)
            ;; If prefix arg is given, query the user.
            (and current-prefix-arg
                 (magit-diff-read-range-or-commit "Range"))
            ;; Otherwise, auto-guess based on position of point, e.g., based on
            ;; if we are in the Staged or Unstaged section.
            (pcase (magit-diff--dwim)
              ('unmerged (error "unmerged is not yet implemented"))
              ('unstaged nil)
              ('staged "--cached")
              (`(stash . ,value) (error "stash is not yet implemented"))
              (`(commit . ,value) (format "%s^..%s" value value))
              ((and range (pred stringp)) range)
              (_ (magit-diff-read-range-or-commit "Range/Commit"))))))
    (let ((name (concat "*git diff difftastic"
                        (if arg (concat " " arg) "")
                        "*")))
      (th/magit--with-difftastic
       (get-buffer-create name)
       `("git" "--no-pager" "diff" "--ext-diff" ,@(when arg (list arg))))))

  (transient-define-prefix th/magit-aux-commands ()
    "My personal auxiliary magit commands."
    ["Auxiliary commands"
     ("d" "Difftastic Diff (dwim)" th/magit-diff-with-difftastic)
     ("s" "Difftastic Show" th/magit-show-with-difftastic)])


  (transient-append-suffix 'magit-dispatch "!"
    '("#" "My Magit Cmds" th/magit-aux-commands))
  (define-key magit-status-mode-map (kbd "#") #'th/magit-aux-commands))
#+end_src

*** Display tracked files
Sometimes I want to see what is tracked in a repository.
Define this as a global minor mode which adds a section in the magit status buffer (global because it seemed buggy to modify local value of ~magit-status-sections-hook~).  Inspired by magit-todos mode definition.

~j t~ (default magit binding) jumps to the section of tracked files.
#+begin_src emacs-lisp
(define-minor-mode magit-tracked-files-mode
  "Show list of tracked files in magit status buffer"
  :global t
  (if magit-tracked-files-mode
      (magit-add-section-hook 'magit-status-sections-hook
                              #'magit-insert-tracked-files
                              nil
                              'append)
    (remove-hook 'magit-status-sections-hook #'magit-insert-tracked-files))
  (magit-refresh))
#+end_src

*** forge
#+begin_src emacs-lisp
(use-package forge
  :after magit)
#+end_src

*** Use visual-line-mode in magit for repositories with mostly prose text
This can be enabled with a local variable ~aj/magit-visual-line-mode~ (set it as dir-local) or automatically if all the checked in files are org- or text-mode-based.
#+begin_src emacs-lisp
(defvar-local aj/magit-visual-line-mode nil
  "Enable visual-line-mode for magit if non-nil.
Set to symbol ‘disable’ to prevent activation of visual-line-mode.")
(put 'aj/magit-visual-line-mode 'safe-local-variable #'booleanp)

(add-hook 'magit-mode-hook #'aj/magit-maybe-enable-visual-line-mode)
(defun aj/magit-maybe-enable-visual-line-mode ()
  "Enables ‘visual-line-mode’ for repositories with mostly prose."
  (when (and (not (eq 'disable aj/magit-visual-line-mode))
             (or aj/magit-visual-line-mode
                 (cl-every #'aj/text-file-p (magit-list-files))))
    (visual-line-mode)))

(defun aj/text-file-p (file)
  (let ((case-fold-search nil))
    (aj/mode-equal-or-derived-p
     (assoc-default file auto-mode-alist
                    'string-match)
     '(text-mode org-mode))))

(defun aj/mode-equal-or-derived-p (mode modes)
  "Non-nil if MODE is one of MODES or derived from one of MODES"
  (or (memq mode modes)
      (apply #'provided-mode-derived-p mode modes)))
#+end_src

*** Dired display of untracked git files
#+begin_src emacs-lisp
(defvar-local aj/dired-untracked-filter nil)
(put 'aj/dired-untracked-filter 'safe-local-variable #'stringp)

(defun aj/dired-untracked ()
  "List untracked git files with dired"
  (interactive)
  (switch-to-buffer (get-buffer-create "*untracked*"))
  (let ((dired-mode-hook
         (remq 'dired-collapse-mode dired-mode-hook))
        (filter (if aj/dired-untracked-filter
                    (concat "| grep -ve \"" aj/dired-untracked-filter "\" ")
                  "")))
    (shell-command (concat "git ls-files --others " filter "| xargs ls -lL")
                   (current-buffer))
    (dired-mode)
    (setq-local dired-subdir-alist
                (list (cons default-directory (point-min-marker))))))

#+end_src

*** git-timemachine
#+begin_src emacs-lisp
(use-package git-timemachine)
#+end_src

*** diff-hl-mode
#+begin_src emacs-lisp
(use-package diff-hl
  :init (global-diff-hl-mode)
  :custom
  (diff-hl-fringe-bmp-function 'aj/diff-hl-fringe-bmp-from-type)
  :config
  (add-hook 'magit-pre-refresh-hook 'diff-hl-magit-pre-refresh)
  (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh)
  (defun aj/diff-hl-fringe-bmp-from-type(_type _pos)
    'aj/diff-hl-bitmap)
  (define-fringe-bitmap 'aj/diff-hl-bitmap
    [#b00011000] nil nil '(center repeated))

  (add-hook 'aj/face-definitions-hook
            (lambda (&rest _ignore)
              (set-face-attribute 'diff-hl-insert nil :inverse-video t :foreground (face-background 'fringe))
              (set-face-attribute 'diff-hl-delete nil :inverse-video t :foreground (face-background 'fringe))
              (set-face-attribute 'diff-hl-change nil :inverse-video t :foreground (face-background 'fringe)))))
#+end_src

** visible-bookmarks (bm)
#+begin_src emacs-lisp
(use-package bm
  :defer 2
  :init (setq bm-restore-repository-on-load t)

  :bind (("<C-f5>" . bm-toggle)
         ("<f5>" . bm-next)
         ("<S-f5>" . bm-previous)
         ("<left-fringe> <mouse-5>" . bm-next-mouse)
         ("<left-fringe> <mouse-4>" . bm-previous-mouse)
         ("<left-fringe> <mouse-1>" . bm-toggle-mouse))
  :config
  (setq-default bm-buffer-persistence t)
  (setq bm-highlight-style 'bm-highlight-only-fringe
        bm-fringe-face 'gnus-summary-selected
        bm-fringe-persistent-face 'query-replace)
  (add-hook' after-init-hook 'bm-repository-load)
  (add-hook 'find-file-hooks 'bm-buffer-restore)
  (add-hook 'kill-buffer-hook 'bm-buffer-save)
  (add-hook 'kill-emacs-hook (lambda nil (bm-buffer-save-all) (bm-repository-save)))
  (add-hook 'after-save-hook 'bm-buffer-save)
  (add-hook 'after-revert-hook 'bm-buffer-restore))
#+end_src

** uniquify
#+begin_src emacs-lisp
(use-package uniquify
  :straight nil
  :demand t
  :config (setq uniquify-buffer-name-style 'post-forward-angle-brackets
                uniquify-after-kill-buffer-p t ; rename after killing uniquified
                uniquify-ignore-buffers-re "^\\*") ; ignore special buffers
  )
#+end_src

** New (custom) utility commands
#+begin_src emacs-lisp
(use-package aj-custom-commands
  :straight (aj-custom-commands :host gitlab :repo "andersjohansson/aj-custom-emacs-commands")
  :defer t
  :bind (("C-x C-k" . aj/delete-current-buffer-file)
         ("C-x C-r" . rename-visited-file)
         ("C-c m" . aj/message-peek)
         :map prog-mode-map
         ("C-a" . aj/beginning-or-indentation))
  ;; :init
  ;; (straight-use-package 'pcsv) ;;needed but custom-commands
  )
#+end_src

** Editing. Marking, killing, yanking, etc.

*** Selected: a custom keymap when the region is active :ARCHIVE:
Some bindings both for acting and extending the region.
#+begin_src emacs-lisp
(use-package selected
  :ensure t
  :commands selected-minor-mode
  :init
  (setq selected-org-mode-map (make-sparse-keymap))
  :bind (:map selected-keymap
              ("q" . selected-off)
			  ("u" . upcase-dwim)
			  ("d" . downcase-dwim)
			  ("w" . kill-ring-save)
			  ("n" . next-line)
			  ("p" . previous-line)
			  ("f" . forward-char)
			  ("b" . backward-char)
			  ("F" . forward-word)
			  ("B" . backward-word)
			  ("a" . beginning-of-visual-line)
			  ("e" . end-of-visual-line)
			  ("{" . backward-paragraph)
			  ("}" . forward-paragraph)
			  ;; ("(" . backward-sentence)
			  ;; (")" . forward-sentence)
			  ("s" . isearch-forward)
			  ("r" . isearch-backward)
			  ("[" . scroll-down-line)
			  ("]" . scroll-up-line)
			  ("M" . rectangle-mark-mode)
			  ("R" . replace-rectangle)
			  ("x" . exchange-point-and-mark)
              ;; :map selected-org-mode-map
              ;; ("t" . org-table-convert-region)
              ;; ("*" . org-toggle-heading)
              )
  :config (selected-global-mode))
#+end_src

*** Delete-selection-mode
#+begin_src emacs-lisp
(delete-selection-mode)
#+end_src

*** Whole-line-or-region :ARCHIVE:
#+begin_src emacs-lisp
(use-package whole-line-or-region
  :demand t
  :config (whole-line-or-region-global-mode))
#+end_src

*** Save interprogram-paste, so it won’t be overwritten by kills done in emacs and is instead kept in the kill ring.
#+begin_src emacs-lisp
(setq save-interprogram-paste-before-kill t)
#+end_src

*** expand-region :ARCHIVE:
#+begin_src emacs-lisp
(use-package expand-region
  :bind ("C-ä" . er/expand-region))
#+end_src

*** Join line to following is my favourite command
#+begin_src emacs-lisp
(bind-key "M-j" #'aj/join-following)  ;; no use for comment-indent-new-line
(defun aj/join-following ()
  (interactive)
  (join-line -1))
#+end_src

*** cycle-spacing
#+begin_src emacs-lisp
(global-set-key (kbd "S-SPC") 'cycle-spacing)
#+end_src

*** hungry-delete                                                   :ARCHIVE:
Deleting a whitespace character deletes all whitespace up till non ws
#+begin_src emacs-lisp
(use-package hungry-delete
  :demand t
  :config (global-hungry-delete-mode))
#+end_src

** Various key binding customizations

*** Use ~C-x s~ for ~save-buffer~ and ~C-S-x C-S-s~ for ~save-some-buffers~
Becuase I often mistype and let go of my ctrl button before pressing s.
#+begin_src emacs-lisp
(bind-key "C-x s" #'save-buffer)
(bind-key "C-S-x C-S-s" #'save-some-buffers)
#+end_src

*** Goto-adress
#+begin_src emacs-lisp
(use-package goto-addr
  :hook ((compilation-mode . goto-address-mode)
         (prog-mode . goto-address-prog-mode)
         (text-mode . goto-address-mode)
         (elfeed-show-mode . goto-address-mode))
  :bind (:map goto-address-highlight-keymap
              ("C-c C-o" . goto-address-at-point))
  :commands (goto-address-prog-mode
             goto-address-mode))
#+end_src

*** Kill emacs instead of terminal
I often have more use for killing emacs (including all GUI-windows).
#+begin_src emacs-lisp
(global-set-key [remap save-buffers-kill-terminal] #'save-buffers-kill-emacs)
#+end_src

*** No shift select
#+begin_src emacs-lisp
(setq shift-select-mode nil)
#+end_src

*** Rectangle mark-mode hydra :ARCHIVE:
#+begin_src emacs-lisp
(global-set-key (kbd "C-x SPC") 'hydra-rectangle/body)

(defhydra hydra-rectangle (:body-pre (rectangle-mark-mode 1)
                                     :color pink
                                     :post (deactivate-mark))
  "
    ^_k_^     _d_elete    _s_tring
  _h_   _l_   _q_uit      _y_ank
    ^_j_^     _n_ew-copy  _r_eset
  ^^^^        _e_xchange  _u_ndo
  ^^^^        ^ ^         _p_aste
  "
  ("h" backward-char nil)
  ("l" forward-char nil)
  ("k" previous-line nil)
  ("j" next-line nil)
  ("e" hydra-ex-point-mark nil)
  ("n" copy-rectangle-as-kill nil)
  ("d" delete-rectangle nil)
  ("r" (if (region-active-p)
           (deactivate-mark)
         (rectangle-mark-mode 1)) nil)
  ("y" yank-rectangle nil)
  ("u" undo nil)
  ("s" string-rectangle nil)
  ("p" kill-rectangle nil)
  ("q" nil nil))

(defvar rectangle-mark-mode)
(defun hydra-ex-point-mark ()
  "Exchange point and mark."
  (interactive)
  (if rectangle-mark-mode
      (exchange-point-and-mark)
    (let ((mk (mark)))
      (rectangle-mark-mode 1)
      (goto-char mk))))
#+end_src

*** Kill current buffer instead of kill-buffer
#+begin_src emacs-lisp
(global-set-key (kbd "C-x k") #'kill-current-buffer)
(global-set-key (kbd "C-x K") #'kill-buffer-and-window)
#+end_src

*** count-words instead of count-words-region
#+begin_src emacs-lisp
(global-set-key (kbd "C-=") #'count-words)
#+end_src

*** which-key
#+begin_src emacs-lisp
(use-package which-key
  :defer 4
  :config (which-key-setup-side-window-right-bottom)
  (which-key-mode)
  (setq which-key-paging-prefixes '("C-x"))
  (setq which-key-paging-key "<f2>"))
#+end_src

*** Hydra for toggle
#+begin_src emacs-lisp
(defvar whitespace-mode)
(defhydra hydra-toggle (:color blue)
  "
_a_ abbrev-mode:       %`abbrev-mode
_d_ debug-on-error:    %`debug-on-error
_f_ auto-fill-mode:    %`auto-fill-function
_t_ truncate-lines:    %`truncate-lines
_w_ whitespace-mode:   %`whitespace-mode
_v_ variable-pitch:
"
  ("a" abbrev-mode nil)
  ("d" toggle-debug-on-error nil)
  ("f" auto-fill-mode nil)
  ("t" toggle-truncate-lines nil)
  ("w" whitespace-mode nil)
  ("v" variable-pitch-mode nil)
  ("q" nil "quit"))
;; Recommended binding:
(bind-key "C-x t" 'hydra-toggle/body)

;; Here, using e.g. "_a_" translates to "a" with proper face.
;; More interestingly:
;;
;;     "foobar %`abbrev-mode" means roughly (format "foobar %S" abbrev-mode)
;;
;; This means that you actually see the state of the mode that you're changing.
#+end_src
*** Mark-paragraph, backward-kill-word
#+begin_src emacs-lisp
(global-set-key (kbd "M-?") 'mark-paragraph)
(global-set-key (kbd "M-h") 'backward-kill-word)
#+end_src

*** Text-scale (zoom), and variable-pitch
#+begin_src emacs-lisp
;;Free the keys for it
(bind-keys ("C-x =" . balance-windows)
           ("C-x )" . what-cursor-position))

(defhydra hydra-zoom (global-map "C-x +")
  "zoom"
  ("+" text-scale-increase "in")
  ("-" text-scale-decrease "out")
  ("´" variable-pitch-mode "variable-pitch")
  ("0" (text-scale-increase 0) "reset"))

;; also zoom with C-scroll (like in Firefox)
(bind-key "<C-down-mouse-4>" #'text-scale-increase)
(bind-key "<C-down-mouse-5>" #'text-scale-decrease)
#+end_src

** Movement
*** ~C-S-a~ as back-to-indentation
#+begin_src emacs-lisp
(bind-key "C-S-a" 'back-to-indentation)
#+end_src

*** Up and down for line scrolling, C-n, C-p for moving cursor.
#+begin_src emacs-lisp
(global-set-key [up]  #'scroll-down-line)
(global-set-key [down] #'scroll-up-line)
#+end_src

*** Forward-word med bara whitespace som word-boundary
#+begin_src emacs-lisp
(defun aj/forward-word-ws ()
  (interactive)
  (forward-whitespace 1)
  (forward-whitespace -1))
(defun aj/backward-word-ws ()
  (interactive)
  (forward-whitespace -1)
  (forward-whitespace 1))

(global-set-key (kbd "C-c f") 'aj/forward-word-ws)
(global-set-key (kbd "C-c b") 'aj/backward-word-ws)
#+end_src


*** Scrolling
#+begin_src emacs-lisp
(setq scroll-conservatively 10000
      scroll-margin 3
      next-screen-context-lines 3
      scroll-error-top-bottom t
      scroll-preserve-screen-position 'in-place)
#+end_src

** Mixed stuff
This could perhaps be sorted better.
*** Don’t kill scratch-buffer
#+begin_src emacs-lisp
(defun aj/unkillable-scratch-buffer ()
  (if (equal (buffer-name (current-buffer)) "*scratch*")
      (progn
        (erase-buffer)
        (bury-buffer)
        nil)
    t))
(add-hook 'kill-buffer-query-functions 'aj/unkillable-scratch-buffer)
#+end_src

*** Print to pdf :ARCHIVE:
#+begin_src emacs-lisp
(defun aj/print-to-pdf (filename)
  (interactive "F")
  (ps-spool-buffer-with-faces)
  (switch-to-buffer "*PostScript*")
  (write-file "/tmp/tmp.ps")
  (kill-buffer "tmp.ps")
  (let ((cmd (format "ps2pdf14 /tmp/tmp.ps \"%s\"" filename )))
    (shell-command cmd)
    (shell-command "rm /tmp/tmp.ps")
    (message (concat "Saved to:  " filename))))
#+end_src

*** No pictures for speedbar
#+begin_src emacs-lisp
(setq speedbar-use-images nil)
#+end_src

*** Trash can be good
#+begin_src emacs-lisp
(setq delete-by-moving-to-trash t)

(defun aj/dired-do-delete-no-trash (&optional arg)
  "Delete without trashing all marked (or next ARG) files.
`dired-recursive-deletes' controls whether deletion of
non-empty directories is allowed."
  (interactive "P")
  (let (markers)
    (dired-internal-do-deletions
     ;; this may move point if ARG is an integer
     (nreverse
      (dired-map-over-marks (cons (dired-get-filename)
                                  (let ((m (point-marker)))
                                    (push m markers)
                                    m))
                            arg))
     arg nil)
    (dolist (m markers) (set-marker m nil))))

(with-eval-after-load 'dired
  (define-key dired-mode-map (kbd "ä") 'aj/dired-do-delete-no-trash)
  (define-key dired-mode-map (kbd "ö") 'aj/dired-do-last-mod-rename))

(defun aj/visit-trash ()
  "Visit trash with dired, with `delete-by-moving-to-trash' set to nil."
  (interactive)
  (dired (concat (or (getenv "XDG_DATA_HOME") "~/.local/share") "/Trash/files"))
  (setq-local delete-by-moving-to-trash nil))

(defun aj/dired-restore-from-trash (&optional arg)
  "Restore marked (or next ARG) files in dired from Trash.

Only works with XDG trash dir."
  (interactive "P")
  (let* ((xdg-data-dir ;; these variables copied from ‘move-file-to-trash’
          (directory-file-name
           (expand-file-name "Trash"
                             (or (getenv "XDG_DATA_HOME")
                                 "~/.local/share"))))
         (trash-files-dir (expand-file-name "files" xdg-data-dir))
         (trash-info-dir (expand-file-name "info" xdg-data-dir)))

    (cl-loop for file in (dired-map-over-marks (dired-get-filename) arg)
             if (string-prefix-p trash-files-dir file) do
             (if-let ((trashinfo (expand-file-name
                                  (concat (file-name-nondirectory file)
                                          ".trashinfo")
                                  trash-info-dir))
                      (restorepath (with-temp-buffer
                                     (save-match-data
                                       (insert-file-contents trashinfo)
                                       (when (search-forward-regexp "^Path=\\(.+\\)$")
                                         (decode-coding-string
                                          (url-unhex-string (match-string 1))
                                          'utf-8 t)
                                         )))))
                 (when (y-or-n-p
                        (format "Restore %s → %s" (file-name-nondirectory file) restorepath))
                   (dired-rename-file file restorepath t)
                   (delete-file trashinfo))
               (user-error "Couldn’t find path to restore to."))
             else do (user-error "Can only restore files in trash dir"))))

(defun aj/dired-trash-remove (&optional arg)
  "Remove marked (or next ARG) files from trash using the trash-rm program."
  (interactive "P")
  (cl-loop for file in (dired-map-over-marks (dired-get-filename) arg) do
           (shell-command (format "trash-rm %s" (file-name-nondirectory file)))
           (dired-remove-file file)))
#+end_src

*** Source my ~.bash_env~.
Needed when starting in a non-interactive shell.
#+begin_src emacs-lisp
(setenv "BASH_ENV" "~/.bash_env")
#+end_src

*** backup-files :org_async:
#+begin_src emacs-lisp
(setq delete-old-versions t
	  kept-new-versions 6
	  kept-old-versions 2
	  version-control t)
#+end_src

** prog-modes
*** Whitespace-mode and whitespace-cleanup-mode
#+begin_src emacs-lisp
(use-package whitespace
  :custom
  (whitespace-style '(face trailing lines-tail tabs))
  (whitespace-line-column 80)
  (whitespace-display-mappings
   '((space-mark   ?\     [?·] [?.]) ; space - middle dot
     (space-mark   ?\xA0  [?¤] [?_]) ; hard space - currency sign
     (newline-mark ?\n    [?↵ ?\n] [?$ ?\n]) ; eol - downwards arrow
     (tab-mark     ?\t    [?» ?\t] [?\\ ?\t]) ; tab - right guillemet
     )))

(use-package whitespace-cleanup-mode
  :demand t
  :config (global-whitespace-cleanup-mode))
#+end_src

*** LSP, language server protocol :ARCHIVE:
This is the new thing, and it is good, because it knows a lot about the code and provides completion etc.
#+begin_src emacs-lisp
(use-package lsp-mode
  :hook (js-mode . lsp-mode)
  :config
  (set-face-attribute 'lsp-face-highlight-read nil :inherit 'idle-highlight)
  (add-hook 'lsp-mode-hook (lambda () (idle-highlight-mode -1))))

(use-package lsp-ui
  :hook (lsp-mode . lsp-ui-mode)
  :config
  (set-face-attribute 'lsp-ui-sideline-code-action nil :foreground nil :inherit 'font-lock-function-name-face)
  (set-face-attribute 'lsp-ui-sideline-current-symbol nil :foreground nil :weight 'light :inherit 'highlight))
(use-package company-lsp :commands company-lsp)

#+end_src

*** Highlight todos (hl-todo)
#+begin_src emacs-lisp
(use-package hl-todo
  :commands global-hl-todo-mode
  :defer 10
  :config (global-hl-todo-mode t))
#+end_src

*** eldoc
#+begin_src emacs-lisp
(global-eldoc-mode t)
#+end_src

*** Ediff
#+begin_src emacs-lisp
(use-package ediff
  :custom
  (ediff-window-setup-function #'ediff-setup-windows-plain)
  (ediff-split-window-function #'split-window-sensibly)
  :config
  ;; unfold when moving to position with ediff.
  (advice-add 'ediff-position-region :before #'aj/org-ediff-unfold)
  (defun aj/org-ediff-unfold (beg end &rest _)
    (when (derived-mode-p 'org-mode)
      (save-excursion (goto-char beg) (org-fold-show-set-visibility 'canonical)
                      (goto-char end) (org-fold-show-set-visibility 'canonical)))))
#+end_src

*** paren-face
Dims parentheses in lisp modes.
#+begin_src emacs-lisp
(use-package paren-face
  :init (global-paren-face-mode))
#+end_src

*** Elisp

**** Bind ~pp-eval-last-sexp~ and ~pp-eval-expression~
#+begin_src emacs-lisp
(bind-keys ("C-x C-S-e" . pp-eval-last-sexp)
           ("C-M-:" . pp-eval-expression))
#+end_src

**** Some settings from ESK
#+begin_src emacs-lisp
(add-hook 'emacs-lisp-mode-hook 'aj/remove-elc-on-save)

(defun aj/remove-elc-on-save ()
  "If you're saving an elisp file, likely the .elc is no longer valid."
  (add-hook 'after-save-hook
            (lambda ()
              (if (file-exists-p (concat buffer-file-name "c"))
                  (delete-file (concat buffer-file-name "c"))))
            nil t))

;; (define-key read-expression-map (kbd "TAB") #'completion-at-point)
;; (define-key lisp-mode-shared-map (kbd "RET") 'reindent-then-newline-and-indent)
#+end_src

**** Elisp-slime-nav
#+begin_src emacs-lisp
(use-package elisp-slime-nav
  :init (add-hook 'emacs-lisp-mode-hook #'elisp-slime-nav-mode)
  :config
  (defun aj/find-elisp-thing-at-point-other-window (sym-name)
    "Find the elisp thing at point, be it a function, variable, library or face. Display in other window.

With a prefix arg, or if there is no thing at point, prompt for
the symbol to jump to.

Argument SYM-NAME is the thing to find."
    (interactive (list (elisp-slime-nav--read-symbol-at-point)))
    (when sym-name
      (let ((sym (intern sym-name)))
        (message "Searching for %s..." sym-name)
        (if (fboundp 'xref-push-marker-stack)
            (xref-push-marker-stack)
          (with-no-warnings
            (ring-insert find-tag-marker-ring (point-marker))))
        (cond
         ((fboundp sym)
          (find-function-do-it sym nil #'switch-to-buffer-other-window))
         ((boundp sym)
          (find-function-do-it sym 'defvar #'switch-to-buffer-other-window))
         ((or (featurep sym) (locate-library sym-name))
          (find-library sym-name)) ;; explicitly calls switch-to-buffer
         ((facep sym)
          (find-function-do-it sym 'defface #'switch-to-buffer-other-window))
         (t
          (pop-tag-mark)
          (error "Don't know how to find '%s'" sym))))))

  (define-key elisp-slime-nav-mode-map (kbd "C-M-.")
    #'aj/find-elisp-thing-at-point-other-window))
#+end_src

**** Timestamps
#+begin_src emacs-lisp
(defun aj/elisp-timestamps ()
  (setq-local time-stamp-line-limit 10)
  (setq-local time-stamp-start "^;; Modified: ")
  (setq-local time-stamp-end "$")
  (setq-local time-stamp-format "%:y-%02m-%02d")
  (add-hook 'before-save-hook #'time-stamp nil t))

(add-hook 'emacs-lisp-mode-hook #'aj/elisp-timestamps)
#+end_src

**** Nameless
#+begin_src emacs-lisp
(use-package nameless
  :defer t
  :init (add-hook 'emacs-lisp-mode-hook #'nameless-mode)
  (setq nameless-private-prefix t
        nameless-affect-indentation-and-filling nil))
#+end_src

**** Electric-quote-mode
#+begin_src emacs-lisp
(add-hook 'emacs-lisp-mode-hook #'electric-quote-local-mode)
(setq electric-quote-context-sensitive t)
#+end_src

*** aggressive-indent
#+begin_src emacs-lisp
(use-package aggressive-indent
  :commands aggressive-indent-mode
  :init (add-hook 'prog-mode-hook #'aggressive-indent-mode)
  :config (add-hook 'reb-mode-hook (lambda () (aggressive-indent-mode -1))) ;; meaningless and shadows the important keybinding C-c C-q
  )
#+end_src

*** Outline
**** Outline hydra
#+begin_src emacs-lisp
(with-eval-after-load 'outline
  (defhydra hydra-outline (:color pink :hint nil)
    "
^Hide^             ^Show^           ^Move
^^^^^^------------------------------------------------------
_z_: sublevels     _a_: all         _u_: up
_t_: body          _e_: entry       _n_: next visible
_o_: other         _i_: children    _p_: previous visible
_c_: entry         _k_: branches    _f_: forward same level
_l_: leaves        _s_: subtree     _b_: backward same level
_d_: subtree     _TAB_: toggle

"
    ;; Hide
    ("z" outline-hide-sublevels)    ; Hide everything but the top-level headings
    ("t" outline-hide-body)         ; Hide everything but headings (all body lines)
    ("o" outline-hide-other)        ; Hide other branches
    ("c" outline-hide-entry)        ; Hide this entry's body
    ("l" outline-hide-leaves)       ; Hide body lines in this entry and sub-entries
    ("d" outline-hide-subtree)      ; Hide everything in this entry and sub-entries
    ;; Show
    ("a" outline-show-all)          ; Show (expand) everything
    ("e" outline-show-entry)        ; Show this heading's body
    ("i" outline-show-children)     ; Show this heading's immediate child sub-headings
    ("k" outline-show-branches)     ; Show all sub-headings under this heading
    ("s" outline-show-subtree)      ; Show (expand) everything in this heading & below
    ("TAB" outline-cycle)
    ;; Move
    ("u" outline-up-heading)                ; Up
    ("n" outline-next-visible-heading)      ; Next
    ("p" outline-previous-visible-heading)  ; Previous
    ("f" outline-forward-same-level)        ; Forward - same level
    ("b" outline-backward-same-level)       ; Backward - same level
    ("q" nil "leave"))

  (bind-key "C-c #" 'hydra-outline/body outline-minor-mode-map)) ; by example
#+end_src

*** Origami folding :ARCHIVE:
#+begin_src emacs-lisp
(use-package origami
  :commands origami-mode
  :config (bind-keys :map origami-mode-map
                     ("TAB" . origami-recursively-toggle-node)
                     ("S-TAB" . origami-toggle-all-nodes)))
#+end_src

*** octave-mode
#+begin_src emacs-lisp
(autoload 'octave-mode "octave" nil t)
(setq auto-mode-alist
      (cons '("\\.m$" . octave-mode) auto-mode-alist))
#+end_src

*** Tabs or spaces
#+begin_src emacs-lisp
(setq-default tab-width 4)
(defvaralias 'cperl-indent-level 'tab-width)
(defvaralias 'js-indent-level 'tab-width)

;; (use-package smart-tabs-mode
;;   :commands smart-tabs-insinuate
;;   :init (smart-tabs-insinuate 'c 'c++ 'java 'javascript 'cperl 'python 'ruby 'nxml)
;;   )

(add-hook 'emacs-lisp-mode-hook
		  (lambda ()
			;; Use spaces, not tabs.
			(setq indent-tabs-mode nil)))
#+end_src

*** smartparens

**** Initial
#+begin_src emacs-lisp
(use-package smartparens
  :init (require 'smartparens-config)
  :config
  (smartparens-global-mode t)
  (add-to-list 'sp-ignore-modes-list 'org-agenda-mode)
  (show-smartparens-global-mode t)
  (sp-use-smartparens-bindings)
  (sp-pair "`" nil :actions :rem) ;den sabbar org-cdlatex-mode m.m.
  (sp-local-pair 'org-mode "\\(" "\\)" :trigger "$$")
  (define-key smartparens-mode-map (kbd "M-<delete>") 'undefined)
  (define-key smartparens-mode-map (kbd "M-<backspace>") 'undefined))
;; sista sabbar mitt skrivande, borde bara kopplas till org-mode, men vet inte hur)
#+end_src


**** Minibuffer evaluation
#+begin_src emacs-lisp
(add-hook 'eval-expression-minibuffer-setup-hook #'smartparens-mode)
#+end_src
*** Comment-dwim-2
To only activate it in prog-mode, we define a minor mode with the binding.
#+begin_src emacs-lisp
(use-package comment-dwim-2
  :init
  (defvar comment-dwim-2-mode-map
    (let ((map (make-sparse-keymap)))
      (define-key map (kbd "C-c C-;") #'comment-dwim-2)
      map))

  (define-minor-mode comment-dwim-2-mode
    "Binds ‘comment-dwim-2’"
    :keymap comment-dwim-2-mode-map)


  (add-hook 'prog-mode-hook #'comment-dwim-2-mode))
#+end_src

*** CPERL
cperl instead of perl-mode
#+begin_src emacs-lisp
(use-package cperl-mode
  :straight nil
  :defer t
  :init (defalias 'perl-mode 'cperl-mode)
  :functions cperl-set-style
  :config (cperl-set-style "GNU")
  (defun aj/cperl-eldoc-documentation-function ()
    "Return meaningful doc string for `eldoc-mode'."
    (car (let ((cperl-message-on-help-error nil))
           (cperl-get-help))))
  (add-hook 'cperl-mode-hook (eldoc-mode))
  (add-hook 'cperl-mode-hook
            (lambda () (setq-local eldoc-documentation-function
                              'aj/cperl-eldoc-documentation-function))))
#+end_src

*** Notifications while compiling
#+begin_src emacs-lisp
  (autoload 'notifications-notify "notifications")
  (defun aj/compile-notify (_buffer message)
    (notifications-notify :title "Emacs kompilering" :body message :urgency "critical"))
  (add-to-list 'compilation-finish-functions 'aj/compile-notify)
#+end_src

*** Prettify :ARCHIVE:
#+begin_src emacs-lisp
(global-prettify-symbols-mode t)
(setq prettify-symbols-unprettify-at-point t)
#+end_src
*** Fill comments in prog-mode
#+begin_src emacs-lisp
(defun esk-local-comment-auto-fill ()
  (setq-local comment-auto-fill-only-comments t)
  (auto-fill-mode t))

(add-hook 'prog-mode-hook 'esk-local-comment-auto-fill)
#+end_src
*** Idle-highlight-mode
#+begin_src emacs-lisp
(use-package idle-highlight-mode
  :hook prog-mode)
#+end_src
** Text-modes and spelling
*** Visual-line-mode
**** Text-mode uses visual-line-mode and visual-fill-column-mode
#+begin_src emacs-lisp
(add-hook 'text-mode-hook 'turn-on-visual-line-mode)
(add-hook 'visual-line-mode-hook #'aj/hl-line-visual-line)

(defun aj/hl-line-visual-line ()
  (setq-local hl-line-range-function #'aj/hl-line-visual-line-range-function))

(defun aj/hl-line-visual-line-range-function ()
  (cons
   (save-excursion (beginning-of-visual-line))
   (save-excursion (beginning-of-visual-line 2))))

(use-package visual-fill-column
  :hook (visual-line-mode .  aj/visual-fill-column-mode-enable-disable)
  :config
  (defun aj/visual-fill-column-mode-enable-disable ()
    (if visual-line-mode
        (visual-fill-column-mode)
      (visual-fill-column-mode -1)))
  (setq-default visual-fill-column-width 100)
  (setq split-window-preferred-function #'visual-fill-column-split-window-sensibly)
  (advice-add 'text-scale-increase :after #'visual-fill-column-adjust))

;; use indicators, but dim them
(defface aj/shadow-fringe
  '((nil (:foreground "#cccccc"))) "Face for dim fringe bitmaps")

(set-fringe-bitmap-face 'right-curly-arrow 'aj/shadow-fringe)
(set-fringe-bitmap-face 'left-curly-arrow 'aj/shadow-fringe)
(setq visual-line-fringe-indicators (list nil 'right-curly-arrow))
#+end_src

**** Define a binding (~C-S-k~) for killing logical line in visual-line-mode, make sure this works also in org-mode, and that org-mode calls org-kill-line even if visual-line-mode is activated
#+begin_src emacs-lisp
;;(with-eval-after-load 'simple
(define-key visual-line-mode-map [remap kill-line] nil)
(bind-keys :map visual-line-mode-map
           ("C-k" . kill-visual-line)
           ("C-S-k" . kill-line))

(with-eval-after-load 'org
  (define-key org-mode-map [remap kill-line] nil)
  (bind-keys :map org-mode-map
             ("C-k" . org-kill-line)
             ("C-S-k" . kill-line))

  ;; Make org-kill-line take priority over kill-visual-line
  (defvar aj/org-visual-line-mode-map (copy-keymap visual-line-mode-map))
  (define-key aj/org-visual-line-mode-map (kbd "C-k") #'org-kill-line)
  (define-key aj/org-visual-line-mode-map  [remap kill-line] nil)
  (define-key aj/org-visual-line-mode-map  (kbd "C-S-k") #'kill-line)

  (defun aj/org-override-visual-line-mode-map ()
    (setq minor-mode-overriding-map-alist
          (list (cons visual-line-mode aj/org-visual-line-mode-map))))

  (add-hook 'org-mode-hook #'aj/org-override-visual-line-mode-map))

#+end_src

*** No, sentences don’t end with double space
That’s a stupid convention from the days of the typewriter (and in Swedish we don’t even use the longer (not double!) spaces after sentences that are good typographic practice in English).
#+begin_src emacs-lisp
(setq sentence-end-double-space nil)
#+end_src

*** Fill-paragraph fixes + ~aj/one-sentence-per-line-mode~
I generally don’t want hard line breaks in my text-mode paragraphs, so a very wide fill-column allows me to use ~M-q~ to remove all line breaks in a paragraph.

However, sometimes I put every sentence on its own line (good for version control) and then it would be good if ~fill-paragraph~ made sure that this was the case instead.

The minor mode defined below takes care of this. I advice ~fill-region-as-paragraph~ which is called by ~org-fill-paragraph~ (which is the most common way for me of invoking it), but perhaps there can be some invocations that are not matched by this. It would probably be cleaner to remap some keys, but this covers many cases in one go.

#+begin_src emacs-lisp
(add-hook 'text-mode-hook (lambda () (setq fill-column 99999)))

(define-minor-mode aj/one-sentence-per-line-mode
  "Minor mode that overrides `fill-region-as-paragraph' to
  arrange every sentence on its own line"
  :lighter nil)

(defun aj/one-sentence-fill-override (fun from to &rest args)
  (if aj/one-sentence-per-line-mode
      (aj/one-sentence-per-line-region from to)
    (apply fun from to args)))

(advice-add 'fill-region-as-paragraph :around #'aj/one-sentence-fill-override)

(defun aj/one-sentence-per-line-region (from to)
  "Makes one sentence per line in region"
  (interactive "r")
  (let ((se (sentence-end)))
    (save-excursion
      (goto-char from)
      ;; start by removing all but the last line breaks
      (while (search-forward "\n" (1- to) t)
        (replace-match " " t t))
      (goto-char to)
      ;; has to changed? too much?
      (while (search-backward-regexp se from t)
        (replace-match "\n" t nil nil 2)))))

(defun aj/set-org-sentence-end ()
  "Allow sentences to end with an org-bracket-link

I often put `org-annotate' comments after sentences, and these
should be kept together."
  (setq-local
   sentence-end
   (format
    "\\(?9:[.?!…‽][]\"'”’)}]*\\(?8:%s\\)?\\(?2:$\\|[	  ]\\)\\|[。．？！]+\\)[
]*"
    org-link-bracket-re)))

(add-hook 'org-mode-hook #'aj/set-org-sentence-end)
#+end_src

*** ~aj/one-sentence-per-line-highlight-mode~, highlight missing end of sentence characters
#+begin_src emacs-lisp
(defface aj/missing-eol-period '((t :inherit trailing-whitespace :extend t))
  "Face for marking missing end-of-sentence characters in
‘aj/one-sentence-per-line-highlight-mode’"
  :group 'aj)

(defvar aj/missing-eol-period-fl-keywords
  ;; anchored match: First matches lines starting with alnum (not
  ;; org-headlines for example), and then highlights words at eol
  ;; without periods etc.
  '(("^[[:alnum:]]" "\\b[[:word:]]+[^].?!:…‽\"'”’]$" nil nil
     (0 'aj/missing-eol-period prepend))))


(define-minor-mode aj/one-sentence-per-line-highlight-mode
  "Minor mode that marks missing end of senptence characters when
  writing one sentence per line"
  :lighter nil
  (if aj/one-sentence-per-line-highlight-mode
      (font-lock-add-keywords nil aj/missing-eol-period-fl-keywords)
    (font-lock-remove-keywords nil aj/missing-eol-period-fl-keywords)))
#+end_src

*** Fix text-mode syntax table and char table for quote symbols
When writing English with contractions using "right single quotation mark", ~’~, it needs to be treated as a word character for ispell/flyspell to treat the contraction correctly, similar to how ~'~ is defined in ~text-mode-syntax-table~.

In addition, words made up of characters from different scripts won’t be considered a word by word-movement functions, etc. Apperently the curly quote symbols in unicode is in the ~symbol~ script, whereas "ordinary" letters and the straight quotes are ~latin~ (I guess this is for historical reasons). I don’t know if there are any negative effects with putting the curly quotes in ~latin~, but it makes word navigation work. Maybe I should keep the changes to ~’~.

#+begin_src emacs-lisp
(modify-syntax-entry ?’ "w" text-mode-syntax-table)
(dolist (c '(?“ ?” ?‘ ?’))
  (set-char-table-range char-script-table c 'latin))
#+end_src

*** Expand straight single quote to curly single quote in text modes
When writing in English, I often want to quickly add a quote for a possessive. It’s almost always correct to guess that this is what is intended by a single quote at the end of a word.
#+begin_src emacs-lisp
(defun aj/single-quote-to-curly ()
  "If previous character is a word constituent insert ’ else '.
Should be bound to ', in relevant modes."
  (interactive)
  (if (looking-back "\\w" 1)
      (insert "’")
    (insert "'")))

(bind-key "'" #'aj/single-quote-to-curly 'text-mode-map)
(bind-key "'" #'aj/single-quote-to-curly 'org-mode-map)
#+end_src

*** Abbrev-mode
In the abbrev-file I have defined two tables to use as parents of ~text-mode-abbrev-table~, ~aj/swedish-abbrevs~ and ~aj/english-abbrevs~. They are activated when writing in English or Swedish as defined by the functions below (the ~:enable-function~ of the tables).

I also define abbrevs for english which expand "dont" to "do not" etc. in the table ~aj/formal-english-abbrevs~. This is activated via the minor mode ~aj/formal-english-minor-mode~.

Editing abbrevs with ~edit-abbrevs~ and saving them in the abbrev-file doesn’t seem to preserve properties. Therefore properties are added below (Some of this will be fixed in 27.1).
#+begin_src emacs-lisp
(use-package abbrev
  :straight nil
  :init
  (add-hook 'text-mode-hook #'abbrev-mode)
  (setq abbrev-file-name "~/.emacs.d/config/abbrev_defs")
  :config

  ;; I have some language-dependant abbrevs. For example, when writing in English
  ;; transforming i → I. But I also sometimes use mixed hunspell
  ;; dictionaries "en_GB,sv_SE", and the table ‘aj/english-abbrevs’,
  ;; should only be activated when writing only English in a buffer.
  ;; Hence the following enable-function.

  (require 'ispell)

  ;; TODO, check use of ispell-local-dictionary, ispell-dictionary, ispell-current-dictionary
  (defun aj/writing-pure-english-p ()
    "Is the current dictionary English?"
    (when-let ((dict (or ispell-local-dictionary (and flyspell-mode ispell-dictionary))))
      (member dict '("en" "en_GB" "en_US"))))

  ;; (defun aj/writing-english-p ()
  ;;   "Does current dictonary include English?"
  ;;   (when-let ((dict (or ispell-local-dictionary (and flyspell-mode ispell-dictionary))))
  ;;     (string-match dict "en")))

  ;; We can activate

  (defun aj/writing-swedish-p ()
    "Does current dictionary include Swedish?"
    (when-let ((dict (or ispell-local-dictionary (and flyspell-mode ispell-dictionary))))
      (string-match "sv" dict)))

  ;; the abbrev-tables ‘aj/english-abbrevs’ and ‘aj/swedish-abbrevs’
  ;; are defined in the abbrev file.
  ;; but they need to have enable-functions (which can’t be saved to
  ;; file!)

  ;; Putting these as parents to ‘text-mode-abbrev-table’ means they
  ;; get enabled for ‘text-mode’ and ‘org-mode’
  (with-eval-after-load abbrev-file-name
    (abbrev-table-put aj/english-abbrevs :enable-function #'aj/writing-pure-english-p)
    (abbrev-table-put aj/swedish-abbrevs :enable-function #'aj/writing-swedish-p)
    (abbrev-table-put text-mode-abbrev-table
                      :parents (list aj/english-abbrevs aj/swedish-abbrevs))
    ;; to add or replace it every time abbrev-file is loaded:
    (setf (alist-get 'aj/formal-english-minor-mode abbrev-minor-mode-table-alist)
          aj/formal-english-abbrevs)
    (setq aj/formal-english-fl-keywords
          `((,(regexp-opt
               (cl-loop for w being the symbols of aj/formal-english-abbrevs
                        for ww = (symbol-name w)
                        when (and (string-match "'" ww))
                        append (list ww (replace-match "’" t t ww))))
             0 'hi-pink prepend)))))

(defvar aj/formal-english-fl-keywords nil)

(define-minor-mode aj/formal-english-minor-mode
  "Minor mode for expanding abbrevs like \"dont\" to \"do not\".
And for higlighting existing don’t etc."
  :lighter ""
  (if aj/formal-english-minor-mode
      (font-lock-add-keywords nil aj/formal-english-fl-keywords)
    (font-lock-remove-keywords nil aj/formal-english-fl-keywords))
  (font-lock-flush))
#+end_src

*** Spelling: Ispell + flyspell
**** Options, define languages, hunspell, etc.
#+begin_src emacs-lisp
(setq-default ispell-program-name "hunspell")

(setq ispell-silently-savep t
      ;; ispell-dictionary "sv_SE"
      )

;; I want to have control over all parameters,
;; quoting characters and personal dictionaries, so I set my dicts
;; like this:

(add-hook 'ispell-initialize-spellchecker-hook #'aj/extra-dicts)
(defun aj/extra-dicts ()
  (setq ispell-base-dicts-override-alist
        '(("en_GB"
           "[[:alpha:]]" "[^[:alpha:]]"
           "[’'´.0-b:-]" t ("-d" "en_GBz-large")
           nil utf-8)
          ("en_US"
           "[[:alpha:]]" "[^[:alpha:]]"
           "[’'´.0-b:-]" t ("-d" "en_US")
           nil utf-8)
          ("en_GB,sv_SE"
           "[[:alpha:]]" "[^[:alpha:]]"
           "[’'´.0-b:-]" t ("-d" "en_GBz-large,sv_SE")
           nil utf-8)
          ("blandat"
           "[[:alpha:]]" "[^[:alpha:]]"
           "[ø’'´.0-b:-]" t ("-d" "en_GBz-large,sv_SE,da_DK")
           nil utf-8)
          ("en_US,sv_SE"
           "[[:alpha:]]" "[^[:alpha:]]"
           "[’'´.0-b:-]" t ("-d" "en_US,sv_SE")
           nil utf-8))))
#+end_src

**** flyspell-hydra and custom commands
#+begin_src emacs-lisp
(bind-key "C-c l" 'hydra-flyspell/body)
(defhydra hydra-flyspell (:color blue :hint nil)
  "
^Correct:^    _,_: auto-correct   _c_orrect Current: %(identity ispell-current-dictionary)
^Toggle:^     _l_: turn %(if flyspell-mode \"off\" \"on \") flyspell _L_ toggle+disable, turn: %(if flyspell-mode \"off\" \"on \")
^Languages:^  _s_venska   _b_ritish  _d_: svenska-british _a_: blandat  _u_s english
"
  ("l" flyspell-mode)
  ("L" aj/disable-enable-flyspell-permanently-in-file)
  ("c" ispell-word)
  ("," flyspell-auto-correct-word :color red)
  ("s" (aj/ispell-change-dictionary "sv_SE"))
  ("S" (aj/ispell-change-dictionary-store "sv_SE"))
  ("b" (aj/ispell-change-dictionary "en_GB"))
  ("B" (aj/ispell-change-dictionary-store "en_GB"))
  ("d" (aj/ispell-change-dictionary "en_GB,sv_SE"))
  ("D" (aj/ispell-change-dictionary-store "en_GB,sv_SE"))
  ("a" (aj/ispell-change-dictionary "blandat"))
  ("A" (aj/ispell-change-dictionary-store "blandat"))
  ("u" (aj/ispell-change-dictionary "en_US"))
  ("U" (aj/ispell-change-dictionary-store "en_US"))
  ("q" nil "quit"))

(defun aj/ispell-change-dictionary (dict)
  "Change dictionary, enable ‘flyspell-mode’, disable ‘guess-language-mode’"
  (ispell-change-dictionary dict)
  (flyspell-mode)
  (guess-language-mode -1))

(defun aj/disable-enable-flyspell-permanently-in-file ()
  (interactive)
  (save-excursion
    (save-restriction
      (widen)
      (if flyspell-mode
          (progn
            (flyspell-mode -1)
            (guess-language-mode -1)
            (add-file-local-variable 'aj/inhibit-flyspell t))
        (flyspell-mode)
        (goto-char (point-min))
        (when (search-forward "Local Variables" nil t)
          (flush-lines "aj/inhibit-flyspell: t"))))))

(defun aj/ispell-change-dictionary-store (dict)
  (interactive (list (completing-read
                      "Dictionary: "
                      (mapcar #'car ispell-dictionary-alist))))
  (save-excursion
    (aj/ispell-change-dictionary dict)
    (add-file-local-variable 'ispell-local-dictionary dict)))

(advice-add 'ispell-change-dictionary :after #'aj/ispell-change-dictionary-merge-personal)

(defun aj/ispell-change-dictionary-merge-personal (dict &rest _args)
  "If this is a combined dictionary (hunspell), merges all
personal dictionaries into a combined personal dictionary."
  (when (and dict
             (string-match "," dict))
    (let* ((filenamefn (apply-partially #'format "~/.hunspell_%s"))
           (dictfiles
            (cons (funcall filenamefn dict)
                  (mapcar filenamefn (split-string dict "," t " ")))))
      (with-temp-buffer
        (dolist (d dictfiles)
          (when (file-readable-p d) (insert-file-contents d)))
        (unless (eq (point-min) (point-max))
          (delete-duplicate-lines (point-min) (point-max))
          (write-file (car dictfiles))))
      ;; should be overridden in `ispell-buffer-local-dict' if we have
      ;; a local variable definition in the buffer
      ;; tvivlar på att detta är rätt kanske:
      ;; (setq-local ispell-local-pdict (car dictfiles))

      ;; eller så borde den avsättas om vi växlat till en icke-mergad.
      )))
#+end_src

**** Guess language, conditional enabling of flyspell and setting of languages for flyspell, typo and langtool.
#+begin_src emacs-lisp
(use-package guess-language
  :defer t
  :config
  (setq guess-language-langcodes '((en . ("en_GB" "English"))
                                   (sv . ("sv_SE" "Swedish")))
        guess-language-languages '(en sv)
        guess-language-min-paragraph-length 45)

  ;; (add-to-list 'guess-language-after-detection-functions
  ;;              #'aj/set-langtool-language)

  ;; (defun aj/set-langtool-language (lang _beg _end)
  ;;   (cl-case lang
  ;;     (sv (setq-local langtool-default-language "sv-SE"))
  ;;     (en (setq-local langtool-default-language "en-GB"))))
  )


(defvar aj/flyspell-modes '(org-mode))
(defvar-local aj/inhibit-flyspell nil)
(put 'aj/inhibit-flyspell 'safe-local-variable #'booleanp)

;; Activate flyspell if local ispell-language defined.

;; Functions that maybe enables flyspell and guess-language, a second
;; after local variables are read (to ensure ispell language and
;; aj/inhabit-flyspell is set).

(add-hook 'hack-local-variables-hook #'aj/maybe-enable-flyspell)

(defun aj/maybe-enable-flyspell ()
  (run-with-idle-timer 1 nil #'aj/maybe-enable-flyspell-fn (current-buffer)))

(defun aj/maybe-enable-flyspell-fn (buf)
  "Possibly enable ‘flyspell-mode’

Enable it for buffers in ‘aj/flyspell-modes’ with defined
‘ispell-local-dictionary’, or for ‘mu4e-compose-mode’ (then use
‘guess-language-mode’)"
  (when (buffer-live-p buf)
    (with-current-buffer buf
      (cond ((and (not aj/inhibit-flyspell)
                  (member major-mode aj/flyspell-modes)
                  ispell-local-dictionary)
             (flyspell-mode)
             ;; (aj/set-langtool-language-from-ispell-dict)
             )
            ((eq major-mode 'mu4e-compose-mode)
             (flyspell-mode)
             (guess-language-mode))))))

;; (defun aj/set-langtool-language-from-ispell-dict ()
;;   (when (and ispell-local-dictionary
;;              (< (length ispell-local-dictionary) 7))
;;     (setq-local langtool-default-language
;;                 (replace-regexp-in-string "\_" "-" ispell-local-dictionary))))
#+end_src

**** Extra flyspell bindings :ARCHIVE:
#+begin_src emacs-lisp
(with-eval-after-load 'flyspell
  (bind-keys :map flyspell-mode-map
             ("C-,"   . flyspell-auto-correct-previous-word)
             ("C-;"   . flyspell-check-previous-highlighted-word)
             ("C-M-," . flyspell-goto-next-error)))
#+end_src

**** Flyspell-correct
Works ok with modern completion
#+begin_src emacs-lisp
(use-package flyspell-correct
  :after flyspell
  :bind (:map flyspell-mode-map
              ("C-," . flyspell-auto-correct-previous-word)
              ("C-;" . flyspell-correct-wrapper)
              ;; also disable conflicting C-. (embark-act)
              ("C-." . nil)))
#+end_src

**** Extra words and areas to avoid spellchecking in various modes.
#+begin_src emacs-lisp
(defun aj/flyspell-only-pure-words-predicate ()
  "Don’t spellcheck words containing non-alpha characters."
  (save-excursion
    (save-match-data
      (skip-chars-forward "^[:space:]")
      (let* ((limit (1- (point))))
        (skip-chars-backward "^[:space:]")
        (if (> 2 (- limit (point)))
            t
          (forward-char)
          (not (search-forward-regexp "[^[:alpha:]]" limit t)))))))

(put 'text-mode 'flyspell-mode-predicate #'aj/flyspell-only-pure-words-predicate)

(cl-loop for m in
         '(tex-mode-flyspell-verify
           org-mode-flyspell-verify
           sgml-mode-flyspell-verify
           mail-mode-flyspell-verify
           git-commit-flyspell-verify
           texinfo-mode-flyspell-verify
           flyspell-generic-progmode-verify)
         do
         (advice-add m :after-while #'aj/flyspell-only-pure-words-predicate))


(defun aj/flyspell-org-not-link-predicate ()
  (not (memq (face-at-point) '(org-link org-date org-scheduled))))

(advice-add 'org-mode-flyspell-verify :before-while #'aj/flyspell-org-not-link-predicate)
#+end_src

*** Typo
For doing smart (curly) quotes, mainly in emails since org has it’s own mechanism when exporting.
#+begin_src emacs-lisp
(use-package typo
  :after mu4e
  :config
  (setq-default typo-language "Swedish")
  (typo-global-mode 1)
  (add-hook 'mu4e-compose-mode-hook #'typo-mode)
  (defun aj/toggle-en-sv-typo ()
    (interactive)
    (setq typo-language
          (if (string= typo-language "English")
              "Swedish"
            "English")))
  (bind-key "C-c C-ö" #'aj/toggle-en-sv-typo mu4e-compose-mode-map))
#+end_src

*** eglot-ltex
#+begin_src emacs-lisp
(use-package eglot
  :config
  (add-to-list 'eglot-server-programs
               '((text-mode latex-mode org-mode markdown-mode) . ("ltex-ls"))))
#+end_src

*** Flymake-languagetool :ARCHIVE:
#+begin_src emacs-lisp
(use-package flymake-languagetool
  :hook ((text-mode       . flymake-languagetool-load)
         (latex-mode      . flymake-languagetool-load)
         (org-mode        . flymake-languagetool-load)
         (markdown-mode   . flymake-languagetool-load))
  :custom
  (flymake-languagetool-server-port 8003)
  (flymake-languagetool-language "auto")
  :init
  (setq flymake-languagetool-server-jar "/usr/share/languagetool:/usr/share/java/languagetool/*"))
#+end_src

*** [[https://github.com/mhayashi1120/Emacs-langtool][Language tool]], :ARCHIVE:
#+begin_src emacs-lisp
(use-package langtool
  :bind (("C-x 4 w" . langtool-check)
         ("C-x 4 W" . langtool-check-done)
         ("C-x 4 l" . langtool-switch-default-language)
         ("C-x 4 4" . langtool-show-message-at-point)
         ("C-x 4 c" . langtool-correct-buffer))
  :custom
  ;; (langtool-java-classpath "/usr/share/languagetool:/usr/share/java/languagetool/*")
  (langtool-language-tool-server-jar "/usr/share/languagetool:/usr/share/java/languagetool/*")

  ;; (langtool-language-tool-server-jar "/usr/share/java/languagetool/languagetool-server.jar")
  (langtool-server-user-arguments '("-p" "8342"))
  ;; (langtool-java-classpath "/usr/share/languagetool:/usr/share/java/languagetool/*")
  (langtool-mother-tongue "sv")
  (langtool-disabled-rules '("WHITESPACE_RULE" "EN_QUOTES")))

#+end_src

*** Word lookups (definition, translation, synonyms). Use define-word for online word definitions and SDCV for Webster's dictionary installed locally
My extra libraries can be found at:  https://gitlab.com/andersjohansson/define-word-thesaurus and  https://gitlab.com/andersjohansson/define-word-tyda.

Instructions for getting Webster’s dictionary: http://mbork.pl/2017-01-14_I'm_now_using_the_right_dictionary

#+begin_src emacs-lisp
(use-package define-word
  :commands (define-word define-word-at-point))

(use-package define-word-thesaurus
  :straight (:host gitlab
                   :repo "andersjohansson/define-word-thesaurus"
                   :files ("*.el" "*.py"))
  :after define-word)

(use-package define-word-tyda
  :straight (:host gitlab :repo "andersjohansson/define-word-tyda")
  :after define-word)

(use-package define-word-babla
  :straight (:host gitlab :repo "andersjohansson/define-word-babla")
  :after define-word)

(use-package sdcv-mode
  :straight nil
  :commands 'sdcv-search)
(use-package google-translate
  :commands 'google-translate-smooth-translate
  :init (setq google-translate-translation-directions-alist
              '(("sv" . "en") ("en" . "sv") ("da" . "sv"))))

;; needs wn, installed with aur package wordnet-cli
(use-package wordnut)

;; (embark-define-keymap aj/embark-word-lookup-map
;;   "Keymap for looking up words in dictionaries etc."
;;   ("w" sdcv-search)
;;   ("RET" define-word)
;;   ;; ("t" (define-word (read-from-minibuffer "Tyda: " ) 'tyda) "tyda")
;;   ;; ("T" (define-word-at-point nil 'tyda) "Tyda at point")
;;   ;; ("c" (define-word (read-from-minibuffer "Synonymer: " ) 'synonymer) "synonymer")
;;   ;; ("C" (define-word-at-point nil 'synonymer) "Synonymer at point")
;;   ;; ("s" (define-word (read-from-minibuffer "Thesaurus: " ) 'thesaurus) "Thesaurus")
;;   ;; ("S" (define-word-at-point nil 'thesaurus) "Thesaurus at point")
;;   ;; ("b" (define-word (read-from-minibuffer "bab.la: " ) 'babla))
;;   ;; ("n" wordnut-search "wordnut")
;;   ;; ("g" google-translate-smooth-translate "Google translate")
;;   ;; ("h" display-local-help)
;;   ;; ("H" embark-toggle-highlight)
;;   ;; ("d" xref-find-definitions)
;;   ;; ("r" xref-find-references)
;;   ;; ("a" xref-find-apropos)
;;   ;; ("s" info-lookup-symbol)
;;   ;; ("n" embark-next-symbol)
;;   ;; ("p" embark-previous-symbol)
;;   ;; ("'" expand-abbrev)
;;   ;; ("$" ispell-word)
;;   ;; ("o" occur)
;;   )

;; (fset 'aj/embark-word-lookup-map aj/embark-word-lookup-map)
;; (define-key embark-identifier-map "W" 'aj/embark-word-lookup-map)



;; (defhydra hydra-word-lookup
;;   (:color blue)
;;   ("w" sdcv-search "in Webster's")
;;   ("p" define-word-at-point "word at point")
;;   ("<RET>" define-word "define word")
;;   ("t" (define-word (read-from-minibuffer "Tyda: " ) 'tyda) "tyda")
;;   ("T" (define-word-at-point nil 'tyda) "Tyda at point")
;;   ("c" (define-word (read-from-minibuffer "Synonymer: " ) 'synonymer) "synonymer")
;;   ("C" (define-word-at-point nil 'synonymer) "Synonymer at point")
;;   ("s" (define-word (read-from-minibuffer "Thesaurus: " ) 'thesaurus) "Thesaurus")
;;   ("S" (define-word-at-point nil 'thesaurus) "Thesaurus at point")
;;   ("b" (define-word (read-from-minibuffer "bab.la: " ) 'babla))
;;   ("n" wordnut-search "wordnut")
;;   ("g" google-translate-smooth-translate "Google translate"))


(defmacro aj/define-word-with (backend)
  "Return a function which calls ‘define-word’ with BACKEND."
  `(defun ,(intern (concat "aj/define-word-with-" (symbol-name backend)))
       (word)
     ,(format "Call define-word with %s" backend)
     (define-word word ',backend)))

(defun aj/google-translate-guess (text)
  "Translate TEXT, guessing language."
  (let* ((from (with-temp-buffer (insert text)
                                 (symbol-name (guess-language-buffer))))
         (to (cond ((equal from "sv") "en")
                   ((equal from "en") "sv")
                   (t (google-translate-read-target-language)))))
    (google-translate-translate from to text)))

(embark-define-keymap aj/embark-word-lookup-map
  "Keymap for ‘define-word’ etc."
  ;; :parent identifier-symbol-map
  ("w" sdcv-search)
  ("RET" (aj/define-word-with wordnik))
  ("t" (aj/define-word-with tyda))
  ("b" (aj/define-word-with babla))
  ("s" (aj/define-word-with thesaurus))
  ("n" wordnut-search)
  ("g" aj/google-translate-guess))

(fset 'aj/embark-word-lookup-map aj/embark-word-lookup-map)
(define-key embark-identifier-map "W" 'aj/embark-word-lookup-map)
(define-key embark-region-map "W" 'aj/embark-word-lookup-map)

(defun aj/word-lookup ()
  (interactive)
  (let* ((targets (embark--targets))
         (tf (seq-filter (lambda (x)
                           (member (plist-get x :type) '(identifier symbol region)))
                         targets))
         (targets (or
                   tf
                   `((:type identifier :target ,(read-string "Word: " (word-at-point))))))
         (ind (mapcar #'funcall '(embark-mixed-indicator embark-highlight-indicator)))
         (action
          (unwind-protect
              (or (embark--prompt
                   ind
                   aj/embark-word-lookup-map
                   targets)
                  (user-error "Canceled"))
            (mapc #'funcall ind))
          )) ;; (mapc #'funcall ind)

    (funcall action (plist-get (car targets) :target))

    ))

(bind-key "C-x l"  #'aj/word-lookup)






#+end_src

*** pandoc-view-mode: Auto convert files for reading in org mode via pandoc
https://gist.github.com/imarko/ec8f39550662fcd16908b7ec9d100e7e
#+begin_src emacs-lisp
(define-derived-mode
  pandoc-view-mode
  org-mode
  "pandoc-view-mode"
  "View pandoc converted files in org-mode."
  (setq-local org-element-use-cache nil)
  (setq-local revert-buffer-function #'pandoc-view-mode-revert-buffer)
  (pandoc-view-mode-revert-buffer))

(defun pandoc-view-mode-revert-buffer (&rest _ignore)
  (let ((inhibit-read-only t)
        (mediadir (expand-file-name
                   (concat "pandoc-view-mode/"
                           (file-name-base (buffer-file-name)))
                   (temporary-file-directory))))
    (erase-buffer)
    (make-directory mediadir t)
    (save-excursion
      (call-process "pandoc" nil t nil "-torg" "--wrap=none"
                    "--extract-media" mediadir
                    "--lua-filter=/home/aj/kodat/000-egna-skript/pandoc-remove-header-attributes.lua"
                    (buffer-file-name)))
    (set-buffer-modified-p nil))
  (read-only-mode t)
  (org-display-inline-images t)
  ;; some stuff for making it pretty:
  (setq-local visual-fill-column-width 78
              visual-fill-column-center-text t)
  (visual-fill-column-mode t))

(add-hook 'pandoc-view-mode-hook #'doc-font-mode)

(add-to-list 'auto-mode-alist '("\\.docx\\'" . pandoc-view-mode))
(add-to-list 'auto-mode-alist '("\\.epub\\'" . pandoc-view-mode))

#+end_src

** Special modes
*** View-mode
#+begin_src emacs-lisp
(use-package view
  :straight '(view :type built-in)
  :custom (view-read-only t)
  :bind (:map view-mode-map
              ;; these are normally bound to previous search using
              ;; view-mode’s custom search function which I see no
              ;; point in using
     	      ("n" . next-line)
              ("p" . previous-line)))

#+end_src

*** Extra definitions for ~auto-mode-alist~
#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist
             '("\\.\\(timer\\|service\\)\\'" . conf-mode))

(add-to-list 'auto-mode-alist
             '("PKGBUILD$" . sh-mode))
#+end_src

*** Pdf-view (pdf-tools)
**** Main settings
pdf-loader handles deferred loading. Then settings are applied after loading pdf-view.
#+begin_src emacs-lisp
(use-package pdf-tools
  :commands pdf-loader-install ;; TODO (fel?)
  :init (pdf-loader-install)
  :custom
  (pdf-annot-tweak-tooltips nil)
  (pdf-view-use-scaling t)
  :config
  ;; I almost never have use for synctex:
  (setq pdf-tools-enabled-modes
        (delq 'pdf-sync-minor-mode pdf-tools-enabled-modes)))

(with-eval-after-load 'pdf-view
  (defun pdf-view-current-pagelabel (&optional window)
    (nth (1- (pdf-view-current-page window)) (pdf-info-pagelabels)))

  (setq-default pdf-view-display-size 'fit-page)
  (add-hook 'pdf-view-mode-hook (lambda () (auto-revert-mode -1)))

  (defvar aj/pdf-view-midnight-list
    '(("#282828" . "#f9f5d7")
      ("#fdf4c1" . "#282828")))
  (setq pdf-view-midnight-colors (car aj/pdf-view-midnight-list))

  (defun aj/pdf-view-midnight-toggle ()
    (interactive)
    (when-let ((ind (cl-position pdf-view-midnight-colors
                                 aj/pdf-view-midnight-list
                                 :test 'equal)))
      (setq pdf-view-midnight-colors
            (nth (mod (1+ ind) (length aj/pdf-view-midnight-list))
                 aj/pdf-view-midnight-list))
      (pdf-view-midnight-minor-mode 1)))

  (defvar aj/pdf-hl-color "#EDE3FA")
  (defvar aj/pdf-ul-color "#633D91")
  (defvar aj/pdf-ol-color "#9C2F38")
  (defvar aj/pdf-note-color "#77599C")
  (defvar aj/pdf-hl-note-color "#E0EDD1" "used for highlights with notes")
  (setq pdf-annot-default-text-annotation-properties
        `((icon . "Comment")
          (color . ,aj/pdf-note-color)
          (label . ,user-full-name)
          (popup-is-open . nil)
          ;; (subject . "Comment")
          ))

  (defvar pdf-annot-activate-created-annotations)

  (defun aj/pdf-hl (edit) (interactive "P")
         (let ((pdf-annot-activate-created-annotations edit))
           (pdf-annot-add-markup-annotation (pdf-view-active-region t) 'highlight aj/pdf-hl-color)))
  (defun aj/pdf-hl-and-copy (edit) (interactive "P")
         (let ((pdf-annot-activate-created-annotations edit))
           (pdf-annot-add-markup-annotation (pdf-view-active-region) 'highlight aj/pdf-hl-color)
           (pdf-view-kill-ring-save)))
  (defun aj/pdf-ul (edit) (interactive "P")
         (let ((pdf-annot-activate-created-annotations edit))
           (pdf-annot-add-markup-annotation (pdf-view-active-region t) 'underline aj/pdf-ul-color)))
  (defun aj/pdf-ol (edit) (interactive "P")
         (let ((pdf-annot-activate-created-annotations edit))
           (pdf-annot-add-markup-annotation (pdf-view-active-region t) 'strike-out aj/pdf-ol-color)))
  (defun aj/pdf-sq (edit) (interactive "P")
         (let ((pdf-annot-activate-created-annotations edit))
           (pdf-annot-add-markup-annotation (pdf-view-active-region t) 'squiggly aj/pdf-ol-color)))
  (defun aj/pdf-hl-note () (interactive)
         (let ((pdf-annot-activate-created-annotations t))
           (pdf-annot-add-markup-annotation (pdf-view-active-region t) 'highlight aj/pdf-hl-note-color)))
  (defun aj/pdf-text (ev) (interactive "e")
         (let* ((pdf-annot-activate-created-annotations t)
                (posn (if (mouse-event-p ev)
                          (event-start ev)
                        (user-error "Not a mouse event")))
                (pw (posn-window posn)))
           ;;(with-current-buffer (window-buffer (posn-window posn))
           (unless (eq (window-buffer pw) (current-buffer))
             (select-window pw))
           (if (eq 'image (car-safe (posn-object posn)))
               (pdf-annot-add-text-annotation posn "Comment" `((color . ,aj/pdf-note-color)))
             (user-error "Not image?"))))
  (bind-keys
   :map pdf-view-mode-map
   ("s a" . pdf-view-auto-slice-minor-mode)
   ("q" . aj/pdf-quit)
   ("1" . aj/pdf-hl-and-copy)
   ("2" . aj/pdf-ul)
   ("3" . aj/pdf-ol)
   ("4" . aj/pdf-sq)
   ("5" . aj/pdf-hl-note)
   ("!" . (lambda () (interactive) (aj/pdf-hl t)))
   ("\"" . (lambda () (interactive) (aj/pdf-ul t)))
   ("#" . (lambda () (interactive) (aj/pdf-ol t)))
   ("¤" . (lambda () (interactive) (aj/pdf-sq t)))
   ("<C-S-mouse-1>" . aj/pdf-text))

  (defun aj/pdf-quit ()
    (interactive)
    (cl-case (read-char "Really close pdf? ")
      ((?q ?y) (kill-buffer))))

  ;; advice count-words
  (advice-add 'count-words :before-until #'aj/pdf-count-words)
  (defun aj/pdf-count-words (_start _end)
    (when (eq major-mode 'pdf-view-mode)
      (pdf-view-assert-active-region)
      (let ((txt (pdf-view-active-region-text)))
        (with-temp-buffer
          (insert (car txt))
          (count-words--message "PDF region" (point-min) (point-max))
          ))
      t))

  (defun aj/other-window-pdf-next-page (n)
    (interactive "p")
    (when-let ((other-pdf-window
                (or (get-window-with-predicate #'pdf-util-pdf-window-p nil 'thisframe)
                    (get-window-with-predicate #'pdf-util-pdf-window-p nil 'visible))))
      (with-selected-window other-pdf-window
        (with-demoted-errors "%s"
          (if pdf-view-multipage-mode
              (pdf-view-multipage-next-page n)
            (pdf-view-next-page n))))))
  (defun aj/other-window-pdf-previous-page (n)
    (interactive "p")
    (aj/other-window-pdf-next-page (- (or n 1))))
  (bind-keys ("M-n" . aj/other-window-pdf-next-page)
             ("M-p" . aj/other-window-pdf-previous-page))


  ;; No scrollbar!
  (add-hook 'pdf-view-mode-hook #'aj/no-scrollbars)
  (defun aj/no-scrollbars ()
    (setq vertical-scroll-bar nil)))
#+end_src

**** Multipage view
Package adopted from some code with "issues" from politza. But it initially seems to work ok for getting the pdf "book" experience.

https://github.com/politza/pdf-tools/issues/74#issuecomment-90224020
https://gist.github.com/politza/a3339a4f3b3901fcce4c
#+begin_src emacs-lisp
(use-package pdf-view-multipage
  :straight (:host gitlab :repo "andersjohansson/pdf-view-multipage")
  :custom
  (pdf-view-multipage-odd-pages-left t)
  (pdf-view-multipage-remap-all t))
#+end_src

**** org-pdfview
#+begin_src emacs-lisp
(use-package org-pdfview
  :after org
  :defer t)
#+end_src

**** pdf-oc-quote
Copying from a pdf with correct org references and page numbers
https://gitlab.com/andersjohansson/pdf-oc-quote
#+begin_src emacs-lisp
(use-package pdf-oc-quote
  :straight (:depth full :host gitlab :repo "andersjohansson/pdf-oc-quote")
  :custom
  (pdf-oc-quote-fill-column 999999)
  :config
  (setq pdf-oc-quote-cite-functions
        (list
         #'pdf-oc-quote-cite-from-bibtex-or-json
         (pdf-oc-quote-make-cite-function (org-cite-insert nil)))))
#+end_src

**** pdf-view-restore
Save viewed page, like saveplace
#+begin_src emacs-lisp
(use-package pdf-view-restore
  :after pdf-tools
  :custom (pdf-view-restore-filename "~/.emacs.data/pdf-view-restore.el")
  :config
  (add-hook 'pdf-view-mode-hook 'pdf-view-restore-mode))
#+end_src

**** Functions for clearing annotations in pdfs
#+begin_src emacs-lisp
(defun aj/dired-pdf-delete-all-annotations-in-files ()
  "Delete all annotations in marked dired files."
  (interactive)
  (cl-loop for f in (dired-get-marked-files)
           do
           (find-file f)
           (aj/pdf-delete-all-annotations-in-buffer)
           (save-buffer)
           (kill-buffer)))

(defun aj/pdf-delete-all-annotations-in-buffer ()
  "Delete all pdf annotations in current buffer."
  (interactive)
  (cl-loop for a in (pdf-annot-getannots) do
           (pdf-annot-delete a)))
#+end_src

**** Get annotations from Sony PRS e-reader
#+begin_src emacs-lisp
(use-package prs-pdf-annotations
  :straight (:host 'gitlab :repo "andersjohansson/prs-pdf-annotations")
  :config
  (defun aj/zotero-to-prs ()
    "Copy a zotero pdf to Sony PRS."
    (interactive)
    (let ((aj/zoterofile-options (append '(:action aj/zotero-to-prs--copy) aj/zoterofile-options)))
      (aj/zoterofile)))

  (defun aj/zotero-to-prs--copy (file)
    "Do the copy of file to the Sony PRS."
    (copy-file
     file
     (expand-file-name "Sony_Reader/media/books/" prs-pdf-annotations-reader-path))))







#+end_src

** Display customizations: theme, modeline, etc.
*** Variable pitch
I want to use variable pitch for most things. But changing the default face to a variable pitch font is not a good idea, since so many tabular modes etc. depend on a monospace font. Setting it ~text-mode~ and in the modeline is good though.

#+begin_src emacs-lisp
(add-hook 'text-mode-hook #'variable-pitch-mode)
(set-face-attribute 'mode-line nil :family "Input Sans Condensed")
(set-face-attribute 'mode-line-inactive nil :family "Input Sans Condensed")
#+end_src

*** Document font (doc-font)
When editing longer text documents in org mode (or perhaps LaTeX) it’s good to use a nice sans serif like ET Book (https://github.com/edwardtufte/et-book).
This code defines a mode for doing a a local remapping to do that in a buffer.
Heavily inspired by the package ~mixed-pitch~ (https://gitlab.com/jabranham/mixed-pitch).
But also with some inspiration from here: https://lepisma.github.io/2017/10/28/ricing-org-mode/

#+begin_src emacs-lisp
(use-package doc-font
  ;; in /lisp
  :straight nil
  :commands doc-font-mode
  :config
  (defun aj/doc-font-toggle-org-num ()
    (when (eq major-mode 'org-mode)
      (if doc-font-mode
          (org-num-mode)
        (org-num-mode -1))))
  (add-hook 'doc-font-mode-hook
            #'aj/doc-font-toggle-org-num))
#+end_src

*** Cycle font size
Sometimes I feel the need for a generally bigger font. Especially when switching between my 13 inch 1920*1080-screen and my 24 inch 1920*1080-screen (systemwide screenwise fractional scaling is still not an option on linux, so both screens together doesn’t look that good). I usually achieve this by toogling text-scaling in gnome, and here are some functions for making emacs follow that.

I can then use this script to toggle size in gnome:
#+begin_src sh
scalingfactor=$(LANG=C printf "%.2f" $(gsettings get org.gnome.desktop.interface text-scaling-factor))

if[[ $scalingfactor == "1.25" ]]; then
	gsettings set org.gnome.desktop.interface text-scaling-factor 1.00
	emacsclient --eval "(aj/set-font-size-following-gnome 1.0)"
else
	gsettings set org.gnome.desktop.interface text-scaling-factor 1.25
	emacsclient --eval "(aj/set-font-size-following-gnome 1.25)"
fi
#+end_src


#+begin_src emacs-lisp
(defvar aj/startup-font-size nil)
(defvar aj/startup-gnome-text-scaling-factor nil)

(add-hook 'window-setup-hook #'aj/set-startup-font-size)

(defun aj/set-startup-font-size ()
  (setq aj/startup-gnome-text-scaling-factor
        (string-to-number
         (shell-command-to-string
          "gsettings get org.gnome.desktop.interface text-scaling-factor")))

  ;; FIXED!
  ;; emacs (PGTK-build) at startup seems to interpret the gnome text-scaling-factor
  ;; in a weird way, so I get too large font. Scaling down already
  ;; here works.
  ;; (when (< 1 aj/startup-gnome-text-scaling-factor)
  ;;   (set-face-attribute 'default nil :height
  ;;                       (round (/ (face-attribute 'default :height)
  ;;                                 aj/startup-gnome-text-scaling-factor))))
  (setq aj/startup-font-size
        (face-attribute 'default :height)))


(defun aj/set-font-size-following-gnome (scaling-factor)
  "Follow gnome’s SCALING-FACTOR in resizing default font size."
  (let ((height (round (* aj/startup-font-size
                          (/ scaling-factor
                             aj/startup-gnome-text-scaling-factor)))))
    (set-face-attribute 'default nil :height height))
  (run-hooks 'aj/cycle-font-size-hook))

(defvar aj/cycle-font-size-hook nil
  "Hooks run after global cycling of font-size.")

;; Old functions for just cycling

;; (defun aj/cycle-font-size ()
;;   (interactive)
;;   (cond ((< 7 (- aj/orig-font-size (face-attribute 'default :height)))
;;          ;; we are smaller
;;          (set-face-attribute 'default nil :height aj/orig-font-size))
;;         ((< 7 (- (face-attribute 'default :height) aj/orig-font-size))
;;          ;; we are larger
;;          (set-face-attribute 'default nil :height 90))
;;         ((> 7 (abs (- aj/orig-font-size (face-attribute 'default :height))))
;;          ;; we are approximately at default
;;          (set-face-attribute 'default nil :height 140)))
;;   (run-hooks 'aj/cycle-font-size-hook))

;;This is ctrl-win-shift-t (win normally is Super, but in pgtk apperently Hyper-super.. weird)
;; (bind-key "C-H-s-T" #'aj/cycle-font-size)
;; this is fn-T
;; (bind-key "<269025091>" #'aj/cycle-font-size)
#+end_src

*** Modeline
**** mini-modeline
#+begin_src emacs-lisp
(use-package mini-modeline
  :straight (:host 'github :repo "kiennq/emacs-mini-modeline")
  :demand t
  :hook (window-setup . mini-modeline-mode)
  :config

  (defsubst aj/modeline-column (pos)
    "Get the column of the position POS."
    (save-excursion (goto-char pos)
                    (current-column)))

  (defun aj/mode-line-region ()
    (when (and mark-active (not (derived-mode-p 'special-mode)))
      (let* ((beg (region-beginning))
             (end (region-end))
             (lines (count-lines beg (min end (point-max)))))
        (concat " ｢"
                (cond ((bound-and-true-p rectangle-mark-mode)
                       (let ((cols (abs (- (aj/modeline-column end)
                                           (aj/modeline-column beg)))))
                         (format "%d×%d " lines cols)))
                      ((> lines 1)
                       (format "·%d≣%d" (- end beg) lines))
                      ((format "·%d" (- end beg))))
                (format " %dw" (count-words beg end))
                "｣ "))))

  (setq mini-modeline-r-format '("%e" mode-line-front-space
                                 (:eval (aj/mode-line-region))
                                 mode-line-mule-info
                                 ;; mode-line-client
                                 mode-line-modified
                                 mode-line-remote
                                 ;; mode-line-frame-identification
                                 "  "
                                 mode-line-buffer-identification
                                 " " mode-line-position " "
                                 mode-line-misc-info))

  (setq mini-modeline-right-padding 1
        mini-modeline-enhance-visual nil)

  (add-hook 'aj/face-definitions-hook #'aj/mini-modeline-faces)
  (defun aj/mini-modeline-faces (theme)
    ;; (set-face-attribute 'mode-line nil :box t)
    (when (member theme '(modus-operandi modus-vivendi))
      (set-face-attribute 'mini-modeline-mode-line-inactive nil
                          :background (modus-themes-color 'bg-active) :height 0.14)
      (set-face-attribute 'mini-modeline-mode-line-active nil
                          :background (modus-themes-color 'blue-fringe-bg) :height 0.14))))
#+end_src

**** mini-modeline + doom-modeline :ARCHIVE:
#+begin_src emacs-lisp
;; (use-package doom-modeline
;;   :demand t
;;   :straight (doom-modeline :fork (:host github :repo "andersjohansson/doom-modeline" :branch "mini-modeline"))
;;   :custom
;;   (doom-modeline-buffer-file-name-style 'truncate-all)
;;   ;; (doom-modeline-bar-width (frame-parameter nil 'left-fringe))
;;   (doom-modeline-height 10)
;;   (doom-modeline-icon t)
;;   (doom-modeline-icons-scale-factor 0.75)
;;   (doom-modeline-icons-v-adjust-factor 0.75)
;;   :config

;;   (set-face-attribute 'doom-modeline nil :inherit 'default)
;;   (set-face-attribute 'doom-modeline-inactive nil :inherit 'shadow)

;;   ;; (set-face-attribute 'doom-modeline nil :inherit 'variable-pitch)
;;   ;; (set-face-attribute 'doom-modeline-inactive nil :inherit 'variable-pitch)

;;   ;; (cl-loop for f in '(doom-modeline-buffer-file doom-modeline-buffer-major-mode)
;;   ;;          do (set-face-attribute f nil :inherit
;;   ;;                                 (merge-face-attribute
;;   ;;                                  :inherit 'variable-pitch-mode
;;   ;;                                  (face-attribute f :inherit))))
;;   ;; (merge-face-attribute
;;   ;;  :inherit '(bold)
;;   ;;  '(variable-pitch-mode)
;;   ;;  ;; (face-attribute 'doom-modeline-buffer-file :inherit)
;;   ;;  )

;;   ;;   ;; pdf pages with pagelabels
;;   (advice-add 'doom-modeline-update-pdf-pages :override #'aj/doom-modeline-update-pdf-pages)

;;   (defun aj/doom-modeline-update-pdf-pages ()
;;     "Update PDF pages. Use pagelabels if available."
;;     (setq doom-modeline--pdf-pages
;;           (let* ((cp (eval `(pdf-view-current-page)))
;;                  (physical (format "%d/%d"
;;                                    cp
;;                                    (pdf-cache-number-of-pages)))
;;                  (currlabel (pdf-view-current-pagelabel)))

;;             (propertize
;;              (if (equal currlabel (number-to-string cp))
;;                  (concat " P: " physical " ")
;;                (concat " P:" currlabel " (" physical ") "))
;;              'face (if (doom-modeline--active)
;;                        'mode-line
;;                      'mode-line-inactive)))))
;;   )

(use-package mini-modeline
  :straight (:host 'github :repo "kiennq/emacs-mini-modeline")
  ;; :straight (mini-modeline :fork (:host github :repo "andersjohansson/mini-modeline" :branch "buffer-local-formats"))
  ;; :after doom-modeline
  :demand t
  :hook (window-setup . mini-modeline-mode)
  :config
  ;; (doom-modeline-def-modeline 'minibuffer-line
  ;;   '(workspace-name window-number matches buffer-info remote-host buffer-position word-count parrot selection-info objed-state misc-info persp-name battery grip irc mu4e gnus github debug lsp checker minor-modes input-method indent-info buffer-encoding major-mode process vcs))

  ;; (setq mini-modeline-r-format
  ;; (doom-modeline-format--minibuffer-line))

  (defsubst aj/modeline-column (pos)
    "Get the column of the position POS."
    (save-excursion (goto-char pos)
                    (current-column)))

  (defun aj/mode-line-region ()
    (when (and mark-active (not (derived-mode-p 'special-mode)))
      (let* ((beg (region-beginning))
             (end (region-end))
             (lines (count-lines beg (min end (point-max)))))
        (concat " ｢"
                (cond ((bound-and-true-p rectangle-mark-mode)
                       (let ((cols (abs (- (aj/modeline-column end)
                                           (aj/modeline-column beg)))))
                         (format "%d×%d " lines cols)))
                      ((> lines 1)
                       (format "·%d≣%d" (- end beg) lines))
                      ((format "·%d" (- end beg))))
                (format " %dw" (count-words beg end))
                "｣ "))))

  (setq mini-modeline-r-format '("%e" mode-line-front-space
                                 (:eval (aj/mode-line-region))
                                 mode-line-mule-info
                                 ;; mode-line-client
                                 mode-line-modified
                                 mode-line-remote
                                 mode-line-frame-identification
                                 mode-line-buffer-identification
                                 " " mode-line-position " "
                                 mode-line-misc-info))

  (setq mini-modeline-right-padding 1
        mini-modeline-enhance-visual nil)

  (add-hook 'aj/face-definitions-hook #'aj/mini-modeline-faces)
  (defun aj/mini-modeline-faces (theme)
    (set-face-attribute 'mode-line nil :box t)
    (when (member theme '(modus-operandi modus-vivendi))
      (set-face-attribute 'mini-modeline-mode-line-inactive nil
                          :background (modus-themes-color 'bg-active) :height 0.14)
      (set-face-attribute 'mini-modeline-mode-line-active nil
                          :background (modus-themes-color 'blue-fringe-bg) :height 0.14)))


  ;; no need for bars
  ;; (defun doom-modeline-segment--bar ()
  ;;   "Don’t show the bar when using mini-modeline"
  ;;   "")
  ;; (remove-hook 'after-setting-font-hook #'doom-modeline-refresh-bars)
  ;; (remove-hook 'window-configuration-change-hook #'doom-modeline-refresh-bars)


  ;; (defsubst doom-modeline-vspc ()
  ;;   "Text style with icons in mode-line."
  ;;   (propertize " " 'face 'doom-modeline-vspc-face))

  ;; (defsubst doom-modeline-spc ()
  ;;   "Text style with whitespace."
  ;;   (propertize " " 'face 'doom-modeline-spc-face))

  ;; ;; use some special doom-modelines
  ;; (defun aj/mini-modeline-set-doom-special (key)
  ;;   (when-let ((modeline (doom-modeline key)))
  ;;     (setq-local mini-modeline-r-format modeline)))

  ;; (add-hook 'Info-mode-hook (lambda () (aj/mini-modeline-set-doom-special 'info)))
  ;; (add-hook 'pdf-view-mode-hook (lambda () (aj/mini-modeline-set-doom-special 'pdf)))
  ;; (add-hook 'dired-mode-hook (lambda () (aj/mini-modeline-set-doom-special 'project)))
  ;; (add-hook 'dashboard-mode-hook (lambda () (aj/mini-modeline-set-doom-special 'project)))
  ;; (add-hook 'image-mode-hook (lambda () (aj/mini-modeline-set-doom-special 'media)))
  ;; (add-hook 'mu4e-compose-mode-hook (lambda () (aj/mini-modeline-set-doom-special 'message)))
  ;; (add-hook 'git-commit-mode-hook (lambda () (aj/mini-modeline-set-doom-special 'message)))
  ;; (add-hook 'magit-mode-hook (lambda () (aj/mini-modeline-set-doom-special 'vcs)))
  ;; (add-hook 'org-src-mode-hook (lambda () (aj/mini-modeline-set-doom-special 'org-src)))
  ;; (add-hook 'git-timemachine-mode-hook (lambda () (aj/mini-modeline-set-doom-special 'timemachine)))
  ;; (add-hook 'xwidget-webkit-mode-hook (lambda () (aj/mini-modeline-set-doom-special 'minimal)))

  ;; show modeline for some other special buffers. Currently
  ;; ispell-choices-buffer is one good candidate.
  ;; (defvar aj/buffers-with-modeline nil)
  ;; (with-eval-after-load 'ispell
  ;;   (add-to-list 'aj/buffers-with-modeline ispell-choices-buffer))

  ;; (advice-add #'get-buffer-create :after #'aj/local-visible-modeline)
  ;; (defun aj/local-visible-modeline (buffer)
  ;;   (when (member buffer aj/buffers-with-modeline)
  ;;     (with-current-buffer buffer
  ;;       (setq-local face-remapping-alist
  ;;                   '((mode-line . mode-line)
  ;;                     (doom-modeline . mode-line))))))

  ;; fix eldoc minibuffer display
  ;; (with-eval-after-load 'eldoc
  ;;     (defvar aj/eldoc-modeline-buffer nil)

  ;;     (setq eldoc-message-function #'aj/eldoc-minibuffer-message)

  ;;     (defun aj/eldoc-minibuffer-message (format-string &rest args)
  ;;       "Display messages in the mode-line when in the minibuffer.
  ;; Otherwise work like `message'."
  ;;       (if (minibufferp)
  ;;           (progn
  ;;             (setq aj/eldoc-modeline-buffer
  ;;                   (window-buffer
  ;; 	               (or (window-in-direction 'above (minibuffer-window))
  ;; 		               (minibuffer-selected-window)
  ;; 		               (get-largest-window))))
  ;; 	        (add-hook 'minibuffer-exit-hook
  ;; 		              (lambda () (setq eldoc-mode-line-string nil
  ;; 			                           ;; https://debbugs.gnu.org/16920
  ;; 			                           eldoc-last-message nil)
  ;;                         (with-current-buffer aj/eldoc-modeline-buffer
  ;;                           (setf (alist-get 'mode-line face-remapping-alist)
  ;;                                 'mini-modeline-mode-line)))
  ;; 		              nil t)
  ;; 	        (with-current-buffer aj/eldoc-modeline-buffer
  ;;               (setf (alist-get 'mode-line face-remapping-alist)
  ;;                     'mode-line-inactive)
  ;;               (when (and mode-line-format
  ;;                          (not (and (listp mode-line-format)
  ;;                                    (assq 'eldoc-mode-line-string mode-line-format))))
  ;; 	            (setq mode-line-format
  ;; 		              (list "" '(eldoc-mode-line-string
  ;; 			                     (" " eldoc-mode-line-string " "))
  ;; 			                mode-line-format)))
  ;;               (setq eldoc-mode-line-string
  ;;                     (when (stringp format-string)
  ;;                       (apply #'format-message format-string args)))
  ;;               (force-mode-line-update)))
  ;;         (apply #'message format-string args))))

  )
#+end_src

*** Themes
**** My own face definitions
Load my own face customizations after enabling a theme.
#+begin_src emacs-lisp
(defface aj/goto-address-mail-face '((t :inherit (shadow italic)))
  "" :group 'aj)
(setq goto-address-mail-face 'aj/goto-address-mail-face)

(defun aj/apply-face-definitions (&optional theme)
  "Do face definition stuff after loading THEME.
Also runs hook aj/face-definitions-hook."
  (unless (member theme '(use-package user)) ;enable theme calls itself with user theme.

    ;; don’t inherit bold for these:
    ;; (set-face-attribute 'orderless-match-face-0 nil :inherit nil)
    ;; (set-face-attribute 'orderless-match-face-1 nil :inherit nil)
    ;; (set-face-attribute 'orderless-match-face-2 nil :inherit nil)
    ;; (set-face-attribute 'orderless-match-face-3 nil :inherit nil)

    (with-eval-after-load 'org-indent
      ;; modus-operandi sets it to inherit fixed-pitch, but that is
      ;; bad with the detailed space matching I do!
      ;; (set-face-attribute 'org-indent nil :inherit 'org-hide)

      ;; but when going back to not overriding org-indent with
      ;; displayed spaces, we need org-hide and org-indent to both use
      ;; fixed-pitch to match ok.
      (set-face-attribute 'org-hide nil :inherit 'fixed-pitch)
      )

    (with-eval-after-load 'org-faces

      (set-face-attribute 'org-column nil :inherit 'fixed-pitch)
      (set-face-attribute 'org-column-title nil :inherit 'fixed-pitch)

      (set-face-attribute 'org-cite nil :inherit 'package-status-external)
      (set-face-attribute 'org-cite-key nil :inherit 'org-scheduled)

      (set-face-attribute 'org-document-title nil :height 1.5 :weight 'bold)
      ;; ;; (set-face-attribute 'org-meta-line nil :inherit 'org-drawer)

      (set-face-attribute 'org-block-begin-line nil :overline (modus-themes-color 'bg-active) :height 0.9)
      (set-face-attribute 'org-block-end-line nil :underline `(:color ,(modus-themes-color 'bg-active) :position t) :overline nil :height 0.9)

      ;;(set-face-attribute 'org-quote nil :weight 'light :height 0.95 :background nil)
      (set-face-attribute 'org-quote nil :height 0.95 :background 'unspecified)

      ;; ;; Use fixed-pitch for checkbox, compressed font for table
      (set-face-attribute 'org-checkbox nil :inherit 'fixed-pitch)
      (set-face-attribute 'org-table nil :family "Input Mono Compressed")

      (set-face-attribute 'org-agenda-date-today nil :background 'unspecified)

      ;; (dolist (n '("1" "2" "3" "4" "5" "6" "7" "8"))
      ;;   (set-face-attribute (intern (concat "org-level-" n)) nil :weight 'light))

      (when (eq theme 'modus-operandi)
        (set-face-attribute 'org-block nil :background "#f8f8f8")

        ;; avoid tags inheriting headline color
        ;; (set-face-attribute 'org-tag nil :foreground (modus-themes-color 'magenta-nuanced-fg)
        ;;                     :weight 'light)

        ;; (setq org-todo-keyword-faces
        ;;       `(("TODO" . ,(modus-themes-color 'red))
        ;;         ("STARTAD" . ,(modus-themes-color 'blue))
        ;;         ("VÄNTAR" . ,(modus-themes-color 'yellow))
        ;;         ("AVFÖRD" . ,(modus-themes-color 'green))
        ;;         ("DONE" . ,(modus-themes-color 'green)))))
        ))

    (with-eval-after-load 'org-modern
      (set-face-attribute 'org-modern-todo nil :height 1.0 :inherit 'org-modern-label :foreground (modus-themes-color 'red))

      (defface aj/org-waiting `((t :inherit org-modern-todo :foreground ,(modus-themes-color 'yellow))) "Face for waiting org-state" :group 'org-faces)
      (defface aj/org-started `((t :inherit org-modern-todo :foreground ,(modus-themes-color 'blue))) "Face for started org-state" :group 'org-faces)
      ;; (defface aj/org-done `((t :inherit org-modern-done)) "Face for done org-state" :group 'org-faces)

      (setq org-modern-todo-faces
            '(("TODO" . org-modern-todo)
              ("STARTAD" . aj/org-started)
              ("VÄNTAR" . aj/org-waiting)
              ("AVFÖRD" . org-modern-done)
              ("DONE" . org-modern-done))))


    (with-eval-after-load 'idle-highlight-mode
      (set-face-attribute 'idle-highlight nil :inherit nil :underline t))

    (set-face-attribute 'mode-line-buffer-id nil :inherit 'variable-pitch :weight 'regular)


    (run-hook-with-args 'aj/face-definitions-hook theme)))

(advice-add 'enable-theme :after #'aj/apply-face-definitions)
#+end_src

**** Gruvbox :ARCHIVE:
#+begin_src emacs-lisp
(use-package gruvbox
  :straight (gruvbox-theme
             :depth nil
             :fork (:host github :repo "andersjohansson/emacs-theme-gruvbox" :branch "ajfixes2")))
#+end_src

**** Modus-themes (I almost always use the light modus-operandi theme)
#+begin_src emacs-lisp
(use-package modus-themes
  :custom
  (modus-themes-headings '((t . (regular))))
  (modus-themes-syntax '(yellow-comments))
  (modus-themes-links '(faint neutral-underline))
  (modus-themes-fringes 'subtle)
  (modus-themes-diffs 'desaturated)
  (modus-themes-org-blocks 'gray-background)
  (modus-themes-mail-citations 'faint)
  (modus-themes-region '(bg-only no-extend))
  (modus-themes-org-agenda '((header-date . (bold-all))))
  (modus-themes-variable-pitch-ui t)
  (modus-themes-completions '((matches nil)
                              (selection background regular)))
  (modus-themes-mixed-fonts t)
  :config
  (setq org-fontify-whole-heading-line t))
#+end_src

**** Pdf background for modus themes
From modus-themes manual
#+begin_src emacs-lisp
(defun aj/pdf-tools-backdrop ()
  (face-remap-add-relative
   'default
   `(:background ,(modus-themes-color 'bg-alt))))

(add-hook 'pdf-tools-enabled-hook #'aj/pdf-tools-backdrop)
#+end_src

**** Define themes to use for dark and light and load light theme
#+begin_src emacs-lisp
(defvar aj/light-theme 'modus-operandi
  ;; 'gruvbox-light-hard
  )
(defvar aj/dark-theme 'modus-vivendi
  ;; gruvbox-dark-medium
  )

(load-theme aj/light-theme)
;; I’m not loading dark theme here, since I seldom use it.
#+end_src

**** Dark-light-switching
#+begin_src emacs-lisp
(defun aj/toggle-light-dark ()
  "Toggles light and dark theme in Emacs and Arc theme in gtk."
  (interactive)
  (cond
   ((custom-theme-enabled-p aj/light-theme)
    (disable-theme aj/light-theme)
    (unless (custom-theme-p aj/dark-theme)
      ;; I seldom use the dark theme, so now is the time to load it
      (load-theme aj/dark-theme t t))
    (enable-theme aj/dark-theme)
    (call-process-shell-command
     ;; "xfconf-query -c xsettings -p /Net/ThemeName -s \"Arc-Dark\""
     ;; for gnome:
     "dconf write /org/gnome/desktop/interface/gtk-theme \"'Arc-Dark'\""
     ))
   ((custom-theme-enabled-p aj/dark-theme)
    (disable-theme aj/dark-theme)
    (enable-theme aj/light-theme)
    (call-process-shell-command
     ;; "xfconf-query -c xsettings -p /Net/ThemeName -s \"Arc\""
     "dconf write /org/gnome/desktop/interface/gtk-theme \"'Arc'\""
     ))
   (t
    (enable-theme 'aj/light-theme))))

(bind-key "S-<f11>" #'aj/toggle-light-dark)
#+end_src

*** Lin-mode
More prominent line highlighting where it is suitable.
#+begin_src emacs-lisp
(use-package lin
  :straight (:host gitlab :repo "protesilaos/lin")
  :hook ((dired-mode
          mu4e-headers-mode
          elfeed-search-mode-hook)
         . lin-mode)
  :config
  (set-face-attribute
   'lin-hl nil
   :background (modus-themes-color 'cyan-nuanced-bg)))
#+end_src

*** Hl-line for prog-mode
#+begin_src emacs-lisp
(add-hook 'prog-mode-hook 'hl-line-mode)
#+end_src

*** Cursor
#+begin_src emacs-lisp
(setq-default cursor-type 'bar)
(setq-default cursor-in-non-selected-windows 'hollow)
(blink-cursor-mode -1)
(setq blink-cursor-alist '((bar . (bar . 1))))
#+end_src

*** Writeroom
#+begin_src emacs-lisp
(use-package writeroom-mode
  :commands writeroom-mode
  :bind ("<f12>" . writeroom-mode)
  :custom (writeroom-width 80)
  (writeroom-mode-line t)
  (writeroom-extra-line-spacing 0.3)
  (writeroom-restore-window-config t)
  (writeroom-global-effects '(writeroom-set-fullscreen))
  ;; :config
  ;; (doom-modeline-def-modeline 'writeroom-doom-modeline '(matches buffer-info buffer-position word-count selection-info github  vcs))

  ;; (defun aj/writeroom-mini-modeline ()
  ;;   (setq-local mini-modeline-r-format (doom-modeline-format--writeroom-doom-modeline)))

  ;; (add-hook 'writeroom-mode-hook #'aj/writeroom-mini-modeline)

  ;; (defun aj/writeroom-mini-modeline-disable ()
  ;;   (kill-local-variable 'mini-modeline-r-format))

  ;; (add-hook 'writeroom-mode-disable-hook #'aj/writeroom-mini-modeline-disable)
  )
#+end_src

*** Hide mode-line
#+begin_src emacs-lisp
(use-package hide-mode-line
  :defer t)
#+end_src

*** Colours in shell output
From: http://stackoverflow.com/questions/4726220/how-to-have-colors-in-the-output-of-emacs-shell-command/4729543#4729543
#+begin_src emacs-lisp
(use-package ansi-color
  :commands (ansi-color-apply-on-region ansi-color-make-color-map))

(defadvice display-message-or-buffer (before ansi-color activate)
  "Process ANSI color codes in shell output."
  (let ((buf (ad-get-arg 0)))
    (and (bufferp buf)
         (string= (buffer-name buf) "*Shell Command Output*")
         (with-current-buffer buf
           (ansi-color-apply-on-region (point-min) (point-max))))))
#+end_src


** Special libraries for research :org_async:

*** Scimax (use some of it) :ARCHIVE:
#+begin_src emacs-lisp
(use-package scimax
  :straight '(:host github :repo "jkitchin/scimax"))
#+end_src
*** sqlite3 :ARCHIVE:
#+begin_src emacs-lisp
(use-package sqlite3)
#+end_src
*** aj-forskning
Some special functions for managing my data files.
#+begin_src emacs-lisp
(use-package aj-forskning ;; private package
  :straight nil
  :commands (ajf/mount-forskningsdata ajf/swap-quotes-cycle aj/repeat-last-words ajf/stage-tag-changes))

;;; font-lock () och {}
;; (with-eval-after-load 'org
;;   (defvar ajf/font-lock-brackets-keywords
;; 	'(("{[^}]+}" (0 '(face font-lock-type-face) append))
;; 	  ("([^)]+)" (0 '(face font-lock-variable-name-face) append))))

;;   (defun ajf/font-lock-brackets ()
;; 	(dolist (el ajf/font-lock-brackets-keywords)
;; 	  (add-to-list 'org-font-lock-extra-keywords el t)))

;;   (add-hook 'org-font-lock-set-keywords-hook #'ajf/font-lock-brackets))
#+end_src

*** mplayer-mode
I use my fork, available here: https://github.com/andersjohansson/mplayer-mode/tree/org-sessions
(it’s messy and mixes up too many things in my current opinion...)
#+begin_src emacs-lisp
(use-package mplayer-mode
  :straight (:host github :repo "andersjohansson/mplayer-mode" :depth full :branch "org-sessions")
  :defer t
  :config (setq mplayer-display-time-in-modeline nil
				mplayer-default-seek-step 3))
#+end_src

*** orgqda-transcript
Also at: https://gitlab.com/andersjohansson/orgqda
#+begin_src emacs-lisp
(use-package orgqda-transcript
  :straight   :straight (:depth full :host gitlab :repo "andersjohansson/orgqda" :files ("orgqda-transcript.el"))
  :defer t
  :custom
  (orgqda-transcript-encode-filename-in-links nil)
  (orgqda-transcript-bind-fn-keys t)
  (orgqda-transcript-bind-1-4-keys t)
  (orgqda-transcript-set-up-speaker-keys t)
  (orgqda-transcript-set-up-speaker-keys-5-9 t)
  (orgqda-transcript-rebind-c-s-ret t)
  (orgqda-transcript-rebind-s-ret t)

  :config
  (defun aj/q-hydra-pre ()
    (undo-boundary)
    (insert "q"))
  (defhydra aj/q-hydra (:body-pre aj/q-hydra-pre
                                  :color blue
                                  :timeout 1)
    "other: "
    ("y" (progn (zap-to-char -1 ?q) (orgqda-transcript-insert-parenthesis-other-speaker "yeah")) "yeah")
    ("2" (progn (zap-to-char -1 ?q) (orgqda-transcript-insert-parenthesis-other-speaker "yeah yeah")) "yeah yeah")
    ("3" (progn (zap-to-char -1 ?q) (orgqda-transcript-insert-parenthesis-other-speaker "yeah yeah yeah")) "yeah yeah yeah")
    ("4" (progn (zap-to-char -1 ?q) (orgqda-transcript-insert-parenthesis-other-speaker "yeah yeah yeah yeah")) "yeah yeah yeah yeah")
    ("o" (progn (zap-to-char -1 ?q) (orgqda-transcript-insert-parenthesis-other-speaker "ok")) "ok")
    ("i" (progn (zap-to-char -1 ?q) (orgqda-transcript-insert-parenthesis-other-speaker "oh yeah")) "oh yeah")
    ("å" (progn (zap-to-char -1 ?q) (orgqda-transcript-insert-parenthesis-other-speaker "ok yeah")) "ok yeah")
    ("n" (progn (zap-to-char -1 ?q) (orgqda-transcript-insert-parenthesis-other-speaker "mhm")) "mhm")
    ("m" (progn (zap-to-char -1 ?q) (orgqda-transcript-insert-parenthesis-other-speaker "mmm")) "mmm")
    ("l" (progn (zap-to-char -1 ?q) (insert "(laugh)")))
    ("c" (progn (zap-to-char -1 ?q) (insert "[country]")))
    ("C" (progn (zap-to-char -1 ?q) (insert "[city]"))))

  (define-key orgqda-transcript-mode-map "q" #'aj/q-hydra/body)

  (defhydra aj/hydra-mplayer (:color blue)
    ("SPC"     #'mplayer-toggle-pause "pause")
    ("RET"     #'mplayer-toggle-pause-with-rewind "pause rew")
    ("<right>" #'mplayer-seek-forward "forward" :color pink)
    ("<left>"  #'mplayer-seek-backward "backward" :color pink)
    ("f"       #'mplayer-faster "faster" :color pink)
    ("s"       #'mplayer-slower "slower":color pink)
    ("r"       #'mplayer-reset-speed "reset speed")
    ("p"       #'mplayer-seek-position "seek pos")
    ("g"       #'mplayer-seek-timestamp "seek ts")
    ("t"       #'mplayer-insert-position "insert pos")
    ("d"       #'mplayer-toggle-osd "toggle osd")
    ("i"       #'mplayer-insert-timestamp "insert ts")
    ("Q"       #'mplayer-quit-mplayer "Quit mplayer")
    ("q" nil))

  (define-key orgqda-transcript-mode-map (kbd "C-c m") #'aj/hydra-mplayer/body)

  ;; (defvar aj/mplayer-last-seek-f (current-time))
  ;; (defvar aj/mplayer-number-of-seeks-f 0)
  ;; (defvar aj/mplayer-last-seek-b (current-time))
  ;; (defvar aj/mplayer-number-of-seeks-b 0)
  ;; (defvar aj/mplayer-seek-sequence '(0 .9 1.5 2 4))
  ;; (put 'aj/mplayer-seek-sequence 'safe-local-variable
  ;;      (lambda (x) (cl-every #'numberp x)))

  ;; (defun aj/mplayer-seek-backward ()
  ;;   (interactive)
  ;;   (if (and (eq last-command 'aj/mplayer-seek-backward)
  ;;            (> 1.0 (float-time (time-subtract (current-time) aj/mplayer-last-seek-b))))
  ;;       (cl-incf aj/mplayer-number-of-seeks-b)
  ;;     (setq aj/mplayer-number-of-seeks-b 1))
  ;;   (mplayer-seek-backward
  ;;    (or (nth aj/mplayer-number-of-seeks-b aj/mplayer-seek-sequence) 5))
  ;;   (setq aj/mplayer-last-seek-b (current-time)))

  ;; (defun aj/mplayer-seek-forward ()
  ;;   (interactive)
  ;;   (if (and (eq last-command 'aj/mplayer-seek-forward)
  ;;            (> 1.0 (float-time (time-subtract (current-time) aj/mplayer-last-seek-f))))
  ;;       (cl-incf aj/mplayer-number-of-seeks-f)
  ;;     (setq aj/mplayer-number-of-seeks-f 1))
  ;;   (mplayer-seek-forward
  ;;    (or (nth aj/mplayer-number-of-seeks-f aj/mplayer-seek-sequence) 5))
  ;;   (setq aj/mplayer-last-seek-f (current-time)))

  ;; (bind-key "<f1>" #'aj/mplayer-seek-backward orgqda-transcript-mode-map)
  ;; (bind-key "<f2>" #'aj/mplayer-seek-forward orgqda-transcript-mode-map)

  (bind-key "C-S-a" #'orgqda-transcript-beginning-or-indentation orgqda-transcript-mode-map)
  (bind-key "C-S-e" #'end-of-line orgqda-transcript-mode-map)
  ;; (dolist (key `(("1" . mplayer-toggle-pause-with-rewind)
  ;;                ("2" . mplayer-seek-backward)
  ;;                ("3" . mplayer-seek-forward)))
  ;;   (define-key orgqda-transcript-mode-map (car key) (cdr key)))

  (bind-key "C-+" #'aj/repeat-last-words orgqda-transcript-mode-map))
#+end_src

*** Edit only whitespace
A mode that enables editing of only whitespace. Useful in my transcript files for avoiding accidental edits while adding codes with orgqda.
#+begin_src emacs-lisp
(defvar edit-only-whitespace-keywords
   '(("[^[:space:]]" (0 '(face nil read-only t eow-readonly t)))))

(define-minor-mode edit-only-whitespace-mode
  "Allows only editing whitespace in buffer."
  :lighter nil
  (if edit-only-whitespace-mode
      (progn
        (setq-local font-lock-extra-managed-props (append '(read-only eow-readonly) font-lock-extra-managed-props))
        (font-lock-add-keywords
         nil
         edit-only-whitespace-keywords))
    (setq-local font-lock-extra-managed-props
                (thread-last font-lock-extra-managed-props
                  (remove 'read-only)
                  (remove 'eow-readonly)))
    (font-lock-remove-keywords nil edit-only-whitespace-keywords)
    (save-excursion
      (save-restriction
        (widen)
        (goto-char (point-min))
        (let ((inhibit-read-only t)
              prop)
          (while (setq prop (text-property-search-forward 'eow-readonly))
            (remove-text-properties
             (prop-match-beginning prop)
             (prop-match-end prop)
             '(read-only t eow-readonly t))))))))
#+end_src

** Standard frame parameters
I want my windows to launch at half screen width, to the left. But on my narrow laptop screen probably a little wider (90 chars).
#+begin_src emacs-lisp
(when (display-graphic-p)

  (scroll-bar-mode t)
  (set-scroll-bar-mode 'right)

  (defun aj/no-minibuffer-scrollbar-or-fringe (&optional frame)
    (set-window-scroll-bars (minibuffer-window frame) nil nil nil nil t)
    ;; no right fringe in minibuffer
    ;; disable this, looks bad for too-wide completion candidates
    ;; ($ instead of fringe marks)
    ;; (set-window-fringes (minibuffer-window frame) nil 0 nil t)
    )

  (aj/no-minibuffer-scrollbar-or-fringe)
  (add-hook 'after-make-frame-functions #'aj/no-minibuffer-scrollbar-or-fringe)
  ;; brute-force:
  ;; (add-hook 'window-configuration-change-hook #'aj/no-minibuffer-scrollbar-or-fringe)

  ;; this is a bit narrower for arc-gtk-theme:
  (add-to-list 'default-frame-alist '(scroll-bar-width . 12))

  (unless (eq 'pgtk (framep-on-display))
    ;; doesn’t work with pgtk
    (add-to-list 'default-frame-alist '(top . 0))
    (add-to-list 'default-frame-alist '(left . (+ -9)))
    (add-to-list 'default-frame-alist '(fullscreen . fullheight))

    (defun aj/frame-to-left ()
      (interactive)
      (if (> (x-display-pixel-width) aj/large-screen-min-width)
          (let ((hw (/ (/ (x-display-pixel-width) 2 ) (frame-char-width))))
            (add-to-list 'default-frame-alist (cons 'width hw))
            (set-frame-parameter nil 'width hw))
        (set-frame-parameter nil 'width 90)
        (add-to-list 'default-frame-alist (cons 'width 90)) ;small
        )
      (set-frame-parameter nil 'fullscreen 'fullheight)
      (set-frame-parameter nil 'left '(+ -0))
      (set-frame-parameter nil 'top 0))

    (add-hook 'after-init-hook #'aj/frame-to-left))
  )



#+end_src

** Late file settings
*** Auto-saving and reverting
**** Auto-saving of all buffers in visited files :ARCHIVE:
I don’t currently use this. It has caused more problems for me than it has solved. Over-eager auto-save interferes with some packages (most notably helm). And I’m kind of used to using unsaved buffers for some parts of my workflow.

Inspired by https://github.com/grettke/lolsmacs, it’s better to not keep inconsistent state in non-saved buffers. Especially since Emacs or my computer crashes from time to time.

#+begin_src emacs-lisp
(setq auto-save-default nil)
(auto-save-visited-mode)

;; also auto-save on various hooks

(defvar aj/save-all-buffers-hooks
  (append
   '(focus-out-hook mouse-leave-buffer-hook kill-emacs-hook suspend-hook))
  "When they run save all file buffers.")
(defvar aj/save-current-buffer-before-functions
  (append
   '(tex-compile vc-diff vc-next-action vc-revert))
  "Before they run save the buffer.")
(defvar aj/save-all-buffers-before-functions
  (append
   '(dired eshell grep ibuffer shell tex-compile)
   '(;; compile
     ns-do-hide-emacs goto-line)
   '(eval-buffer)
   '(org-export-dispatch org-babel-tangle org-babel-detangle)
   '(kill-current-buffer list-buffers save-buffers-kill-emacs save-buffers-kill-terminal switch-to-buffer pop-to-buffer)
   '(delete-frame delete-other-frames other-frame suspend-frame)
   '(delete-window quit-window)
   ;; doesn’t work with helm
   ;; other-window select-window
   )
  "Before they run save all file buffers.")

(defvar aj/save-buffers-debug nil "When non-nil message debug information for `aj/save-all-buffers'.")

(defun aj/save-all-buffers (&rest _args)
  "Save all file buffers.

When `aj/save-buffers-debug' is non-nil display performance information in
,*Messages* buffer.
Ignore all _ARGS. "
  (interactive)
  (let ((time (current-time)))
    (save-some-buffers t nil)
    (when aj/save-buffers-debug
      (message "aj/save-bufs completed in: %.06f seconds" (float-time (time-since time))))))

;; activate it all:
(cl-loop for hook in aj/save-all-buffers-hooks do
         (add-hook hook #'aj/save-all-buffers))

(cl-loop for fn in aj/save-all-buffers-before-functions do
         (advice-add fn :before #'aj/save-all-buffers))

;; (cl-loop for fn in aj/save-all-buffers-before-functions do
;;          (advice-remove fn #'aj/save-all-buffers))

(cl-loop for fn in aj/save-current-buffer-before-functions do
         (advice-add fn :before #'basic-save-buffer))


(define-key special-event-map [sigusr1] #'aj/save-all-buffers)
#+end_src

**** Auto reverting
#+begin_src emacs-lisp
(use-package autorevert
  :custom
  ;; Don't update pdfs in process of being built though:
  (global-auto-revert-ignore-modes '(pdf-view-mode))
  ;; why ever query if reverting is unproblematic (i.e. no edits)?
  (revert-without-query '(".*"))
  ;; Also auto refresh dired and some more, but be quiet about it
  (global-auto-revert-non-file-buffers t)
  (auto-revert-verbose nil)
  ;; I’m always on a reasonable system that can use notification

  ;; BUT polling seems to be needed for the initial activation in a
  ;; dired-buffer (see ‘auto-revert--global-adopt-current-buffer’,
  ;; which calls ‘auto-revert-set-timer’ and a file watcher doesn’t
  ;; seem to be added before first poll by timer, which never happens
  ;; if ‘auto-revert-avoid-polling’ is non-nil). This seems wrong.
  ;; seems to happen both for file and non-file buffers.
  ;; Reproducible in emacs -Q ?

  ;; (auto-revert-avoid-polling t)

  :init
  (global-auto-revert-mode t))
#+end_src

A function for reverting all opened files, even remote files (because auto-revert doesn’t work there)
#+begin_src emacs-lisp
(defun aj/revert-all-buffers ()
  "Refreshes all open buffers from their respective files."
  (interactive)
  (dolist (buf (buffer-list))
	(with-current-buffer buf
	  (when (and (buffer-file-name) (not (buffer-modified-p)))
		(revert-buffer t t t) )))
  (message "Refreshed open files."))
#+end_src

*** Recentf
#+begin_src emacs-lisp
(use-package recentf
  :demand t
  :init (require 'aj-forskning) ;; some important exclusions there
  :custom
  (recentf-max-menu-items 500)
  (recentf-max-saved-items 500)
  (recentf-keep '(recentf-keep-default-predicate ajf/recentf-keep))
  :config
  (defun aj/recentf-exclude (filename)
    (cl-loop for reg in completion-ignored-extensions
             when
             (string-match-p
              (if (equal "$" (substring reg -1))
                  reg
                (concat reg "$"))
              filename)
             return t))

  (recentf-mode 1))
#+end_src

* Final
** Load custom loaddefs :org_async:ARCHIVE:
#+begin_src emacs-lisp
(load-file aj/custom-loaddefs-file)
#+end_src
** Local variables for lisp
#+begin_src emacs-lisp
;; Local Variables:
;; byte-compile-warnings: '(not free-vars)
;; End:
#+end_src

*  Local Variables :ARCHIVE:

# Local Variables:
# eval: (progn (require 'use-package))
# aj/inhibit-flyspell: t
# End:
