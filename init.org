# -*-coding: utf-8; -*-
#+TITLE: Emacs init file
#+AUTHOR: Anders Johansson
#+PROPERTY: header-args :tangle yes :comments no :no-expand t
#+TODO: CHECK TODO | DONE

This is my init file. Kept as an org file which is tangled and compiled to ~init.elc~

Additional configuration is in [[file:lisp/aj-org-config.org][aj-org-config.org]] and [[file:lisp/aj-mail-config.org][aj-mail-config.org]], and some of my configurations have been put in separate packages which are generally available in gitlab or github repositories.

Hopefully some of this could be useful to others.

* Lexical-binding
#+BEGIN_SRC emacs-lisp
;; -*- lexical-binding: t -*-
#+END_SRC

* All configuration
** Meta
*** Tangling
Inspired by: https://github.com/larstvei/dot-emacs/blob/master/init.org

Emacs can only load =.el=-files. We can use =C-c C-v t= to run =org-babel-tangle=, which extracts the code blocks from the current file into a source-specific file (in this case a =.el=-file).

To avoid doing this each time a change is made we can add a function to the =after-save-hook= ensuring to always tangle and byte-compile the =org=-document after changes. But this generally annoys me, it’s easier to just choose when it should be done.

These functions possibly create two files from each org-file. When doing org-mode asynchronous exports, a small init file should be loaded, and this is automatically generated through tangling all trees tagged with "org_async". Even more specificity can be achieved with the tag "org_async_exclude" (which means a subtree of an "org_async"-tree can still be excluded). Additionally, "no_default_tangle" excludes trees from the standard init-files, and archived trees are always excluded (I use it for "commenting out" stuff). All to make as small and lean init files as possible.

#+BEGIN_SRC emacs-lisp
(defvar aj/org-init-files
  (list (expand-file-name "init.org" user-emacs-directory)
        (expand-file-name "aj-org-config.org" (concat user-emacs-directory "lisp"))
        (expand-file-name "aj-mail-config.org" (concat user-emacs-directory "lisp"))))

(defun aj/tangle-init (&optional file)
  (interactive)
  "If the current file is listed in aj/org-init-files the
code-blocks are tangled, and the tangled file is compiled.

Two files are possibly created, one with all trees, and one for
org mode async exports, using only trees tagged with “org_async”."
  (let* ((file (or file (buffer-file-name)))
         (file-noext (file-name-sans-extension file)))
    (when (or (called-interactively-p 'interactive)
              (and (member file aj/org-init-files)
                   ;; (y-or-n-p-with-timeout "Tangle+compile file?" 3 nil)
                   ))

	  (let* ((file-el (concat file-noext ".el"))
             ;; (file-async (concat file-noext "-org-async.el"))
             (prog-mode-hook nil)
             ;; avoid garbage-collection for this
             (gc-cons-threshold most-positive-fixnum))
        (aj/org-tangle-matching "-no_default_tangle-ARCHIVE" file file-el)
        ;; FIXME, I almost never use org-async export, so commenting
        ;; this out for now:
        ;; (aj/org-tangle-matching "org_async-org_async_exclude-ARCHIVE" file file-async)
        )
      ;; (load file-noext)
      )))

(defun aj/org-tangle-matching (match origin-file target-file)
  (with-current-buffer
      (find-file-noselect origin-file)
    (let* ((todo-only nil)
           (trees (mapconcat #'identity
                             (org-scan-tags #'aj/org-return-entry
                                            (cdr (org-make-tags-matcher match))
                                            todo-only) "\n\n"))
           (ofile (make-temp-file "org-init-tangle" nil ".org"))
           (ofb (find-file-noselect ofile t))
           (byte-compile-warnings '(not free-vars)))
	  (with-current-buffer ofb
        (insert trees)
        (let ((text-mode-hook nil)
              (outline-mode-hook nil)
              (org-mode-hook nil)
              (org-agenda-inhibit-startup t)
              (org-inhibit-startup t))
          (org-mode)
          (org-babel-tangle nil target-file "emacs-lisp")))
      (kill-buffer ofb)
      (when (and (file-exists-p target-file) (file-writable-p target-file))
        (chmod target-file 333)
        (byte-compile-file target-file)))))

(defun aj/org-return-entry ()
  (buffer-substring-no-properties
   (org-entry-beginning-position)
   (org-entry-end-position)))


;; attempts at doing this async

;; this is difficult, because it seems I need to have all my
;; load-paths initiated. In particular it didn’t work with
;; pdf-zotxt-quote which couldn’t find org-zotxt in the compilation.
;; But why was this needed?

;; tried to add only the neccesary stuff to init-async, but ...

;; (async-start
;;  ;; What to do in the child process
;;  (lambda ()
;;    (load-file "~/.emacs.d/init-async.elc")
;;    (aj/tangle-init "~/.emacs.d/init.org")
;;    (sleep-for 1)
;;    (message "hej!")
;;    (with-current-buffer "*Messages*"
;;      (buffer-string)))

;;  ;; What to do when it finishes
;;  (lambda (result)
;;    (message "Async process done, result should be 222: %s"
;;             result)))



;; (let ((weal (aj/org-get-weal)))
;;   (concat
;;    (when weal
;;      (format "#+BEGIN_SRC emacs-lisp\n ;;(with-eval-after-load '%s\n#+END_SRC
;; " weal))

;;    (when weal "#+BEGIN_SRC emacs-lisp\n;;)\n#+END_SRC")))

;; (defun aj/org-get-weal ()
;;   (save-excursion
;;     (save-match-data
;;       (when (search-forward-regexp
;;              ":weal_\\([a-z_]+\\):"
;;              (point-at-eol) t)
;;         (replace-regexp-in-string "_" "-" (match-string 1))))))
#+END_SRC

*** Autoloading in all custom load-paths :ARCHIVE:
Some of my own packages or libraries added in /lisp don’t normally get their autoloads parsed (like happens for libraries included in emacs or those handled via ~package.el~). This is my solution for that problem.
**** Loaddefs file :org_async:
To be loaded [[*Load custom loaddefs][at the end of init]].
#+BEGIN_SRC emacs-lisp
(defvar aj/custom-loaddefs-file (expand-file-name "custom-loaddefs.el" user-emacs-directory))
#+END_SRC
**** Functions
#+BEGIN_SRC emacs-lisp
(defvar aj/original-load-path load-path) ;; has to be initialized early

(defun aj/generate-custom-loaddefs ()
  (cl-letf ((generated-autoload-file aj/custom-loaddefs-file)
            (ignored-local-variables
             (cons 'generated-autoload-file ignored-local-variables))
            ((symbol-function 'file-relative-name) #'aj/identity-first)
            ((symbol-function 'autoload-file-load-name) #'aj/autoload-file-load-name))
    (apply #'update-directory-autoloads (aj/custom-load-paths))))

(defun aj/identity-first (arg &rest _r)
  arg)

(defun aj/autoload-file-load-name (name)
  (if (string-match "\\.elc?\\(\\.\\|\\'\\)" name)
      (substring name 0 (match-beginning 0))
    name))

(defun aj/custom-load-paths ()
  "Returns load paths added in init file, outside package area"
  (cl-remove-if
   (apply-partially #'string-match-p ".emacs.d/elpa")
   (cl-set-difference
    load-path aj/original-load-path :test 'equal)))

(defun aj/generate-loaddefs-after-byte-compile (filename &rest rest)
  (when (and
         ;; no autoloads in my config files
         (not (string-match-p "-config" filename))
         (cl-some (apply-partially #'file-in-directory-p filename)
                  (aj/custom-load-paths)))
    (aj/generate-custom-loaddefs)))

(advice-add 'byte-compile-file :after #'aj/generate-loaddefs-after-byte-compile)
#+END_SRC

** Early settings and loading
*** garbage-collection settings
Avoid garbage collection when initializing and in minibuffer.
https://bling.github.io/blog/2016/01/18/why-are-you-changing-gc-cons-threshold/
#+BEGIN_SRC emacs-lisp
(defun aj/set-no-gc ()
  (setq gc-cons-threshold most-positive-fixnum))

(defun aj/set-normal-gc ()
  (setq gc-cons-threshold 8000000))

(add-hook 'minibuffer-setup-hook #'aj/set-no-gc)
(add-hook 'minibuffer-exit-hook #'aj/set-normal-gc)

(aj/set-no-gc)
(add-hook 'after-init-hook #'aj/set-normal-gc)
#+END_SRC
*** Native compilation
When using the experimental ~feature/native-comp~ branch of emacs, lazily compile all libraries that are loaded.
#+begin_src emacs-lisp
(setq comp-deferred-compilation t
      comp-deferred-compilation-black-list
      '("init\\.el$"
        "aj-org-config\\.el$"
        "aj-mail-config\\.el$"
        "pdf-[-a-z]+\\.el$"
        "mu4e-query-helper\\.el$"))
#+end_src
*** Remove unnecessary GUI-elements
#+begin_src emacs-lisp
(setq inhibit-startup-message t)

(when window-system
  (setq frame-title-format '(buffer-file-name "%f" ("%b")))

  (defun aj/deactivate-gui (mode on)
    "Activate or deactivate MODE depending on ON, and defines a variable stating my choice."
    (when (fboundp mode)
      (funcall mode (or on -1))
      (eval `(defconst ,(intern (concat "aj/" (symbol-name mode) "-on")) ,on))))

                                        ; I always want it to the right
  (dolist (mm '((menu-bar-mode nil) (tool-bar-mode nil) (mouse-wheel-mode t)))
    (aj/deactivate-gui (car mm) (cadr mm))))
#+END_SRC

*** Fontset stuff, color emojis (emacs 27, yay!)
#+BEGIN_SRC emacs-lisp
;; Not needed.
;; (set-fontset-font ft nil (font-spec :name "Symbola") nil 'append)
;; (set-fontset-font ft 'cjk-misc (font-spec :name "Noto Sans CJK") nil)

;; Fonts for some emojis:
;; Emoticons
(set-fontset-font t '(#x1f600 . #x1f64f) "Noto Color Emoji")
;; Misc symbols
(set-fontset-font t '(#x1f300 . #x1F5ff) "Noto Color Emoji")
#+end_src

**** Monospacified? :ARCHIVE:

I never get this to work really well, the issue is with special (fancy) symbols in [[*Mail-config][mu4e]] that gets the columns misaligned when the characters are taken from another font than the default mono-space (I use Ubuntu mono, which lacks many symbols). The "monospacified" version of Symbola is supposed to solve this problem but seemingly doesn’t. For now, I have switched to symbols that are in Ubuntu mono ([[file:lisp/aj-mail-config.org::*Symbols][defined here]]).
#+begin_src emacs-lisp
(dolist (ft (fontset-list))
  (set-fontset-font ft 'unicode (font-spec :name "Ubuntu Mono"))
  (set-fontset-font ft 'unicode (font-spec :name "Symbola monospacified for Ubuntu Mono") nil 'append)
  (set-fontset-font ft nil (font-spec :name "Symbola monospacified for Ubuntu Mono") nil 'append)
  )
#+end_src

*** Determine which of my two computers we are running on
#+begin_src emacs-lisp
(defvar aj/ajeb (string= "ajeb" (system-name)))
#+end_src

*** My own custom variables, utility hooks and functions
Some variables are not suitable to keep in the init-file, I add these via customize to the custom-file, which is not checked in.
#+BEGIN_SRC emacs-lisp
(defgroup aj nil "Group for my private variables"
  :group 'emacs)

(defvar aj/large-screen-min-width 1500
  "The minimum pixel-width for a screen to be considered large.
  Used by `aj/frame-to-left'")

(defvar aj/face-definitions-hook nil
  "Extra functions for defining faces after loading themes etc.")

(defun aj/solarized-theme-p (&optional theme)
  (or (and theme (member theme '(solarized-light solarized-dark)))
      (custom-theme-enabled-p 'solarized-light)
      (custom-theme-enabled-p 'solarized-dark)))
#+END_SRC

*** Add /lisp to load-path :org_async:
#+begin_src emacs-lisp
(eval-and-compile
  (add-to-list 'load-path  "~/.emacs.d/lisp"))
#+end_src

*** Package-manager setup (use straight.el) :org_async:
#+begin_src emacs-lisp
(setq straight-use-package-by-default t
      straight-vc-git-default-clone-depth 1
      straight-cache-autoloads t
      straight-repository-branch "develop")

(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))
#+end_src


*** Bootstrap ~use-package~ :org_async:
#+begin_src emacs-lisp
;; (setq use-package-compute-statistics t)

(straight-use-package 'use-package)

(use-package validate
  :demand t)
(use-package bind-key
  :demand t)
#+end_src


*** Edit definitions with el-patch
#+begin_src emacs-lisp
(use-package el-patch)
#+end_src

*** No littering! :org_async:
#+begin_src emacs-lisp
(use-package no-littering
  :demand t
  :init
  (setq no-littering-etc-directory
        (expand-file-name "config/" user-emacs-directory)
        no-littering-var-directory "~/.emacs.data/")
  :config
  (with-eval-after-load 'recentf
    (add-to-list 'recentf-exclude no-littering-var-directory)
    (add-to-list 'recentf-exclude no-littering-etc-directory))
  (setq auto-save-file-name-transforms
        `((".*" ,(no-littering-expand-var-file-name "auto-save/") t))))
#+end_src

*** Hydra (used for definitions later on) :org_async:
#+BEGIN_SRC emacs-lisp
(use-package hydra
  :demand t)
#+END_SRC

*** Save-hist (don't use session, but save many useful history variables)
#+BEGIN_SRC emacs-lisp
(setq history-delete-duplicates t)

(setq savehist-additional-variables
      '(kill-ring search-ring regexp-search-ring
                  ;; extended-command-history

                  ;; all these should be added automatically when minibuffer is used in savehist-minibuffer-history-variables
                  ;; helm-M-x-input-history
                  ;; helm-adaptive-history helm-build-regexp-history
                  ;; helm-eshell-command-on-file-input-history
                  ;; helm-external-command-history helm-ff-history
                  ;; helm-file-name-history helm-grep-history
                  ;; helm-surfraw-engines-history
                  ;; helm-surfraw-input-history Info-history
                  ;; Info-search-history compile-history
                  ;; dired-regexp-history dired-shell-command-history
                  ;; face-name-history grep-files-history
                  ;; grep-find-history grep-history grep-regexp-history
                  ;; org-agenda-search-history org-insert-link-history
                  ;; org-refile-history org-tags-history
                  ;; pdf-occur-history query-replace-history
                  ;; shell-command-history
                  ))
(savehist-mode)

;; No properties in kill-ring saved by savehist, makes it much smaller
(defun aj/unpropertize-kill-ring ()
  (setq kill-ring (mapcar 'substring-no-properties kill-ring)))

(add-hook 'kill-emacs-hook 'aj/unpropertize-kill-ring -90)
#+END_SRC


*** Center frame (used for helm)
Code adapted from ime-frame
#+begin_src emacs-lisp
(defun aj/center-frame (&optional frame)
  "Center a frame on the screen."
  (interactive)
  (apply 'set-frame-position
         (let* ((frame (or (and (boundp 'frame) frame) (selected-frame)))
                (center (aj/center-frame--get-center frame)))
           `(,frame ,@center))))

(defun aj/center-frame--get-center (frame)
  "Return the center position of FRAME on it's display."
  (let ((screengeometry (assq 'geometry (frame-monitor-attributes frame))))
    (aj/center-frame--box-get-center
     (frame-pixel-width frame)
     (frame-pixel-height frame)
     (nth 3 screengeometry)
     (nth 4 screengeometry))))

(defun aj/center-frame--box-get-center (w h cw ch)
  "Center a box inside another box.

Returns a list of `(TOP LEFT)' representing the centered position
of the box `(w h)' inside the box `(cw ch)'."
  (list (/ (- cw w) 2) (/ (- ch h) 2)))
#+end_src

*** Helm
**** Loading helm
(Really too much in config section here. Should probably move it to another file)
#+begin_src emacs-lisp
(defcustom aj/shortened-helm-paths nil
  "List of replacements to do in `helm-recentf-source' and
`helm-source-files-in-current-dir' lists of files
Order is important! Only the first matching entry will be replaced.

Example of alist entry:
\(\"^~/my/favorite/path\" . \"MFP\"\)"
  :group 'aj
  :type '(alist :key-type regexp :value-type string))

(use-package helm
  :bind (("<f2>" . helm-imenu))
  :demand t
  :config
  (setq-default helm-command-prefix-key "C-c h")
  (require 'helm-config)
  (helm-mode)
  (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action) ; rebind tab to run persistent action
  (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action) ; make TAB works in terminal
  (define-key helm-map (kbd "C-z")  'helm-select-action) ; list actions using C-z

  (when (executable-find "curl")
    (setq helm-net-prefer-curl-p t))

  (setq
   helm-M-x-always-save-history t ; save also crashed commands
   helm-ff-search-library-in-sexp t ; search for library in `require' and `declare-function' sexp.
   helm-scroll-amount 8 ; scroll 8 lines other window using M-<next>/M-<prior>
   helm-ff-file-name-history-use-recentf t)
  ;;fuzzy matching
  (setq helm-buffers-fuzzy-matching t
        helm-recentf-fuzzy-match t
        helm-locate-fuzzy-match t
        helm-file-cache-fuzzy-match t
        helm-mode-fuzzy-match t
        helm-M-x-fuzzy-match t
        helm-semantic-fuzzy-match t
        helm-imenu-fuzzy-match t
        helm-apropos-fuzzy-match t
        helm-lisp-fuzzy-completion t)
  (helm-adaptive-mode 1)

  ;; display
  ;; Input in header line
  (setq helm-echo-input-in-header-line t)
  (add-hook 'helm-minibuffer-set-up-hook #'helm-hide-minibuffer-maybe)

  ;; split like I want it
  (setq helm-split-window-preferred-function #'aj/helm-split-window-fn)
  (defun aj/helm-split-window-fn (window)
    "Reuse a window below or split window below"
    (let* (split-width-threshold
           (win (if (and (fboundp 'window-in-direction)
                         (not (minibufferp helm-current-buffer)))
                    (or (helm-window-in-direction 'below)
                        (split-window (selected-window) nil 'below))
                  (split-window-sensibly window))))
      (setq helm-persistent-action-window-buffer (window-buffer win))
      win))

  ;; (setq ;;helm-display-function
  ;;  ;;#'aj/helm-display-child-frame
  ;;  ;; #'helm-default-display-buffer
  ;;  ;; helm-display-buffer-reuse-frame nil
  ;;  ;; helm-display-buffer-width 120
  ;;  ;; helm-display-buffer-height 35
  ;;  )


  ;; (defun aj/helm-display-child-frame (buffer &optional resume)
  ;;     "Display `helm-buffer' in a separate frame.
  ;; Function suitable for `helm-display-function',
  ;; `helm-completion-in-region-display-function'
  ;; and/or `helm-show-completion-default-display-function'.
  ;; See `helm-display-buffer-height' and `helm-display-buffer-width' to
  ;; configure frame size."
  ;;     (if (not (display-graphic-p))
  ;;         ;; Fallback to default when frames are not usable.
  ;;         (helm-default-display-buffer buffer)
  ;;       (setq helm--buffer-in-new-frame-p t)
  ;;       (let ((default-frame-alist
  ;;               `((parent . ,(selected-frame))
  ;;                 (width . ,helm-display-buffer-width)
  ;;                 (height . ,helm-display-buffer-height)
  ;;                 (undecorated . t)
  ;;                 (left-fringe . 2)
  ;;                 (right-fringe . 2)
  ;;                 (tool-bar-lines . 0)
  ;;                 (line-spacing . 0)
  ;;                 (desktop-dont-save . t)
  ;;                 (no-special-glyphs . t)
  ;;                 (tool-bar-lines . 0)
  ;;                 (left . 0)
  ;;                 (top . 0)
  ;;                 (title . "Helm")
  ;;                 (vertical-scroll-bars . nil)
  ;;                 (menu-bar-lines . 0)
  ;;                 (fullscreen . nil)
  ;;                 (visibility . ,(null helm-display-buffer-reuse-frame))
  ;;                 (minibuffer . nil)))
  ;;             display-buffer-alist)
  ;;         (helm-display-buffer-popup-frame buffer default-frame-alist)
  ;;         (set-face-attribute 'header-line (selected-frame)
  ;;                             :background nil :foreground 'unspecified :height 1.15
  ;;                             :inherit 'default)
  ;;         (aj/center-frame))
  ;;       (helm-log-run-hook 'helm-window-configuration-hook)))

  ;; Only show headers if several sources
  ;; https://www.reddit.com/r/emacs/comments/2z7nbv/lean_helm_window/
  (defun helm-toggle-header-line ()
    (if (eq 1 (length (ignore-errors (with-helm-buffer helm-sources))))
        (set-face-attribute 'helm-source-header nil :height 1)
      (set-face-attribute 'helm-source-header nil :height 1.0)))

  (add-hook 'helm-before-initialize-hook #'helm-toggle-header-line)


  ;;; bindings
  (define-key global-map [remap execute-extended-command] #'helm-M-x)
  (global-set-key (kbd "M-y") 'helm-show-kill-ring)

  (bind-key "<f1> a" #'helm-apropos)

  (global-set-key (kbd "C-x b") 'helm-mini)
  (global-set-key (kbd "C-x B") 'helm-mini)

  (global-set-key (kbd "C-x C-f") 'helm-find-files)
  (global-set-key (kbd "C-c h g") 'helm-google-suggest)

;;; Helm mini:

  (setq helm-mini-default-sources
        '(helm-source-buffers-list
          ;;aj/helm-source-favourite-files
          helm-source-recentf
          helm-source-files-in-current-dir
          aj/helm-source-dired-recent
          helm-source-buffer-not-found))
  (defvar aj/helm-source-dired-recent
    (helm-build-sync-source "Recent directories"
      :candidates 'dired-recent-directories
      :action '(("Open directory" . dired)
                ("Delete from dired-recent list" . aj/helm-action-dired-recent-delete))))

  (defun aj/shorten-helm-path (path)
    (cl-loop
     with disp = (or (car-safe path) path) with real = (or (cdr-safe path) path)
     for (match . replace) in aj/shortened-helm-paths
     when (string-match match disp)
     return (cons
             (concat (substring disp 0 (match-beginning 0))
                     (propertize replace 'face '(bold helm-ff-symlink))
                     (substring disp (match-end 0)))
             real)
     finally return path))

  (defun aj/helm-recentf-filtered-candidates-shorten (candidates _source)
    (mapcar #'aj/shorten-helm-path candidates))

  (with-eval-after-load 'helm-for-files
    (dolist (source '(helm-source-recentf helm-source-files-in-current-dir))
      (cl-callf append
          (alist-get 'filtered-candidate-transformer (symbol-value source))
        '(aj/helm-recentf-filtered-candidates-shorten))))

  ;;; helm-recentf, delete and add to ignore-list
  (with-eval-after-load 'helm-for-files
    (cl-callf append
        (alist-get 'action helm-source-recentf)
      '(("Delete from recentf and ignore" . aj/helm-remove-from-recentf-and-ignore))))

  (defun aj/helm-remove-from-recentf-and-ignore (candidate)
    (setq recentf-list (delete candidate recentf-list))
    (when-let ((pattern (read-string "Pattern for recentf-exclude: " candidate nil nil)))
      (customize-set-variable 'recentf-exclude (cons pattern recentf-exclude))))

  ;;; grep --> ripgrep

  (setq helm-grep-ag-command "rg -u --color=never --smart-case --no-heading --line-number %s %s %s"
        helm-grep-file-path-style 'relative)
  (bind-key "C-s" #'helm-ff-run-grep-ag helm-find-files-map)

  (defun aj/helm-rg-org-files ()
    "Function for searching through all org files in home directory."
    (interactive)
    (advice-add 'helm-grep--filter-candidate-1 :filter-return
                #'aj/shorten-helm-path)
    (unwind-protect
        (let ((helm-grep-file-path-style 'absolute))
          (helm-grep-ag-1 (expand-file-name "~") '("-torg")))
      (advice-remove 'helm-grep--filter-candidate-1
                     #'aj/shorten-helm-path)))


  ;;; more candidates for helm-ucs
  (defun aj/helm-500-candidates (fn &rest args)
    (let ((helm-candidate-number-limit 500))
      (apply fn args)))

  (advice-add 'helm-ucs :around #'aj/helm-500-candidates)
  (advice-add 'helm-imenu :around #'aj/helm-500-candidates)

  ;;; mark-ring extra
  (defun aj/pop-to-mark-invoke-helm (fun)
    (interactive)
    (if (eq last-command 'pop-to-mark-command)
        (helm-all-mark-rings)
      (funcall fun)))

  (defvar helm-mark-ring-map
    (let ((map (make-sparse-keymap)))
      (set-keymap-parent map helm-map)
      (define-key map (kbd "C-<SPC>") 'helm-next-line) map)
    "Keymap for `helm-all-mark-rings'.")

  (setq set-mark-command-repeat-pop t)
  (with-eval-after-load 'helm-ring
    (add-to-list 'helm-source-mark-ring `(keymap . ,helm-mark-ring-map)))
  (advice-add 'pop-to-mark-command :around #'aj/pop-to-mark-invoke-helm)


  ;; Don’t want launched processes lying around being children to
  ;; emacs (and being killed when I have to kill emacs). Therefore I
  ;; use ‘call-process-shell-command’ instead of
  ;; ‘start-process-shell-command’.

  (defun aj/helm-run-or-raise (exe &optional file)
    (let ((real-com (car (split-string exe))))
      (when (member real-com helm-external-commands-list)
        (message "Starting %s..." real-com)
        (if file
            (call-process-shell-command
             (format "%s %s"
                     real-com
                     (shell-quote-argument
                      (if (eq system-type 'windows-nt)
                          (helm-w32-prepare-filename file)
                        (expand-file-name file))))
             nil 0)
          (call-process-shell-command real-com nil 0)))))

  (advice-add 'helm-run-or-raise :override #'aj/helm-run-or-raise)


  ;;; helm-apropos, mark out custom-variables

  (defun helm-def-source--emacs-variables-aj (&optional default)
    (helm-build-in-buffer-source "Variables"
      :init (lambda ()
              (helm-apropos-init
               (lambda (x) (and (boundp x) (not (keywordp x)))) default))
      :fuzzy-match helm-apropos-fuzzy-match
      :filtered-candidate-transformer
      (lambda (cands source)
        (when (null helm-apropos-fuzzy-match)
          (setq cands (helm-apropos-default-sort-fn cands source)))
        (cl-loop for c in cands
                 collect
                 (if (custom-variable-p (intern c))
                     (cons (concat c " ⚙") c)
                   c)))
      :nomark t
      :persistent-action (lambda (candidate)
                           (helm-elisp--persistent-help
                            candidate 'helm-describe-variable))
      :persistent-help "Toggle describe variable"
      :action '(("Describe variable" . helm-describe-variable)
                ("Find variable" . helm-find-variable)
                ("Info lookup" . helm-info-lookup-symbol)
                ("Set variable" . helm-set-variable))
      :action-transformer 'helm-apropos-action-transformer))

  (setq helm-apropos-function-list
        '(helm-def-source--emacs-commands
          helm-def-source--emacs-variables-aj
          helm-def-source--emacs-functions
          helm-def-source--eieio-classes
          helm-def-source--eieio-generic
          helm-def-source--emacs-faces))
  )
#+end_src

**** Helm-fuz
For modern fuzzy matching with a binary module built on Rust libraries.
We need to add "target" to the fuz recipe so that it isn’t removed by straight (we don’t want to rebuild the fuz module every time we start Emacs).
#+begin_src emacs-lisp
(use-package fuz
  :straight (fuz :repo "rustify-emacs/fuz.el" :host github
                 :files ("fuz*.el" "Cargo.toml" "Cargo.lock" "src" "target")))

(use-package helm-fuz
  :after helm
  :config (helm-fuz-mode t))
#+end_src

**** helm-flx :ARCHIVE:
Different fuzzy search algorithm, is this needed?
#+BEGIN_SRC emacs-lisp
(use-package helm-flx
  :after helm
  :init (helm-flx-mode t))
#+END_SRC

**** Open zotero library files
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'helm-files
  (defcustom aj/helm-zotero-library nil
    "Directory of Zotero library files"
    :group 'aj
    :type 'directory)

  (defvar aj/helm-zoterofile-history)
  (defvar aj/zoterofiles-frame-manage nil)

  (defun aj/open-zoterofile-new-frame ()
    (interactive)
    (let ((ocframe
           (make-frame '((width . 100) (height . 20) (name . "helm-zotero")
                         (window-system . x) (fullscreen . nil))))
          (helm-full-frame t)
          (aj/zoterofiles-frame-manage t))
      (select-frame-set-input-focus ocframe)
      (aj/center-frame)
      (aj/helm-open-zoterofile)))

  (defun aj/helm-open-zoterofile ()
    (interactive)
    (let* ((oe '("Open externally" . aj/helm-open-file-externally-delete-frame))
           (ff '("Find file" . aj/helm-find-many-files-widen-frame))
           (active-actions (if aj/zoterofiles-frame-manage
                               (list oe ff)
                             (list ff oe))))
      (helm :sources
            (list
             (helm-build-sync-source "Zotero recently modified"
               :action active-actions
               :pattern-transformer #'helm-recentf-pattern-transformer
               :keymap helm-generic-files-map
               :candidates #'aj/helm-zotero-recently-modified)
             (helm-build-sync-source "Zotero recentf"
               :candidates #'aj/recentf-list-zotero
               :action active-actions
               :fuzzy-match t
               :filtered-candidate-transformer #'helm-highlight-files
               :pattern-transformer #'helm-recentf-pattern-transformer
               :match-part #'aj/helm-zotero-match-part
               :keymap helm-generic-files-map)
             (helm-build-sync-source "Zotero files"
               :candidates #'aj/helm-zotero-files
               :action active-actions
               :fuzzy-match t
               :candidate-transformer #'helm-skip-boring-files
               :filtered-candidate-transformer #'helm-highlight-files
               :pattern-transformer #'helm-recentf-pattern-transformer
               :match-part #'aj/helm-zotero-match-part
               :keymap helm-generic-files-map
               ))


            :buffer "*helm-zoterofile*"
            :history 'aj/helm-zoterofile-history
            :ff-transformer-show-only-basename t)))


  (defun aj/helm-zotero-recently-modified ()
    (when (file-accessible-directory-p aj/helm-zotero-library)
      (with-temp-buffer
        (call-process "ls" nil t nil "-t" "-1" aj/helm-zotero-library)
        (mapcar (lambda (x) (cons x (expand-file-name x aj/helm-zotero-library)))
                (split-string
                 (buffer-substring (point-min)
                                   (progn (goto-char (point-min))
                                          (forward-line 20) (point)))
                 "\n"
                 t)))))

  (defun aj/recentf-list-zotero ()
    (cl-remove-if-not (lambda (it) (string-match-p aj/helm-zotero-library it))
                      recentf-list))

  (defun aj/helm-zotero-files ()
    (when (file-accessible-directory-p aj/helm-zotero-library)
      (directory-files aj/helm-zotero-library t "\\.\\(pdf\\|djvu\\|vue\\)$")))

  (defun aj/helm-zotero-match-part (candidate)
    (if (or helm-ff-transformer-show-only-basename
            helm-recentf--basename-flag)
        (helm-basename candidate) candidate))

  (defun aj/helm-find-many-files-widen-frame (_ignore)
    (helm-find-many-files t)
    (when aj/zoterofiles-frame-manage
      (aj/frame-to-left)
      (set-frame-name (buffer-file-name))))
  (defun aj/helm-open-file-externally-delete-frame (file)
    (helm-open-file-externally file)
    (when aj/zoterofiles-frame-manage
      (delete-frame))))
#+END_SRC
**** TODO Utvärdera om vi borde använda helm-multi-files istället för att lägga allt i helm-mini
**** COMMENT Helm omni-files, buffers, recentf                      :ARCHIVE:

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x C-b") 'aj/helm-omni-buffers)
  (global-set-key (kbd "C-x b") 'aj/helm-omni-buffers)
  (global-set-key (kbd "C-x C-r") 'aj/helm-omni-recent)

  (defvar aj/helm-omni-history nil)

  (defun aj/helm-omni-buffers (&rest arg)
    (interactive)
    (require 'helm-files)
    (unless helm-source-buffers-list
      (setq helm-source-buffers-list
            (helm-make-source "Buffers" 'helm-source-buffers)))
    (helm :sources
          '(helm-source-buffers-list
            helm-source-recentf
            helm-source-files-in-current-dir
            helm-source-locate
            helm-source-bookmarks
            helm-source-buffer-not-found)
          :buffer "*helm omni recentf*"
          :truncate-lines t
          :history 'aj/helm-omni-history
          :ff-transformer-show-only-basename nil))

  (defun aj/helm-omni-recent (&rest arg)
    (interactive)
    (require 'helm-files)
    (unless helm-source-buffers-list
      (setq helm-source-buffers-list
            (helm-make-source "Buffers" 'helm-source-buffers)))
    (helm :sources
          '(helm-source-recentf
            helm-source-buffers-list
            helm-source-locate
            helm-source-files-in-current-dir
            helm-source-bookmarks
            helm-source-buffer-not-found)
          :buffer "*helm omni recent*"
          :truncate-lines t
          :history 'aj/helm-omni-history
          :ff-transformer-show-only-basename nil))

#+END_SRC


**** Helm-recoll                                                    :ARCHIVE:
#+begin_src emacs-lisp
(use-package helm-recoll
  :commands helm-recoll
  :config (helm-recoll-create-source "default" "~/.recoll/"))
#+end_src

**** Favourite files (to mark files which should be prioritized in helm matches) :ARCHIVE:
#+BEGIN_SRC emacs-lisp
(defvar aj/favourite-files nil)
(with-eval-after-load "savehist-mode"
  (add-to-list 'savehist-additional-variables 'aj/favourite-files))

(defun aj/add-favourite-file ()
  (interactive)
  (if-let ((name (or
                  (buffer-file-name)
                  (and (eq major-mode 'dired-mode) default-directory))))
      (cl-pushnew name aj/favourite-files :test #'string=)
    (user-error "Not in a file- or dired-buffer")))

(with-eval-after-load "helm-for-files"
  (defun aj/remove-favourite-file (_candidate)
    ;; to be run from helm
    (cl-loop for file in (helm-marked-candidates)
             do (setq aj/favourite-files (delete file aj/favourite-files))))

  (defclass aj/helm-favourite-files-source (helm-source-sync helm-type-file)
    ((candidates :initform (lambda () aj/favourite-files))
     (pattern-transformer :initform 'helm-recentf-pattern-transformer)
     (match-part :initform (lambda (candidate)
                             (if (or helm-ff-transformer-show-only-basename
                                     helm-recentf--basename-flag)
                                 (helm-basename candidate) candidate)))
     (persistent-action :initform 'helm-ff-kill-or-find-buffer-fname)
     (fuzzy-match :initform t)))

  (defmethod helm--setup-source :after ((source aj/helm-favourite-files-source))
    (setf (slot-value source 'action)
          (append (symbol-value (helm-actions-from-type-file))
                  '(("Delete file(s) from aj/favourite-files" .
                     aj/remove-favourite-file))))
    (setf (slot-value source 'filtered-candidate-transformer)
          (append (slot-value source 'filtered-candidate-transformer)
                  '(aj/helm-recentf-filtered-candidates-shorten))))

  (defvar aj/helm-source-favourite-files
    (helm-make-source "Favourite files" 'aj/helm-favourite-files-source)))
#+END_SRC

**** Favorite directories
http://endlessparentheses.com/visit-directory-inside-a-set-of-directories.html
#+begin_src emacs-lisp
(defcustom aj/favorite-directories nil
  "List of favorite directories.
Used in `aj/visit-favorite-dir'. The order here affects the order
that completions will be offered. Each element is a list of
directory, search depth, and whether to include files."
  :type '(repeat (list (directory :tag "Directory")
                       (integer :tag "Search depth")
                       (boolean :tag "Include files")))
  :group 'aj)

(defvar aj/fav-dir-history nil)

(defun aj/visit-favorite-dir (files-too)
  "Offer all directories inside a set of directories.
Compile a list of all directories inside each element of
`aj/favorite-directories', and visit one of them with
`ido-completing-read'.
With prefix argument FILES-TOO also offer to find files."
  (interactive "P")
  (let ((completions
         (apply #'append
                (mapcar (lambda (x)
                          (aj/get-dir-list (car x) (cadr x) (or files-too (nth 2 x))))
                        aj/favorite-directories)))
        (helm-candidate-number-limit nil))
    (dired
     (helm-comp-read "Open directory: " completions
                     :input-history aj/fav-dir-history))))


(defun aj/get-dir-list (dir level &optional files-too)
  "Get list of directories (or files with FILES-TOO) to a certain level"
  (if (and (file-directory-p dir) (> level 0))
      ;; recurse into directories if we have levels left
      (apply #'append
             (list dir)
             (mapcar
              (lambda (sdir) (aj/get-dir-list sdir (1- level) files-too))
              (mapcar
               #'abbreviate-file-name
               (cl-remove-if-not
                (if files-too #'file-readable-p
                  #'file-directory-p)
                (directory-files
                 (expand-file-name dir)
                 t "^[^\.].*" t)))))
    ;; just return dir or file
    (list dir)))

;;TODO, define as helm-source
;; (defclass aj/helm-favorit-dir-class (helm-source-sync helm-type-timers)
;;   ((candidates :initform timer-idle-list)
;;    (allow-dups :initform t)
;;    (volatile :initform t)
;;    (filtered-candidate-transformer
;;     :initform
;;     (lambda (candidates _source)
;;       (cl-loop for timer in candidates
;;                collect (cons (helm-elisp--format-timer timer) timer))))))

;; (defvar helm-source-idle-time-timers
;;   (helm-make-source "Idle Time Timers" 'helm-idle-time-timers-class))
#+end_src

Note that C-x d is usually bound to dired. I find
this redundant with C-x C-f, so I don't mind
overriding it, but you should know before you do.
#+begin_src emacs-lisp
(define-key ctl-x-map "d" #'aj/visit-favorite-dir)

#+end_src



*** Things to load with org
**** Stuff
#+begin_src emacs-lisp
;; TODO, why here?
(use-package orgqda
  :straight (:depth full :host gitlab :repo "andersjohansson/orgqda")
  :defer t
  :after org
  :init (put 'orgqda-csv-dir 'safe-local-variable #'file-directory-p)
  :config (setq orgqda-exclude-tags
                (append (mapcar #'car org-tag-persistent-alist)
                        '("ARCHIVE" "Reflektion" "Observation" "Forskningsdagbok")))
  (defhydra aj/orgqda-hydra (:color blue :hint t)
	("m" #'orgqda-mode "Toggle mode")
	("ö" #'orgqda-list-tags "List tags")
	("C-ö" #'orgqda-list-tags nil)
	("ä" #'normal-mode "Normal mode")
	("Ö" #'orgqda-list-tags-full "List and extract")
	("c" #'orgqda-collect-tagged "Collect tagged")
	("C-c" #'orgqda-collect-tagged "Collect tagged")
	("v" #'orgqda-collect-tagged-csv "Collect csv")
	("V" #'orgqda-collect-tagged-csv-save "Collect csv save")
	("b" #'orgqda-collect-tagged-csv-save-all "Save all as csv"))
  (bind-key "C-c C-ö" 'aj/orgqda-hydra/body orgqda-mode-map))

(use-package org-pomodoro
  :after org)
(use-package org-download
  :after org)
#+end_src
**** org-pdfview
#+BEGIN_SRC emacs-lisp
(use-package org-pdfview
  :after org
  :defer t)
#+END_SRC
**** org clock hydra
#+BEGIN_SRC emacs-lisp
(bind-key "C-c w" #'hydra-org-clock/body)
;; make byte-compiler happy?
(dolist (x '(org-clock-in org-clock-out org-clock-in-last org-clock-modify-effort-estimate org-clock-cancel org-clock-goto org-clock-display org-clock-report org-clocking-p))
  (autoload x "org-clock"))

(defhydra hydra-org-clock (:color blue :hint nil)
  "
 In/out^        ^Edit^         ^Summary     (_?_)
---------------------------------------------
 _i_n, select    _e_dit effort  _g_oto entry
 _I_n here       _E_ffort here  _d_isplay
 _c_ontinue      _C_ancel       _d_isplay
 _o_ut           _r_eport
 _D_one
 _p_omodoro (select)
 _l_ast task pomodoro (continue)
 _P_omodoro here"
  ("i" aj/org-clock-in-list)
  ("I" aj/org-clock-in-here)
  ("o" org-clock-out)
  ("D" aj/org-mark-current-clocking-done)
  ("c" org-clock-in-last)
  ("p" (org-pomodoro '(4)))
  ("l" (org-pomodoro '(16)))
  ("P" org-pomodoro)
  ("e" org-clock-modify-effort-estimate)
  ("E" org-set-effort)
  ("C" org-clock-cancel)
  ("g" org-clock-goto)
  ("d" org-clock-display)
  ("r" org-clock-report)
  ("?" (org-info "Clocking commands")))

(defun aj/org-clock-in-list ()
  (interactive) (org-clock-in '(4)))

(defun aj/org-clock-in-here ()
  (interactive)
  (cond
   ((eq major-mode 'org-mode)
    (org-clock-in))
   ((eq major-mode 'org-agenda-mode)
    (org-agenda-clock-in))
   (t (message "Not in org file or agenda"))))

(defun aj/helm-org-clock-in (marker)
  (save-window-excursion
    (switch-to-buffer (marker-buffer marker))
    (goto-char (marker-position marker))
    (org-clock-in)))

(defun aj/org-mark-current-clocking-done ()
  (interactive)
  (when (org-clocking-p)
    (save-window-excursion
      (org-clock-goto)
      (org-todo 'done))))
#+END_SRC


*** Org init
**** org init
#+begin_src emacs-lisp
(use-package org
  :bind (("C-c a" . org-agenda) ("C-c c" . org-capture))
  :commands org-mode
  :demand t
  :init
  ;; (require 'org-protocol) ;; move to modules? autoload the entry commands (don’t seem to be)
  (setq org-directory "~/org"
        org-ellipsis " ⤵"
        org-export-backends '(beamer odt ascii html icalendar latex)
        org-modules '(org-habit org-inlinetask org-mu4e org-id org-bullets org-pdfview)
        org-list-allow-alphabetical t
        org-id-method 'ts
        org-id-prefix "aj"
        org-id-link-to-org-use-id 'use-existing
        org-agenda-files (expand-file-name "agenda-files" org-directory))
  (defcustom aj/org-work-agenda-files nil
    "Agenda files connected to work"
    :group 'aj
    :type '(repeat file))
  :config
  (setq org-version "9.4")
  (defun org-version () "9.4")
  ;; (message "Laddade org")
  ;; (load-library "helm-mode)"
  (load-library "aj-org-config")
  ;; (require 'helm-mode)
  ;; (require 'aj-org-config)
  )
#+end_src
**** org init async                             :org_async:no_default_tangle:
#+begin_src emacs-lisp
(use-package org
  :demand t
  :commands org-mode
  :init (progn
          (setq org-directory "~/org"
                org-export-backends '(beamer odt ascii html icalendar latex)
                org-modules '(org-inlinetask org-zotxt org-id)
                org-list-allow-alphabetical t))
  :config (require 'ox) (require 'aj-org-config-org-async))
#+end_src
*** Swallow
#+begin_src emacs-lisp

#+end_src

*** Tooltip-mode :ARCHIVE:
I want to use the echo area (hence ~(tooltip-mode -1)~), but don’t want help echo messages to be truncated, but resized!
#+begin_src emacs-lisp
(tooltip-mode -1)
(setq tooltip-resize-echo-area t)
#+end_src

*** Flycheck
#+begin_src emacs-lisp
(use-package flycheck
  :commands (global-flycheck-mode)
  :init (add-hook 'after-init-hook #'global-flycheck-mode)
  :defer 5
  :config (progn
            (setq-default flycheck-emacs-lisp-load-path 'inherit)
            (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc))
            (add-hook 'text-mode-hook (lambda ()(flycheck-mode -1)))))
#+end_src

*** Saveplace is neccessary
#+BEGIN_SRC emacs-lisp
(require 'saveplace)
(setq save-place-limit 1000)
(save-place-mode 1)
#+END_SRC
*** Custom file :org_async:
#+begin_src emacs-lisp
(setq custom-file "~/.emacs.d/custom.el")
(load custom-file)
#+end_src
** Debugging
#+BEGIN_SRC emacs-lisp
(use-package profiler
  :bind (("<C-f7>" . aj/start-profiler)
         ("<C-f8>" . profiler-report))
  :init
  (defun aj/start-profiler () (interactive)
         (profiler-start 'cpu)))
#+END_SRC

** Mail-config (mu4e)
Use mu4e, the extensive config is in an [[file:lisp/aj-mail-config.org][external file]].
#+BEGIN_SRC emacs-lisp
(use-package mu4e
  :bind (("C-x ö" . mu4e)
         ("C-x m" . mu4e-compose-new)
         ("C-x i" . mu4e~headers-jump-to-maildir)
         ("C-x å" . mu4e-headers-search-bookmark))
  :defer 10
  :init (setq mu4e-get-mail-command "aj-mailsync" ; bash script
                                        ; running several offlineimap
                                        ; processes for syncing
                                        ; different mailboxes
              mu4e-update-interval 600
              mu4e-view-show-images t
              mu4e-use-fancy-chars t
              mu4e-headers-results-limit 200 ; easier on my slow computer
              mu4e-attachment-dir "~/Hämtningar"
              ;; mu4e-change-filenames-when-moving t ;;for mbsync
              mu4e-completing-read-function #'completing-read) ; hands it to helm
  :config (require 'aj-mail-config)
  (mu4e t) ;; start delayed in background
  )
#+END_SRC

*** Fix parse-time-string :ARCHIVE:
Why do I need this? For something with mu4e emailing? I don’t remember. It messes with ~org-read-date-analyze~, which is smarter anyway.

Disable it for now.
#+BEGIN_SRC emacs-lisp
(declare-function parse-iso8601-time-string "parse-time" (str)) ; make byte-compiler happy

(defun aj/parse-time-string (oldfun &rest r)
  "Filter `parse-time-string' to additionally try parsing iso8601 strings"
  (let ((ptret (apply oldfun r)))
    (when (cl-every #'null ptret)
      (if-let ((ip (ignore-errors (parse-iso8601-time-string (car r)))))
          (decode-time ip)
        ptret))))

(advice-add 'parse-time-string :around #'aj/parse-time-string)
#+END_SRC
** Elfeed (feed-reader)
#+BEGIN_SRC emacs-lisp
(use-package elfeed
  :bind ("C-x y" . elfeed)
  :config (add-hook 'elfeed-show-mode-hook #'visual-line-mode))

;;just the split-pane part extracted from the elfeed-goodies package
;; (use-package elfeed-goodies-split-pane
;;   :straight (elfeed-goodies-split-pane
;;              :host github
;;              :repo "algernon/elfeed-goodies"
;;              :files ("elfeed-goodies-split-pane.el"))
;;   :after elfeed
;;   :demand t
;;   :bind (:map elfeed-show-mode-map
;;               ("n" . elfeed-goodies/split-show-next)
;;               ("p" . elfeed-goodies/split-show-prev))
;;   :config
;;   (setq elfeed-goodies/entry-pane-size 0.5
;;         elfeed-show-entry-switch #'elfeed-goodies/switch-pane
;;         elfeed-show-entry-delete #'elfeed-goodies/delete-pane))

#+END_SRC
** TODO Unfixed dependencies
#+BEGIN_SRC emacs-lisp
(use-package dash-functional)
#+END_SRC

** News :ARCHIVE:
#+BEGIN_SRC emacs-lisp
(setq gnus-select-method '(nntp "news.gmane.org"))
#+END_SRC
** Filetypes etc
*** Don’t warn about large pdfs
Patch ~abort-if-file-too-large~ to not complain about pdfs (which are generally handled well by pdf-tools no matter the size).
#+begin_src emacs-lisp
(el-patch-feature files)
(with-eval-after-load 'files
  (el-patch-defun abort-if-file-too-large (size op-type filename &optional offer-raw)
    "If file SIZE larger than `large-file-warning-threshold', allow user to abort.
OP-TYPE specifies the file operation being performed (for message
to user).  If OFFER-RAW is true, give user the additional option
to open the file literally.  If the user chooses this option,
`abort-if-file-too-large' returns the symbol `raw'.  Otherwise,
it returns nil or exits non-locally."
    (let ((choice (and large-file-warning-threshold size
	                   (> size large-file-warning-threshold)
                       ;; No point in warning if we can't read it.
                       (file-readable-p filename)
                       (el-patch-add (not (string= "pdf" (file-name-extension filename))))
                       (files--ask-user-about-large-file
                        size op-type filename offer-raw))))
      (when (eq choice 'abort)
        (user-error "Aborted"))
      choice)))
#+end_src

*** Add pdfbz2 and pdfgz filetypes and decompress correctly
I need this for adding files with .pdfbz2 or .pdfgz suffixes to Zotero with Zotfile, which can't handle double suffixes like .pdf.bz2.

But why do I need to compress pdf-files this way? Shouldn’t pdf-files have reasonable compression?
#+BEGIN_SRC emacs-lisp
(dolist (var '("\\.pdfbz2\\'" "\\.pdfgz\\'"))
  (add-to-list 'auto-mode-alist (cons var 'pdf-view-mode)))
(add-to-list 'jka-compr-compression-info-list
             ["\\.pdfbz2\\'" "bzip2ing" "bzip2" nil "bunzip2ing" "bzip2"
              ("-d")
              nil t "BZh"])
(add-to-list 'jka-compr-compression-info-list
             ["\\.pdfgz\\'" "compressing" "gzip"
              ("-c" "-q")
              "uncompressing" "gzip"
              ("-c" "-q" "-d")
              t t "\213"])
(jka-compr-update)
#+END_SRC

** File management
*** Dired
**** Some settings
#+begin_src emacs-lisp
(setq dired-recursive-deletes 'always
      dired-recursive-copies 'always
      dired-dwim-target t)
#+end_src
**** dired: use ~hl-line-mode~ and hide cursor
But show cursor in ~wdired-mode~
#+begin_src emacs-lisp
(add-hook 'dired-mode-hook #'hl-line-mode)

(defun aj/dired-no-cursor ()
  (setq cursor-type nil))

(add-hook 'dired-mode-hook #'aj/dired-no-cursor)

(defun aj/reset-cursor ()
  (kill-local-variable 'cursor-type))

(add-hook 'wdired-mode-hook #'aj/reset-cursor)

(advice-add 'wdired-change-to-dired-mode :after #'aj/dired-no-cursor)
#+end_src
**** dired-git-info
#+begin_src emacs-lisp
(use-package dired-git-info
    :bind (:map dired-mode-map
                (")" . dired-git-info-mode)))
#+end_src
**** Dired collapse
#+BEGIN_SRC emacs-lisp
(use-package dired-collapse
  ;; :after dired
  :defer t
  :init (add-hook 'dired-mode-hook #'dired-collapse-mode))
#+END_SRC
**** dired-hide-dotfiles
#+BEGIN_SRC emacs-lisp
(use-package dired-hide-dotfiles
  :bind (:map dired-mode-map
              ("å" . dired-hide-dotfiles)))
#+END_SRC
**** Dired subtree
#+BEGIN_SRC emacs-lisp
(use-package dired-subtree
  :defer t
  :after dired
  :config (setq dired-subtree-use-backgrounds nil)
  (bind-keys :map dired-mode-map
             ("TAB" . dired-subtree-cycle)))
#+END_SRC
**** Dired-narrow
#+BEGIN_SRC emacs-lisp
(use-package dired-narrow
  :commands dired-narrow)
#+END_SRC

**** Dired-du
#+BEGIN_SRC emacs-lisp
(use-package dired-du
  :defer t
  :config (validate-setq dired-du-size-format t
                         dired-du-update-headers t))
#+END_SRC

**** COMMENT Extract archives from dired
A simple command to run ~file-roller -h~ for extracting archives in current directory
#+begin_src emacs-lisp
(defun aj/dired-extract-archive-here (&optional arg)
  (interactive "P")
  ;; (dolist (f (dired-map-over-marks
  ;;             (cons (dired-get-filename) (point)) arg))
  ;;   (call-process "file-roller" nil nil nil "-h" f))
  )
#+end_src

**** Dired-ranger :ARCHIVE:
#+BEGIN_SRC emacs-lisp
(use-package dired-ranger
  :commands dired-ranger)
#+END_SRC

**** Sorting and listing-switches (dired-quick-sort)
https://gitlab.com/xuhdev/dired-quick-sort/
But also my branch for persistent per-directory options.
https://gitlab.com/andersjohansson/dired-quick-sort/tree/dir-save
(including some other unmerged fixes).
#+begin_src emacs-lisp
(setq dired-listing-switches "-lhA")
(use-package dired-quick-sort
  :straight nil ; TODO fork
  :load-path "~/kodat/elisp/dired-quick-sort"
  :after dired
  :custom
  (dired-quick-sort-use-per-directory-options t)
  (dired-quick-sort-default-options '("version" ?n ?y "default"))
  (dired-quick-sort-key "s")
  :config
  (dired-quick-sort-setup))
#+end_src

But some of the options for listing-switches doesn’t work with remote sessions in tramp. Avoid this!
#+begin_src emacs-lisp
(add-hook 'dired-before-readin-hook #'aj/dired-no-remote-lsv)

(defun aj/dired-no-remote-lsv ()
  (when (file-remote-p default-directory)
    (setq-local
     dired-listing-switches "-al")
    (setq-local
     dired-actual-switches "-al")))
#+end_src

**** dired-toggle-sudo
#+begin_src emacs-lisp
(use-package dired-toggle-sudo
  :commands dired-toggle-sudo
  :init
  (with-eval-after-load 'dired
    (bind-key "C-c C-s" 'dired-toggle-sudo dired-mode-map)))
#+end_src

**** Dired-recent
Store visited directories in a list, make it accessible from helm
#+BEGIN_SRC emacs-lisp
(use-package dired-recent
  :after (:all dired)
  :config
  (dired-recent-mode 1)
  (setq dired-recent-mode-map nil)
  (with-eval-after-load "helm-for-files"
    (defun aj/remove-dired-recent-dir (_c)
      ;; to be run from helm
      (cl-loop for c in (helm-marked-candidates)
               do (setq dired-recent-directories (delete c dired-recent-directories))))

    (defclass aj/helm-dired-recent-source (helm-source-sync helm-type-file)
      ((candidates :initform (lambda () dired-recent-directories))
       (pattern-transformer :initform 'helm-recentf-pattern-transformer)
       (match-part :initform (lambda (candidate)
                               (if (or helm-ff-transformer-show-only-basename
                                       helm-recentf--basename-flag)
                                   (helm-basename candidate) candidate)))
       (fuzzy-match :initform t)))


    ;; FIX: should be able to use helm-add-action-to-source
    (defmethod helm--setup-source :after ((source aj/helm-dired-recent-source))
      (setf (slot-value source 'action)
            (append (symbol-value (helm-actions-from-type-file))
                    '(("Delete file(s) from aj/favourite-files" .
                       aj/remove-dired-recent-dir))))
      (setf (slot-value source 'filtered-candidate-transformer)
            (append (slot-value source 'filtered-candidate-transformer)
                    '(aj/helm-recentf-filtered-candidates-shorten))))

    (defvar aj/helm-source-dired-recent
      (helm-make-source "Recent directories" 'aj/helm-dired-recent-source))))


#+END_SRC

*** Recentf
#+begin_src emacs-lisp
(use-package recentf
  :demand t
  :init
  :custom
  (recentf-max-menu-items 500)
  (recentf-max-saved-items 500)
  :config
  (defun aj/recentf-exclude (filename)
    (cl-loop for reg in completion-ignored-extensions
             when
             (string-match-p
              (if (equal "$" (substring reg -1))
                  reg
                (concat reg "$"))
              filename)
             return t))

  (recentf-mode 1))
#+end_src

*** Zeitgeist :ARCHIVE:
#+BEGIN_SRC emacs-lisp
(use-package zeitgeist
  :straight nil
  :load-path "~/kodat/elisp/zeitgeist/"
  :demand t)
#+END_SRC
*** Ignore more files for normal completion
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'latex
  (dolist (ext LaTeX-clean-intermediate-suffixes)
    (add-to-list 'completion-ignored-extensions (replace-regexp-in-string "\\\\" "" ext))))
#+END_SRC
*** Always offer to create new directories for ~read-file-name~
Advises ~read-file-name~ to always ask if non-existent directories should be created. Adding a non-existent directory otherwise causes errors in lots of commands calling ~read-file-name~.

This works for instance in ~dired-do-rename~ or ~mu4e-view-save-attachment~ (also with ~helm-mode~ activated).
#+BEGIN_SRC emacs-lisp
(defun aj/create-non-existent-directories (filename)
  (unless (file-exists-p filename)
    (let ((dirname (file-name-directory filename)))
      (when (and (not (file-directory-p dirname))
                 (y-or-n-p (format "Directory %s doesn't exist, create it?" dirname)))
        (make-directory dirname t))))
  filename)

(advice-add 'read-file-name :filter-return #'aj/create-non-existent-directories)
#+END_SRC

*** Make directories as needed (overlap with above?)
#+begin_src emacs-lisp
(defun aj/ff-mkdir ()
  (let ((filename (buffer-file-name)))
	(unless (or (eq nil filename) (file-exists-p filename))
	  (let ((dir (file-name-directory filename)))
		(unless (file-exists-p dir)
		  (make-directory dir t))))))

(add-hook 'find-file-hook 'aj/ff-mkdir)
(add-hook 'before-save-hook 'aj/ff-mkdir)
#+end_src

*** Read-only-directories
Define a dir-locals class and add directories which should by default be read-only there. (most importantly ~straight/build~)
#+begin_src emacs-lisp
(dir-locals-set-class-variables 'read-only-dir '((nil (eval read-only-mode))))

(dir-locals-set-directory-class
 "~/.emacs.d/straight/build/" 'read-only-dir)
#+end_src

** Password-store
Customizations for ~password-store~ and ~pass-mode.~
In particular, I want good completion when generating a password, so, inspired by the directory-completion in ~helm-find-files~, I define a helm source which lists the password directories and allows completion on them.

I also want a function that places the newly generated password in the kill ring: ~aj/password-store-generate-and-copy.~

Last, a few functions to git push, pull and run ~magit~ on the password store.

#+BEGIN_SRC emacs-lisp
(use-package auth-source-pass
  :after auth-source
  :config (auth-source-pass-enable))

(use-package password-store
  :defer t
  :custom (password-store-password-length 47)
  :config

  (defun aj/password-store-generate (oldfun entry &optional password-length _no-symbols)
    (interactive (list (aj/password-store-get-new-entry-with-completion)
                       (when current-prefix-arg
                         (abs (prefix-numeric-value current-prefix-arg)))))
    ;;we get nil when everything is fine, otherwise probably an error
    ;;is signalled
    (unless (apply oldfun entry password-length) entry))

  (advice-add 'password-store-generate :around #'aj/password-store-generate)

  (defun aj/password-store-generate-and-copy ()
    (interactive)
    (password-store-copy
     (call-interactively #'password-store-generate)))

  (defun aj/password-store-generate-and-copy-simpler ()
    (interactive)
    (let ((entry (aj/password-store-get-new-entry-with-completion)))
      (password-store--run-generate entry 19 t t)
      (password-store-copy entry)))

  (defun aj/password-store-generate-and-copy-words (&optional number-of-words)
    (interactive "p")
    (let ((entry (aj/password-store-get-new-entry-with-completion)))
      (password-store-insert entry
                             (aj/password-store-get-random-sv-pass
                              (cl-case number-of-words
                                (1 4)
                                (t number-of-words))))
      (password-store-copy entry)))

  (defun aj/password-store-get-random-sv-pass (&optional num)
    (with-temp-buffer
      (insert-file-contents "/usr/share/hunspell/sv_SE.dic")
      (cl-loop with max = (point-max)
               repeat (or num 4)
               collect (progn
                         (goto-char (random max))
                         (forward-line 0)
                         (when (search-forward-regexp "[^/]+" (point-at-eol))
                           (match-string 0)))
               into words
               finally return
               (mapconcat #'identity words "-"))))

  (defun aj/password-store-get-new-entry-with-completion ()
    (helm
     :prompt: "Password entry:"
     :sources
     (list (helm-build-sync-source "Pass dirs"
             :candidates #'aj/password-store-list-dirs
             :action #'identity
             :persistent-action #'aj/password-helm-complete-persistent)
           (helm-build-dummy-source "Insert"))))

  (defun aj/password-helm-complete-persistent (candidate)
    (with-selected-window (or (active-minibuffer-window)
                              (minibuffer-window))
      (delete-minibuffer-contents)
      (set-text-properties 0 (length candidate)
                           nil candidate)
      (insert candidate)))

  (defun aj/password-store-list-dirs (&optional subdir)
    "List password entries under SUBDIR."
    (unless subdir (setq subdir ""))
    (let ((dir (f-join (password-store-dir) subdir)))
      (when (f-directory-p dir)
        (-reject
         (lambda (d) (string-match-p "\\(/\\.\\|^\\.\\)" d))
         (mapcar (lambda (f) (file-name-as-directory (password-store--file-to-entry f)))
                 (f-directories dir nil t))))))
  )

(use-package pass
  :defer t
  :config
  (bind-keys :map pass-mode-map
             ("P" . aj/pass-git-push)
             ("F" . aj/pass-git-pull)
             ("m" . aj/pass-magit)
             ("W" . aj/password-store-generate-and-copy)
             ("v" . aj/password-store-generate-and-copy-simpler)
             ("V" . aj/password-store-generate-and-copy-words))

  (defun aj/pass-git-push ()
    (interactive)
    (password-store--run-git "push"))
  (defun aj/pass-git-pull ()
    (interactive)
    (password-store--run-git "pull"))
  (defun aj/pass-magit ()
    (interactive)
    (magit-status "~/.password-store"))

  (defun aj/pass-display-header-extra ()
    (pass--display-keybindings
     '((aj/password-store-generate-and-copy . "Gen + copy")
       (aj/password-store-generate-and-copy-simpler . "Gen + copy simpler")
       (aj/password-store-generate-and-copy-words . "Gen + copy words")))
    (insert "\n")
    (pass--display-keybindings '((aj/pass-git-push . "Git push")
                                 (aj/pass-git-pull . "Git pull")
                                 (aj/pass-magit . "Launch magit")))
    (newline)
    (newline))

  (advice-add 'pass-display-header :after #'aj/pass-display-header-extra)
  )





#+END_SRC
** LaTeX
*** Config variables for latex :org_async:
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'tex
  (setq TeX-process-asynchronous t
        TeX-auto-save t
        TeX-parse-self t ;parse on load
        TeX-auto-save t ;parse on save
        TeX-auto-local ".auctex-auto" ; more sensible directory name
        TeX-style-local ".auctex-auto"
        TeX-auto-private '("~/.emacs.d/auctex/.auctex-auto")
        LaTeX-babel-hyphen nil ; Disable language-specific hyphen insertion.
        LaTeX-clean-intermediate-suffixes
        '("\\.aux" "\\.bbl" "\\.blg" "\\.brf" "\\.fot" "\\.glo" "\\.gls" "\\.idx" "\\.ilg" "\\.ind" "\\.lof"  "\\.lot" "\\.nav" "\\.out" "\\.snm" "\\.toc" "\\.url" "\\.synctex\\.gz" "\\.run\\.xml" "\\.bcf" "\\.fdb_latexmk" "\\.upa" "\\.fls" "\\.lox" "\\.log")
        LaTeX-clean-output-suffixes '("\\.dvi" "\\.pdf" "\\.ps" "\\.xdv" "\\.pdfpc")
        LaTeX-csquotes-close-quote "}"
        LaTeX-csquotes-open-quote "\\enquote{"
        TeX-arg-cite-note-p t
        TeX-fold-auto nil
        TeX-fold-macro-spec-list
        '(("[f]"
           ("footnote" "marginpar"))
          ("[n:{1}]"
           ("fxnote" "fxwarning" "fxerror" "fxfatal"))
          ("[nr: {1}]"
           ("fxrnote" "fxrwarning" "fxrerror" "fxrfatal"))
          ("[nri: {1}]"
           ("fxrnoteinline" "fxrwarninginline" "fxrerrorinline" "fxrfatalinline"))
          ("[c]"
           ("cite"))
          ("[l]"
           ("label"))
          ("[r]"
           ("ref" "pageref" "eqref"))
          ("[i]"
           ("index" "glossary"))
          ("[1]:||*"
           ("item"))
          ("…"
           ("dotsppp"))
          ("(C)"
           ("copyright"))
          ("(R)"
           ("textregistered"))
          ("TM"
           ("texttrademark"))
          (1
           ("part" "subparagraph" "part*" "subparagraph*" "emph" "textit" "textsl" "textmd" "textrm" "textsf" "texttt" "textbf" "textsc" "textup"))
          ("C. {1}"
           ("chapter" "chapter*"))
          ("S. {1}"
           ("section" "section*"))
          ("SS. {1}"
           ("subsection" "subsection*"))
          ("SSS. {1}"
           ("subsubsection" "subsubsection*"))
          ("━━━━━━━━━━━━━━━━{1}"
           ("paragraph" "paragraph*"))
          ("({1}:[1])"
           ("autocite" "autocite*"))
          ("[A: {1}]"
           ("citeauthor" "citeauthor*"))
          ("[T: {1}]"
           ("citetitle" "citetitle*"))
          ((lambda
             (&rest ci)
             (setq ret nil)
             (concat "("
                     (substring
                      (dolist
                          (cc ci ret)
                        (setq ret
                              (concat ret cc ", ")))
                      0 -2)
                     ")"))
           ("autocites" "autocites*"))
          ("»{2}«"
           ("foreigntextquote" "foreignquote"))
          ("»{1}«"
           ("textquote" "enquote"))
          ("―»{3}« ({2}:[1])―"
           ("foreignblockcquote"))
          ("»{3}« ({2}:[1])[2]"
           ("foreigntextcquote"))
          ("―»{2}« ({1}:[1])―"
           ("blockcquote"))
          ("»{2}« ({1}:[1])[2]"
           ("textcquote"))
          ("[…][{1}]||[…]"
           ("textelp"))
          ("[{1}][…]||[…]"
           ("textelp*"))
          ("[{1}]"
           ("textins" "textins*"))
          ("{2}"
           ("foreignlanguage")))
        TeX-macro-private '("~/texmf/tex/" "~/texmf/bibtex/bst/" "~/.texmf-config/tex/")
        TeX-modes '(texinfo-mode latex-mode doctex-mode)
        TeX-quote-language-alist '(("swedish" "\\enquote{" "}" nil))
        TeX-style-private '("~/.emacs.d/auctex/.auctex-style")
        bibtex-dialect 'biblatex
        cdlatex-command-alist
        '(("bra" "Insert bra, place point inside" "\\bra{?}" cdlatex-position-cursor nil nil t)
          ("ket" "Insert ket, place point inside" "\\ket{?}" cdlatex-position-cursor nil nil t)
          ("braket" "Insert bracket, point inside" "\\braket{?}" cdlatex-position-cursor nil nil t))
        cdlatex-math-symbol-alist '((43 ("\\cup" "\\dagger")))
        flyspell-tex-command-regexp
        "\\(\\(begin\\|end\\)[ 	]*{\\|\\(cite[a-z*]*\\|label\\|ref\\|eqref\\|input\\|usepackage\\|documentclass\\)[ 	]*\\(\\[[^]]*\\]\\)?{[^{}]*\\)"
        font-latex-math-environments
        '("display" "displaymath" "equation" "eqnarray" "gather" "multline" "align" "alignat" "xalignat" "dmath")
        font-latex-user-keyword-classes
        '(("fxnote"
           (("fxnote" "[{")
            ("fxrnote" "{"))
           font-lock-comment-face command)
          ("fxwarningerrorfatal"
           (("fxfatal" "[{")
            ("fxerror" "[{")
            ("fxwarning" "[{")
            ("fxrfatal" "{")
            ("fxrerror" "{")
            ("fxrwarning" "{"))
           font-latex-warning-face command)
          ("autocites"
           (("autocites" "[[{[[{")
            ("autocites" "[[{[[{[[{")
            ("autocites" "[[{[[{[[{[[{")
            ("autocites" "[[{[[{[[{[[{[[{"))
           font-lock-constant-face command))
        reftex-bibliography-commands '("bibliography" "nobibliography" "addbibresource")))

(setq-default TeX-master 'dwim
              TeX-PDF-mode t) ;PDF by default


;; replacing \\par with a non-displaying character is just stupid
(with-eval-after-load "tex-mode"
  (setq tex--prettify-symbols-alist (delete '("\\par" . ? 
) tex--prettify-symbols-alist)))
#+END_SRC

*** Use pdf-tools
#+BEGIN_SRC emacs-lisp
(defun th/pdf-view-revert-buffer-maybe (file)
  (when-let ((buf (find-buffer-visiting file)))
    (with-current-buffer buf
      (when (derived-mode-p 'pdf-view-mode)
        (pdf-view-revert-buffer t t)))))

(with-eval-after-load 'tex-buf
  ;; only care about pdf
  (setq TeX-view-program-selection '((output-pdf "PDF Tools")))
  (add-hook 'TeX-after-compilation-finished-functions
            #'th/pdf-view-revert-buffer-maybe))


;; (with-eval-after-load 'pdf-sync
;;   (defun aj/locate-synctex-file (pdffile)
;;     (let ((default-directory
;;             (concat (file-name-directory pdffile) "/.tex-aux"))
;;           (basename (file-name-sans-extension
;;                      (file-name-nondirectory pdffile))))
;;       (cl-labels ((file-if-exists-p (file)
;;                                     (and (file-exists-p file)
;;                                          file)))
;;         (or (file-if-exists-p
;;              (expand-file-name (concat basename ".synctex.gz")))
;;             (file-if-exists-p
;;              (expand-file-name (concat basename ".synctex")))
;;             ;; Some pdftex quote the basename.
;;             (file-if-exists-p
;;              (expand-file-name (concat "\"" basename "\"" ".synctex.gz")))
;;             (file-if-exists-p
;;              (expand-file-name (concat "\"" basename "\"" ".synctex")))))))

;;   (add-hook 'pdf-sync-locate-synctex-file-functions #'aj/locate-synctex-file))
#+END_SRC
*** Open pdf in emacsclient in async mode :org_async:no_default_tangle:
DONE?:
skriva wrapper/alternativ funktion till TeX-pdf-tools-sync-view, som tar ett filnamn och sedan binder den så att TeX-pdf-tools-sync-view ser den, alt gör motsvarande saker. Denna funktion ska köras i normala emacsclient.

Filnamnet måste skickas med till "processen" emacsclient, hur inline en emacsvariabel i ett emacs-process-call?

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'tex
  (setq TeX-view-program-list
        '(("emacsclient pdft"
           "emacsclient -e \"(progn (pop-to-buffer (or (find-buffer-visiting \\\"%o\\\") (find-file-noselect \\\"%o\\\"))) (revert-buffer) (alert \\\"Latexmk klar\\\" :title \\\"Org export latexmk\\\" :style 'libnotify))\"")))
  (setq TeX-view-program-selection '((output-pdf "emacsclient pdft"))))
#+END_SRC

*** Extra latex bindings
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'latex
  (bind-keys
   :map LaTeX-mode-map
   ("C-c ä" . TeX-next-error)
   ("C-c w" . latex-word-count)
   ("C-<f1>" . TeX-doc)
   ("C-c C-a" . TeX-command-two-paragraphs)))
#+END_SRC

*** Extra latex commands
**** latex word count
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'latex
  (defun latex-word-count (&optional arg)
    (interactive "P")
    (let*
        ((this-file (buffer-file-name))
         (this-dir default-directory)
         (enc-str (symbol-name buffer-file-coding-system))
         (enc-opt
          (cond
           ((string-match "utf-8" enc-str) "-utf8")
           ((string-match "latin" enc-str) "-latin1")
           ("-encoding=guess")
           )))
      (if arg
          ;; (shell-command (concat "texcount" " -inc" " -v2 " "-opt=$HOME/.texcount "
          ;;                         enc-opt " \"" this-file
          ;; "\""))
          (let ((tcb (generate-new-buffer "*texcount*")))
            (call-process "texcount" nil tcb nil "-inc"
                          "-v2 " (concat "-opt=" (getenv "HOME") "/.texcount") enc-opt this-file)
            (pop-to-buffer tcb)
            (ansi-color-apply-on-region (point-min) (point-max)))
        (message
         (with-output-to-string
           (with-current-buffer standard-output
             (cd this-dir) ;för att inkluderade filer ska läsas rätt
             (call-process "texcount" nil t nil "-total" "-0" "-inc"
                           "-opt=~/.texcount" enc-opt this-file))))))))
#+END_SRC

**** tex-command-two-paragraphs
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'latex
  (defun TeX-command-two-paragraphs ()
    "Mark two sentences backward and run TeX-command-region, useful for exporting the latest text"
    (interactive)
    (save-excursion
      (mark-paragraph -2)
      (TeX-command-region))))
#+END_SRC

*** Extra modes to enable for latex-mode
#+BEGIN_SRC emacs-lisp
(dolist (mode '(turn-on-reftex
                ;; latex-extra-mode
                TeX-fold-mode))
  (add-hook 'LaTeX-mode-hook mode))
#+END_SRC

*** Latexmk-command for normal export
#+BEGIN_SRC emacs-lisp
(declare-function TeX-run-TeX "tex-buf")
(with-eval-after-load 'tex-buf
  (defun aj/TeX-run-latexmk (name command file)
    (interactive)
    (let ((TeX-save-query nil))
      (TeX-save-document "")
      (TeX-run-TeX name command file)))

  (setq TeX-error-overview-open-after-TeX-run t))
#+END_SRC
*** Latexmk-commands for org-async export :org_async:no_default_tangle:
#+BEGIN_SRC emacs-lisp
(declare-function TeX-run-TeX "tex-buf") (defvar TeX-command-buffer nil)
(with-eval-after-load 'tex-buf
  (defun aj/TeX-run-latexmk (name command file)
    (interactive)
    (let ((TeX-save-query nil)
          (TeX-process-asynchronous nil))
      (TeX-save-document "")
      (TeX-run-TeX name command file)
      (with-current-buffer TeX-command-buffer (TeX-view)))))
#+END_SRC
*** Customize Tex-commands :org_async:
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'tex-buf
  (setq LaTeX-command-style '(("" "%(PDF)%(latex) -file-line-error %(extraopts) %S%(PDFout)")))

  (add-to-list 'TeX-command-list '("LaTeX shell-escape" "%`%l --shell-escape %(mode)%' %t" TeX-run-TeX t (latex-mode doctex-mode)))
  (add-to-list 'TeX-command-list '("Nomenclature" "makeindex %s.nlo -s nomencl.ist -o %s.nls" TeX-run-command t t))
  (add-to-list 'TeX-command-list '("cleanmk" "latexmk -c -g -pdf -e '$pdflatex=~s/pdflatex %%O %%S/%l%(mode) %%O %%S/' %s" TeX-run-discard nil t :help "Clean with latexk"))
  (add-to-list 'TeX-command-list '("xelatexmk" "latexmk -g -recorder -xelatex -pv %s" aj/TeX-run-latexmk nil nil :help "Run XeLatexmk on file"))
  (add-to-list 'TeX-command-list '("latexmk" "latexmk -g -pdf -e '$pdflatex=~s/pdflatex %%O %%S/%l%(mode) %%O %%S/' %s" aj/TeX-run-latexmk nil t :help "Run Latexmk on file")))

(setq-default TeX-command-default "latexmk")
#+END_SRC
*** Reftex
Add biblatex formats
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'reftex-vars
  (setq reftex-cite-prompt-optional-args t
        reftex-plug-into-AUCTeX t
        reftex-cite-format
        '((?a . "\\autocite[]{%l}")
          (?\C-a . "\\autocite*[]{%l}")
          (?A . "\\autocites[]{%l}")
          (?t . "\\textcite[]{%l}")
          (?u . "\\citeauthor[]{%l}")
          (?\C-u . "\\citeauthor*{%l}")
          (?\C-t . "\\citetitle[]{%l}")
          (?l . "%l")
          (?\C-l . "[]{%l}") ;for adding more references in an autocites
          (?\C-m . "\\cite[]{%l}")
          (?f . "\\footcite[]{%l}")
          (?p . "\\parencite[]{%l}")
          (?\C-y . "\\citeyear[]{%l}")
          (?n . "\\nocite{%l}"))))
#+END_SRC
*** Tex-fold linebreaks
https://github.com/andersjohansson/tex-fold-linebreaks
#+BEGIN_SRC emacs-lisp
(use-package tex-fold-linebreaks
  :straight (:host gitlab :repo "andersjohansson/tex-fold-linebreaks")
  :commands tex-fold-linebreaks-mode
  :config (setq tex-fold-linebreaks-non-sentence-punctuation-regexp
                "\\([0-9]\\|[[:space:]]\\([[:alpha:]]\\|t\\.ex\\|m\\.fl\\|bl\\|bl\\.a\\|e\\.g\\|i\\.e\\)?\\)$"))
#+END_SRC
** Window management and navigation
*** beginend (redefine beginning and end of buffer in a smart way for special buffers)
#+BEGIN_SRC emacs-lisp
(use-package beginend
  :init (beginend-setup-all))
#+END_SRC
*** Buffer flip :ARCHIVE:
#+begin_src emacs-lisp
(use-package buffer-flip
  :bind ("C-<tab>" . #'buffer-flip)
  :init
  ;; transient keymap used once cycling starts
  (setq buffer-flip-map
        (let ((map (make-sparse-keymap)))
          (define-key map (kbd "C-<tab>")   'buffer-flip-forward)
          (define-key map (kbd "C-S-<iso-lefttab>") 'buffer-flip-backward)
          (define-key map (kbd "ESC")     'buffer-flip-abort)
          map))
  (setq buffer-flip-skip-patterns helm-boring-buffer-regexp-list)
  (with-eval-after-load "org-keys"
    (bind-key "C-<tab>" nil org-mode-map)))
#+end_src
*** Med iflipb? :ARCHIVE:
#+begin_src emacs-lisp
(setq iflipb-wrap-around t)
(setq iflipb-ignore-buffers helm-boring-buffer-regexp-list)

(bind-key "C-§" #'iflipb-previous-buffer)
(bind-key "C-½" #'iflipb-next-buffer)


(defun aj/switch-to-other-buffer ()
  (interactive)
  (iflipb-next-buffer nil)
  (aj/cycle-buffers/body))

(bind-key "C-x C-b" #'aj/switch-to-other-buffer)

(defhydra aj/cycle-buffers (:color red)
  "Cycle buffers"
  ("n" #'iflipb-next-buffer "Next buffer")
  ("b" #'iflipb-previous-buffer "Previous buffer")
  ("q" nil "Quit"))

(setq iflipb-wrap-around t)
#+end_src
*** Flip buffers with nswbuff :ARCHIVE:
#+begin_src emacs-lisp
(use-package nswbuff)

(setq nswbuff-exclude-buffer-regexps helm-boring-buffer-regexp-list
      nswbuff-start-with-current-centered t
      nswbuff-display-intermediate-buffers t
      nswbuff-status-window-layout 'scroll)

(set-face-attribute 'nswbuff-special-buffers-face nil :foreground nil :inherit 'shadow)
(set-face-attribute 'nswbuff-current-buffer-face nil :foreground nil)
(set-face-attribute 'nswbuff-separator-face nil :foreground nil :inherit 'shadow)


(defun aj/switch-to-other-buffer ()
  (interactive)
  (nswbuff-switch-to-next-buffer)
  (aj/cycle-buffers/body))

(bind-key "C-x C-b" #'aj/switch-to-other-buffer)

(defhydra aj/cycle-buffers (:color red)
  "Cycle buffers"
  ("n" #'nswbuff-switch-to-previous-buffer "Previous buffer")
  ("b" #'nswbuff-switch-to-next-buffer "Next buffer")
  ("q" nil "Quit"))
#+end_src
*** aj/switch-to-buffer
#+BEGIN_SRC emacs-lisp
(defun aj/switch-to-other-buffer ()
  (interactive)
  (switch-to-buffer nil)
  (aj/cycle-buffers/body))

(bind-key "C-x C-b" #'aj/switch-to-other-buffer)

(defhydra aj/cycle-buffers (:color red)
  "Cycle buffers"
  ("n" #'next-buffer "Next buffer")
  ("b" #'previous-buffer "Previous buffer")
  ("q" nil "Quit"))
#+END_SRC
*** Eyebrowse :ARCHIVE:
#+BEGIN_SRC emacs-lisp
(use-package eyebrowse
  :init (setq eyebrowse-keymap-prefix (kbd "C-c C-å"))
  (eyebrowse-mode t))
#+END_SRC

*** Window management variables
#+BEGIN_SRC emacs-lisp
(setq split-width-threshold 140)
#+END_SRC

*** Window management hydra
#+BEGIN_SRC emacs-lisp
(bind-key "C-§" #'hydra-window/body)

(defhydra hydra-window (:hint nil)
  "
Split^^            ^Switch^       ^Resize^
_2_ vertical       _r_otate CW    _<left>_ ←
_3_ horizontal     _R_otate CCW   _<down>_ ↓
_1_ only this      _t_ranspose    _<up>_ ↑
_0_ delete                      _<right>_ →
_z_ undo                        _=_ balance
_Z_ redo
_F_ollow _q_ cancel
"
  ("<left>" aj/hydra-move-splitter-left)
  ("<down>" aj/hydra-move-splitter-down)
  ("<up>" aj/hydra-move-splitter-up)
  ("<right>" aj/hydra-move-splitter-right)
  ("=" balance-windows)
  ("2" split-window-below)
  ("3" split-window-right)
  ("r" rotate-frame-clockwise)
  ("R" rotate-frame-anti-clockwise)
  ("t" transpose-frame)
  ("F" follow-mode)
  ("0" delete-window)
  ("1" delete-other-windows)
  ("z" (progn
         (winner-undo)
         (setq this-command 'winner-undo)))
  ("Z" winner-redo)
  ("q" nil))

(winner-mode)

(use-package windmove
  :commands windmove-find-other-window)

(defun aj/hydra-move-splitter-left (arg)
  "Move window splitter left."
  (interactive "p")
  (if (let ((windmove-wrap-around))
        (windmove-find-other-window 'right))
      (shrink-window-horizontally arg)
    (enlarge-window-horizontally arg)))

(defun aj/hydra-move-splitter-right (arg)
  "Move window splitter right."
  (interactive "p")
  (if (let ((windmove-wrap-around))
        (windmove-find-other-window 'right))
      (enlarge-window-horizontally arg)
    (shrink-window-horizontally arg)))

(defun aj/hydra-move-splitter-up (arg)
  "Move window splitter up."
  (interactive "p")
  (if (let ((windmove-wrap-around))
        (windmove-find-other-window 'up))
      (enlarge-window arg)
    (shrink-window arg)))

(defun aj/hydra-move-splitter-down (arg)
  "Move window splitter down."
  (interactive "p")
  (if (let ((windmove-wrap-around))
        (windmove-find-other-window 'up))
      (shrink-window arg)
    (enlarge-window arg)))
#+END_SRC
*** Transpose-frame
#+BEGIN_SRC emacs-lisp
  (use-package transpose-frame
    :commands (transpose-frame flip-frame flop-frame rotate-frame
                              rotate-frame-clockwise rotate-frame-anti-clockwise))
#+END_SRC
*** swap window buffers by drag and drop
#+BEGIN_SRC emacs-lisp
(defun th/swap-window-buffers-by-dnd (drag-event)
  "Swaps the buffers displayed in the DRAG-EVENT's start and end
window."
  (interactive "e")
  (let ((start-win (cl-caadr drag-event))
        (end-win   (cl-caaddr drag-event)))
    (when (and (windowp start-win)
               (windowp end-win)
               (not (eq start-win end-win))
               (not (memq (minibuffer-window)
                          (list start-win end-win))))
      (let ((bs (window-buffer start-win))
            (be (window-buffer end-win)))
        (unless (eq bs be)
          (set-window-buffer start-win be)
          (set-window-buffer end-win bs))))))

(bind-key "<C-S-drag-mouse-1>" #'th/swap-window-buffers-by-dnd)
#+END_SRC
*** Narrowing
Do everything with ~C-x n~.
http://endlessparentheses.com/emacs-narrow-or-widen-dwim.html
#+BEGIN_SRC emacs-lisp
(put 'narrow-to-region 'disabled nil)

(defun aj/narrow-or-widen-dwim (p)
  "Widen if buffer is narrowed, narrow-dwim otherwise.
Dwim means: region, org-src-block, org-subtree, or defun,
whichever applies first. Narrowing to org-src-block actually
calls `org-edit-src-code'.

With prefix P, don't widen, just narrow even if buffer is
already narrowed."
  (interactive "P")
  (declare (interactive-only))
  (cond ((and (buffer-narrowed-p) (not p)) (widen))
        ((and (boundp 'org-src-mode) org-src-mode (not p))
         (org-edit-src-exit)) ;leave org-src, we don’t narrow
                                        ;automatically there
        ((region-active-p)
         (narrow-to-region (region-beginning) (region-end)))
        ((derived-mode-p 'org-mode)
         ;; `org-edit-src-code' is not a real narrowing command.
         ;; Remove this first conditional if you don't want it.
         (cond ((ignore-errors (org-edit-src-code))
                t)
               ;; (delete-other-windows))
               ((ignore-errors (org-narrow-to-block) t))
               (t (org-narrow-to-subtree))))
        (t (narrow-to-defun))))

(define-key ctl-x-map "n" #'aj/narrow-or-widen-dwim)
(with-eval-after-load 'org-keys
  ;; override three separate C-x n * bindings
  (bind-keys :map org-mode-map
             ("C-x n s" . nil)
             ("C-x n b" . nil)
             ("C-x n e" . nil)
             ("C-x n" . aj/narrow-or-widen-dwim)))
;; (unbind-key "C-x n" org-mode-map)

;; For leaving org-src-edit, use C-c C-c, like magit-commit etc.
(with-eval-after-load 'org-src
  (define-key org-src-mode-map "\C-c\C-c" #'org-edit-src-exit))

(defun aj/narrow-clone ()
  (interactive)
  (unless (and (boundp 'org-src-mode) org-src-mode)
    (if-let ((bb (buffer-base-buffer)))
        (progn
          (kill-buffer)
          (pop-to-buffer bb))
      (clone-indirect-buffer nil t)
      (aj/narrow-or-widen-dwim nil))))

(define-key ctl-x-map "N" #'aj/narrow-clone)
#+END_SRC

** Searching, file-management, completion (helm and others)
*** Smarter default search with char-folding
#+begin_src emacs-lisp
(setq search-default-mode #'char-fold-to-regexp)
#+end_src

*** Anzu: Shows number of search matches in modeline, replacements inline etc.
#+BEGIN_SRC emacs-lisp
(use-package anzu
  :defer 12
  :bind (("M-%" . anzu-query-replace)
         ("C-M-%" . anzu-query-replace-regexp))
  :config
  (progn
    (global-anzu-mode +1)
    (dolist (f '((anzu-mode-line . font-lock-variable-name-face)
                 (anzu-replace-to . match)
                 (anzu-match-1 . font-lock-constant-face)
                 (anzu-match-2 . font-lock-keyword-face)
                 (anzu-match-3 . font-lock-type-face)))
      (set-face-attribute (car f) nil :foreground 'unspecified :background 'unspecified
                          :inherit (cdr f)))))

#+END_SRC

*** Company
#+BEGIN_SRC emacs-lisp
(use-package company
  :defer 3
  :custom (company-idle-delay 1)
  :config (global-company-mode))

(use-package company-emoji
  :after company
  :config (add-to-list 'company-backends 'company-emoji))

;; see https://github.com/sebastiencs/company-box/pull/65
(use-package company-box
  :straight (company-box :no-byte-compile t :depth 500 :host github :repo "andersjohansson/company-box" :branch "only-expand-width")
  :after company
  :hook (company-mode . company-box-mode)
  :init (setq company-box-enable-icon nil
              company-box-scrollbar 'default))
#+END_SRC

*** COMMENT yasnippet
#+begin_src emacs-lisp
(use-package yasnippet
  :defer 6
  :config
  (yas-global-mode 1) ;välja specifika?
  (define-key yas-minor-mode-map (kbd "<tab>") nil)
  (define-key yas-minor-mode-map (kbd "TAB") nil)
  (add-hook 'yas-before-expand-snippet-hook (lambda () (smartparens-mode -1)))
  (add-hook 'yas-after-exit-snippet-hook (lambda () (smartparens-mode 1))))
#+end_src

*** Hippie expand
#+BEGIN_SRC emacs-lisp
(bind-key "C-å" #'hippie-expand)

;;some kind of default
(setq hippie-expand-try-functions-list
      '(;; yas-hippie-try-expand
        try-complete-file-name
        try-expand-all-abbrevs
        try-expand-dabbrev
        try-expand-dabbrev-all-buffers
        try-expand-dabbrev-from-kill
        try-complete-lisp-symbol-partially
        try-complete-lisp-symbol
        ;; ispell-complete-word
        try-complete-file-name-partially))

(add-hook 'text-mode-hook #'aj/hippie-expand-for-text-mode)
(add-hook 'prog-mode-hook #'aj/hippie-expand-for-prog-mode)
(add-hook 'emacs-lisp-mode-hook #'aj/hippie-expand-for-elisp)

(defun aj/hippie-expand-for-text-mode ()
  (setq-local hippie-expand-try-functions-list
              '(;; yas-hippie-try-expand
                try-expand-all-abbrevs
                try-expand-dabbrev
                try-expand-dabbrev-all-buffers
                try-expand-dabbrev-from-kill
                ;; ispell-complete-word
                try-complete-file-name
                try-complete-file-name-partially
                ;; try-complete-lisp-symbol-partially
                ;; try-complete-lisp-symbol
                )))

(defun aj/hippie-expand-for-prog-mode ()
  (setq-local hippie-expand-try-functions-list
              '(;; yas-hippie-try-expand
                try-complete-file-name
                try-expand-all-abbrevs
                try-expand-list
                try-expand-line
                try-complete-lisp-symbol-partially
                try-complete-lisp-symbol
                try-expand-dabbrev
                try-expand-dabbrev-all-buffers
                try-expand-dabbrev-from-kill
                try-complete-file-name-partially)))

(defun aj/hippie-expand-for-elisp ()
  (setq-local hippie-expand-try-functions-list
              '(;; yas-hippie-try-expand
                try-complete-lisp-symbol-partially
                try-complete-lisp-symbol
                try-complete-file-name
                try-complete-file-name-partially
                try-expand-all-abbrevs
                try-expand-dabbrev
                try-expand-dabbrev-all-buffers
                try-expand-dabbrev-from-kill
                try-expand-list
                try-expand-line)))
#+END_SRC

** info+ :ARCHIVE:
#+begin_src emacs-lisp
(use-package info+
  ;; :after info
  :defer t
  :config
  (define-key Info-mode-map [mouse-4] nil)
  (define-key Info-mode-map [mouse-5] nil))
#+end_src

** TODO undo-tree
Maybe use: https://github.com/emacsorphanage/undo-tree
#+begin_src emacs-lisp
(use-package undo-tree
  :defer 3
  :bind (("C-z" . undo-tree-undo) ("S-C-z" . undo-tree-redo))
  :config (global-undo-tree-mode)
  (setq undo-tree-auto-save-history nil
        undo-tree-visualizer-timestamps t
        undo-tree-visualizer-diff t)
  (defun aj/undo-tree-compress (filename)
    (concat filename ".gz"))
  (advice-add 'undo-tree-make-history-save-file-name :filter-return
              #'aj/undo-tree-compress))
#+end_src

** Version control, git and magit
*** Magit config
#+begin_src emacs-lisp
(use-package magit
  ;; :pin melpa-stable
  :bind ("C-x g" . magit-status)
  :config
  (magit-auto-revert-mode -1) ;; I use global-auto-revert
  (setq magit-diff-refine-hunk t
        magit-bury-buffer-function #'magit-mode-quit-window)

  (add-hook 'git-commit-setup-hook #'git-commit-turn-on-flyspell)
  (add-hook 'git-commit-setup-hook
            (lambda () (setq fill-column 70)
              (ispell-change-dictionary "en_GB,sv_SE"))
            t))
#+end_src
*** magit-todos
#+begin_src emacs-lisp
(use-package magit-todos
  :after magit
  :commands magit-todos-mode
  :config (magit-todos-mode t))
#+end_src
*** Display tracked files
Sometimes I want to see what is tracked in a repository.
Define this as a global minor mode which adds a section in the magit status buffer (global because it seemed buggy to modify local value of ~magit-status-sections-hook~).  Inspired by magit-todos mode definition.

~j t~ (default magit binding) jumps to the section of tracked files.
#+begin_src emacs-lisp
(define-minor-mode magit-tracked-files-mode
  "Show list of tracked files in magit status buffer"
  nil
  :global t
  (if magit-tracked-files-mode
      (magit-add-section-hook 'magit-status-sections-hook
                              #'magit-insert-tracked-files
                              nil
                              'append)
    (remove-hook 'magit-status-sections-hook #'magit-insert-tracked-files))
  (magit-refresh))
#+end_src
*** forge
#+begin_src emacs-lisp
(use-package forge
  :after magit)
#+end_src
*** Use visual-line-mode in magit for repositories with mostly prose text
This can be enabled with a local variable ~aj/magit-visual-line-mode~ (set it as dir-local) or automatically if all the checked in files are org- or text-mode-based.
#+BEGIN_SRC emacs-lisp
(defvar-local aj/magit-visual-line-mode nil
  "Enable visual-line-mode for magit if non-nil.
Set to symbol ‘disable’ to prevent activation of visual-line-mode.")
(put 'aj/magit-visual-line-mode 'safe-local-variable #'booleanp)

(add-hook 'magit-mode-hook #'aj/magit-maybe-enable-visual-line-mode)
(defun aj/magit-maybe-enable-visual-line-mode ()
  "Enables ‘visual-line-mode’ for repositories with mostly prose."
  (when (and (not (eq 'disable aj/magit-visual-line-mode))
             (or aj/magit-visual-line-mode
                 (cl-every #'aj/text-file-p (magit-list-files))))
    (visual-line-mode)))

(defun aj/text-file-p (file)
  (let ((case-fold-search nil))
    (aj/mode-equal-or-derived-p
     (assoc-default file auto-mode-alist
                    'string-match)
     '(text-mode org-mode))))

(defun aj/mode-equal-or-derived-p (mode modes)
  "Non-nil if MODE is one of MODES or derived from one of MODES"
  (or (memq mode modes)
      (apply #'provided-mode-derived-p mode modes)))
#+END_SRC

*** Dired display of untracked git files
#+BEGIN_SRC emacs-lisp
(defvar-local aj/dired-untracked-filter nil)
(put 'aj/dired-untracked-filter 'safe-local-variable #'stringp)

(defun aj/dired-untracked ()
  "List untracked git files with dired"
  (interactive)
  (switch-to-buffer (get-buffer-create "*untracked*"))
  (let ((dired-mode-hook
         (remq 'dired-collapse-mode dired-mode-hook))
        (filter (if aj/dired-untracked-filter
                    (concat "| grep -ve \"" aj/dired-untracked-filter "\" ")
                  "")))
    (shell-command (concat "git ls-files --others " filter "| xargs ls -lL")
                   (current-buffer))
    (dired-mode)
    (setq-local dired-subdir-alist
                (list (cons default-directory (point-min-marker))))))

#+END_SRC

*** git-timemachine
#+begin_src emacs-lisp
(use-package git-timemachine)
#+end_src
** visible-bookmarks (bm)
#+begin_src emacs-lisp
(use-package bm
  :defer 2
  :init (setq bm-restore-repository-on-load t)

  :bind (("<C-f5>" . bm-toggle)
         ("<f5>" . bm-next)
         ("<S-f5>" . bm-previous)
         ("<left-fringe> <mouse-5>" . bm-next-mouse)
         ("<left-fringe> <mouse-4>" . bm-previous-mouse)
         ("<left-fringe> <mouse-1>" . bm-toggle-mouse))
  :config
  (setq-default bm-buffer-persistence t)
  (setq bm-highlight-style 'bm-highlight-only-fringe
        bm-fringe-face 'gnus-summary-selected
        bm-fringe-persistent-face 'query-replace)
  (add-hook' after-init-hook 'bm-repository-load)
  (add-hook 'find-file-hooks 'bm-buffer-restore)
  (add-hook 'kill-buffer-hook 'bm-buffer-save)
  (add-hook 'kill-emacs-hook (lambda nil (bm-buffer-save-all) (bm-repository-save)))
  (add-hook 'after-save-hook 'bm-buffer-save)
  (add-hook 'after-revert-hook 'bm-buffer-restore))
#+end_src

** uniquify
#+begin_src emacs-lisp
(use-package uniquify
  :straight nil
  :demand t
  :config (setq uniquify-buffer-name-style 'post-forward-angle-brackets
                uniquify-after-kill-buffer-p t ; rename after killing uniquified
                uniquify-ignore-buffers-re "^\\*") ; ignore special buffers
  )
#+end_src

** GhostText + atomic-chrome.el for editing text areas etc. from firefox
#+begin_src emacs-lisp
(use-package atomic-chrome
  :init (atomic-chrome-start-server))
#+end_src

** New (custom) utility commands
#+begin_src emacs-lisp
(use-package aj-custom-commands
  :straight (aj-custom-commands :host gitlab :repo "andersjohansson/aj-custom-emacs-commands")
  :defer t
  :bind (("C-x C-k" . aj/delete-current-buffer-file)
         ("C-x C-r" . aj/rename-current-buffer-file)
         ("C-S-<return>" . ergoemacs-open-in-external-app)
         ("C-c m" . aj/message-peek))
  :init
  (straight-use-package 'pcsv)
  (bind-key "C-a" 'aj/beginning-or-indentation prog-mode-map)
  (with-eval-after-load "dired"
    (bind-key "<s-return>" #'aj/sudo-edit dired-mode-map)))
#+end_src

** Editing. Marking, killing, yanking, etc.

*** Delete-selection-mode
#+begin_src emacs-lisp
(delete-selection-mode)
#+end_src

*** Whole-line-or-region
#+BEGIN_SRC emacs-lisp
(use-package whole-line-or-region
  :demand t
  :config (whole-line-or-region-global-mode))
#+END_SRC
*** Volatile-highlight :ARCHIVE:
Highlights previously changed (yanked, undone, etc.) with a temporary highlight.
#+BEGIN_SRC emacs-lisp
(use-package volatile-highlights
  :commands volatile-highlights-mode
  :init (volatile-highlights-mode t)
  :config
  (with-eval-after-load 'undo-tree
    (vhl/define-extension 'undo-tree 'undo-tree-yank 'undo-tree-move)
    (vhl/install-extension 'undo-tree))
  (vhl/define-extension 'abbrev 'expand-abbrev)
  (vhl/install-extension 'abbrev)
  (vhl/define-extension 'helm-yank 'helm-kill-ring-action-yank)
  (vhl/install-extension 'helm-yank)
  (vhl/define-extension 'flyspell-prev 'flyspell-auto-correct-previous-word)
  (vhl/install-extension 'flyspell-prev)

  (defun aj/vhl-face (&optional theme)
    (when (aj/solarized-theme-p theme)
      (set-face-attribute 'vhl/default-face nil :background nil :foreground nil :inherit 'flycheck-info)))

  (aj/vhl-face)
  (add-hook 'aj/face-definitions-hook #'aj/vhl-face))
#+END_SRC
*** [[https://github.com/rejeep/drag-stuff.el][Drag stuff]] :ARCHIVE:
#+BEGIN_SRC emacs-lisp
(use-package drag-stuff
  :config
  (defhydra aj/hydra-drag-stuff (:color pink)
    "Drag stuff"
    ("f" drag-stuff-right)
    ("b" drag-stuff-left)
    ("p" drag-stuff-up)
    ("n" drag-stuff-down)
    ("q" nil nil))
  (bind-key [f9] #'aj/hydra-drag-stuff/body))
#+END_SRC
*** Save interprogram-paste, so it won’t be overwritten by kills done in emacs and is instead kept in the kill ring.
#+BEGIN_SRC emacs-lisp
(setq save-interprogram-paste-before-kill t)
#+END_SRC
*** expand-region
#+begin_src emacs-lisp
(use-package expand-region
  :bind ("C-ä" . er/expand-region))
#+end_src

*** Join line to following is my favourite command
#+begin_src emacs-lisp
(bind-key "M-j" #'aj/join-following)  ;; no use for comment-indent-new-line
(defun aj/join-following ()
  (interactive)
  (join-line -1))
#+end_src

*** cycle-spacing
#+begin_src emacs-lisp
(global-set-key (kbd "S-SPC") 'cycle-spacing)
#+end_src

*** hungry-delete                                                   :ARCHIVE:
Deleting a whitespace character deletes all whitespace up till non ws
#+begin_src emacs-lisp
(use-package hungry-delete
  :demand t
  :config (global-hungry-delete-mode))
#+end_src

** Various key binding customizations

*** Use ~C-x s~ for ~save-buffer~ and ~C-S-x C-S-s~ for ~save-some-buffers~
Becuase I often mistype and let go of my ctrl button before pressing s.
#+begin_src emacs-lisp
(bind-key "C-x s" #'save-buffer)
(bind-key "C-S-x C-S-s" #'save-some-buffers)
#+end_src

*** Goto-adress
#+begin_src emacs-lisp
(use-package goto-addr
  :hook ((compilation-mode . goto-address-mode)
         (prog-mode . goto-address-prog-mode)
         (text-mode . goto-address-mode)
         (elfeed-show-mode . goto-address-mode))
  :bind (:map goto-address-highlight-keymap
              ("C-c C-o" . goto-address-at-point))
  :commands (goto-address-prog-mode
             goto-address-mode))
#+end_src
*** Kill emacs instead of terminal
I often have more use for killing emacs (including all GUI-windows).
#+BEGIN_SRC emacs-lisp
(global-set-key [remap save-buffers-kill-terminal] #'save-buffers-kill-emacs)
#+END_SRC
*** No shift select
#+BEGIN_SRC emacs-lisp
(setq shift-select-mode nil)
#+END_SRC
*** Rectangle mark-mode hydra :ARCHIVE:
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x SPC") 'hydra-rectangle/body)

(defhydra hydra-rectangle (:body-pre (rectangle-mark-mode 1)
                                     :color pink
                                     :post (deactivate-mark))
  "
    ^_k_^     _d_elete    _s_tring
  _h_   _l_   _q_uit      _y_ank
    ^_j_^     _n_ew-copy  _r_eset
  ^^^^        _e_xchange  _u_ndo
  ^^^^        ^ ^         _p_aste
  "
  ("h" backward-char nil)
  ("l" forward-char nil)
  ("k" previous-line nil)
  ("j" next-line nil)
  ("e" hydra-ex-point-mark nil)
  ("n" copy-rectangle-as-kill nil)
  ("d" delete-rectangle nil)
  ("r" (if (region-active-p)
           (deactivate-mark)
         (rectangle-mark-mode 1)) nil)
  ("y" yank-rectangle nil)
  ("u" undo nil)
  ("s" string-rectangle nil)
  ("p" kill-rectangle nil)
  ("q" nil nil))

(defvar rectangle-mark-mode)
(defun hydra-ex-point-mark ()
  "Exchange point and mark."
  (interactive)
  (if rectangle-mark-mode
      (exchange-point-and-mark)
    (let ((mk (mark)))
      (rectangle-mark-mode 1)
      (goto-char mk))))
#+END_SRC

*** Reasonable binding (~C-'~) for ~other-window~, define backwards command as well.
(But I never seem to remember this, my fingers are stuck with ~C-x o~)
#+BEGIN_SRC emacs-lisp
(bind-key "C-'" #'other-window)
(with-eval-after-load 'org
  (unbind-key "C-'" org-mode-map))

(defun aj/back-window ()
  (interactive)
  (other-window -1))
(bind-key "C-x O" #'aj/back-window)
(bind-key "C-*" #'aj/back-window)
#+END_SRC

*** Kill this buffer instead of kill-buffer
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x k") #'aj/kill-this-buffer)
(global-set-key (kbd "C-x K") #'kill-buffer-and-window)


(defun aj/kill-this-buffer ()
  "Kill the current buffer.
When called in the minibuffer, get out of the minibuffer using
`abort-recursive-edit'."
  (interactive)
  (if (minibufferp)
      (abort-recursive-edit)
    (kill-buffer (current-buffer))))
#+END_SRC
*** count-words instead of count-words-region
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-=") #'count-words)
#+END_SRC
*** Emacs-which-key
#+BEGIN_SRC emacs-lisp
(use-package which-key
  :defer 4
  :config (which-key-setup-side-window-right-bottom)
  (which-key-mode)
  (setq which-key-paging-prefixes '("C-x"))
  (setq which-key-paging-key "<f2>"))
#+END_SRC
*** Hydra for launch
#+BEGIN_SRC emacs-lisp
(defhydra aj/hydra-launch (:color blue)
  "Launch"
  ("z" aj/helm-open-zoterofile "Öppna zoterofil")
  ;;("c" calc "calc")
  ("d" ediff-buffers "ediff buffers")
  ;;("f" 'find-dired "")
  ;;("g" 'lgrep)
  ;;("G" 'rgrep)
  ;;("h" 'man) ; Help
  ("l" list-processes "List processes")
  ("p" paradox-list-packages "paradox")
  ("e" eshell "eshell")
  ("t" proced "proced") ; top
  ("q" nil "quit"))

(bind-key "C-x L" #'aj/hydra-launch/body)
#+END_SRC
*** Hydra for toggle
#+BEGIN_SRC emacs-lisp
(defvar whitespace-mode nil)
(defhydra hydra-toggle (:color pink)
  "
_a_ abbrev-mode:       %`abbrev-mode
_d_ debug-on-error:    %`debug-on-error
_f_ auto-fill-mode:    %`auto-fill-function
_t_ truncate-lines:    %`truncate-lines
_w_ whitespace-mode:   %`whitespace-mode
_v_ variable-pitch:
"
  ("a" abbrev-mode nil)
  ("d" toggle-debug-on-error nil)
  ("f" auto-fill-mode nil)
  ("t" toggle-truncate-lines nil)
  ("w" whitespace-mode nil)
  ("v" variable-pitch-mode nil)
  ("q" nil "quit"))
;; Recommended binding:
(bind-key "C-x t" 'hydra-toggle/body)

;; Here, using e.g. "_a_" translates to "a" with proper face.
;; More interestingly:
;;
;;     "foobar %`abbrev-mode" means roughly (format "foobar %S" abbrev-mode)
;;
;; This means that you actually see the state of the mode that you're changing.
#+END_SRC
*** Mark-paragraph, backward-kill-word
#+begin_src emacs-lisp
(global-set-key (kbd "M-?") 'mark-paragraph)
(global-set-key (kbd "M-h") 'backward-kill-word)
#+end_src

*** Text-scale (zoom), and variable-pitch
#+begin_src emacs-lisp
;;Free the keys for it
(bind-keys ("C-x =" . balance-windows)
           ("C-x )" . what-cursor-position))

(defhydra hydra-zoom (global-map "C-x +")
  "zoom"
  ("+" text-scale-increase "in")
  ("-" text-scale-decrease "out")
  ("´" variable-pitch-mode "variable-pitch")
  ("0" (text-scale-increase 0) "reset"))

;; also zoom with C-scroll (like in Firefox)
(bind-key "<C-down-mouse-4>" #'text-scale-increase)
(bind-key "<C-down-mouse-5>" #'text-scale-decrease)
#+end_src

** Movement
*** ~C-S-a~ as back-to-indentation
#+begin_src emacs-lisp
(bind-key "C-S-a" 'back-to-indentation)
#+end_src

*** Up and down for line scrolling, C-n, C-p for moving cursor.
#+begin_src emacs-lisp
(global-set-key [up]  #'scroll-down-line)
(global-set-key [down] #'scroll-up-line)
#+end_src

*** Forward-word med bara whitespace som word-boundary
#+begin_src emacs-lisp
(defun aj/forward-word-ws ()
  (interactive)
  (forward-whitespace 1)
  (forward-whitespace -1))
(defun aj/backward-word-ws ()
  (interactive)
  (forward-whitespace -1)
  (forward-whitespace 1))

(global-set-key (kbd "C-c f") 'aj/forward-word-ws)
(global-set-key (kbd "C-c b") 'aj/backward-word-ws)
#+end_src


*** Scrolling
#+begin_src emacs-lisp
(setq scroll-conservatively 10000
      scroll-margin 3
      next-screen-context-lines 3
      scroll-error-top-bottom t
      scroll-preserve-screen-position 'in-place)
#+end_src

** Mixed stuff
This could perhaps be sorted better.
*** Don’t kill scratch-buffer
#+BEGIN_SRC emacs-lisp
(defun aj/unkillable-scratch-buffer ()
  (if (equal (buffer-name (current-buffer)) "*scratch*")
      (progn
        (erase-buffer)
        (bury-buffer)
        nil)
    t))
(add-hook 'kill-buffer-query-functions 'aj/unkillable-scratch-buffer)
#+END_SRC

*** Print to pdf
#+begin_src emacs-lisp
(defun aj/print-to-pdf (filename)
  (interactive "F")
  (ps-spool-buffer-with-faces)
  (switch-to-buffer "*PostScript*")
  (write-file "/tmp/tmp.ps")
  (kill-buffer "tmp.ps")
  (let ((cmd (format "ps2pdf14 /tmp/tmp.ps \"%s\"" filename )))
    (shell-command cmd)
    (shell-command "rm /tmp/tmp.ps")
    (message (concat "Saved to:  " filename))))

#+end_src

*** No pictures for speedbar
#+begin_src emacs-lisp
(setq speedbar-use-images nil)
#+end_src

*** Trash can be good
#+begin_src emacs-lisp
(setq delete-by-moving-to-trash t)

(defun aj/dired-do-delete-no-trash (&optional arg)
  "Delete without trashing all marked (or next ARG) files.
`dired-recursive-deletes' controls whether deletion of
non-empty directories is allowed."
  (interactive "P")
  (dired-internal-do-deletions
   ;; this may move point if ARG is an integer
   (nreverse
    (dired-map-over-marks (cons (dired-get-filename) (point))
                          arg))
   arg nil))

(eval-after-load 'dired
  '(progn
	 (define-key dired-mode-map (kbd "ä") 'aj/dired-do-delete-no-trash)
	 (define-key dired-mode-map (kbd "ö") 'aj/dired-do-last-mod-rename)))

(defun aj/visit-trash ()
  "Visit trash with dired, with `delete-by-moving-to-trash' set to nil."
  (interactive)
  (dired (concat (or (getenv "XDG_DATA_HOME") "~/.local/share") "/Trash/files"))
  (setq-local delete-by-moving-to-trash nil))

(defun aj/dired-restore-from-trash (&optional arg)
  "Restore marked (or next ARG) files in dired from Trash.

Only works with XDG trash dir."
  (interactive "P")
  (let* ((xdg-data-dir ;; these variables copied from ‘move-file-to-trash’
          (directory-file-name
           (expand-file-name "Trash"
                             (or (getenv "XDG_DATA_HOME")
                                 "~/.local/share"))))
         (trash-files-dir (expand-file-name "files" xdg-data-dir))
         (trash-info-dir (expand-file-name "info" xdg-data-dir)))

    (cl-loop for file in (dired-map-over-marks (dired-get-filename) arg)
             if (string-prefix-p trash-files-dir file) do
             (if-let ((trashinfo (expand-file-name
                                  (concat (file-name-nondirectory file)
                                          ".trashinfo")
                                  trash-info-dir))
                      (restorepath (with-temp-buffer
                                     (save-match-data
                                       (insert-file-contents trashinfo)
                                       (when (search-forward-regexp "^Path=\\(.+\\)$")
                                         (decode-coding-string
                                          (url-unhex-string (match-string 1))
                                          'utf-8 t)
                                         )))))
                 (when (y-or-n-p
                        (format "Restore %s → %s" (file-name-nondirectory file) restorepath))
                   (dired-rename-file file restorepath t)
                   (delete-file trashinfo))
               (user-error "Couldn’t find path to restore to."))
             else do (user-error "Can only restore files in trash dir"))))

(defun aj/dired-trash-remove (&optional arg)
  "Remove marked (or next ARG) files from trash using the trash-rm program."
  (interactive "P")
  (cl-loop for file in (dired-map-over-marks (dired-get-filename) arg) do
           (shell-command (format "trash-rm %s" (file-name-nondirectory file)))
           (dired-remove-file file)))
#+END_SRC

*** Fix ediff locale
ediff expects diff to return results in C-locale, I’ve made a wrapper script
(it’s: ~LANG=C diff "$1" "$2"~) to solve this.
#+begin_src emacs-lisp
(setq ediff-diff-program "aj-diff-no-locale")
#+end_src


*** y-or-n instead of yes-or-no
#+begin_src emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+end_src

*** Source my ~.bash_env~.
Needed when starting in a non-interactive shell.
#+begin_src emacs-lisp
(setenv "BASH_ENV" "~/.bash_env")
#+end_src

*** backup-files :org_async:
#+begin_src emacs-lisp
(setq delete-old-versions t
	  kept-new-versions 6
	  kept-old-versions 2
	  version-control t)
#+end_src

** prog-modes

*** LSP, language server protocol
This is the new thing, and it is good, because it knows a lot about the code and provides completion etc.
#+begin_src emacs-lisp
(use-package lsp-mode
  :hook (js-mode . lsp-mode)
  :config
  (set-face-attribute 'lsp-face-highlight-read nil :inherit 'idle-highlight)
  (add-hook 'lsp-mode-hook (lambda () (idle-highlight-mode -1))))

(use-package lsp-ui
  :hook (lsp-mode . lsp-ui-mode)
  :config
  (set-face-attribute 'lsp-ui-sideline-code-action nil :foreground nil :inherit 'font-lock-function-name-face)
  (set-face-attribute 'lsp-ui-sideline-current-symbol nil :foreground nil :weight 'light :inherit 'highlight))
(use-package company-lsp :commands company-lsp)
(use-package helm-lsp :commands helm-lsp-workspace-symbol)

#+end_src

*** Highlight todos (hl-todo)
#+begin_src emacs-lisp
(use-package hl-todo
  :commands global-hl-todo-mode
  :defer 10
  :config (global-hl-todo-mode t))
#+end_src

*** eldoc
#+BEGIN_SRC emacs-lisp
(global-eldoc-mode t)
#+END_SRC

*** Some settings for whitespace and ediff
#+BEGIN_SRC emacs-lisp
(setq whitespace-style '(face trailing lines-tail tabs)
      whitespace-line-column 80
      ediff-window-setup-function 'ediff-setup-windows-plain)
#+END_SRC
*** paren-face
Dims parantheses in lisp modes.
#+BEGIN_SRC emacs-lisp
(use-package paren-face
  :init (global-paren-face-mode))
#+END_SRC
*** Elisp
**** Some settings from ESK
#+begin_src emacs-lisp
(add-hook 'emacs-lisp-mode-hook 'aj/remove-elc-on-save)

(defun aj/remove-elc-on-save ()
  "If you're saving an elisp file, likely the .elc is no longer valid."
  (add-hook 'after-save-hook
            (lambda ()
              (if (file-exists-p (concat buffer-file-name "c"))
                  (delete-file (concat buffer-file-name "c"))))
            nil t))

(define-key read-expression-map (kbd "TAB") #'completion-at-point)
(define-key lisp-mode-shared-map (kbd "RET") 'reindent-then-newline-and-indent)
#+end_src
**** Elisp-slime-nav
#+BEGIN_SRC emacs-lisp
(use-package elisp-slime-nav
  :init (add-hook 'emacs-lisp-mode-hook #'elisp-slime-nav-mode)
  :config
  (defun aj/find-elisp-thing-at-point-other-window (sym-name)
    "Find the elisp thing at point, be it a function, variable, library or face. Display in other window.

With a prefix arg, or if there is no thing at point, prompt for
the symbol to jump to.

Argument SYM-NAME is the thing to find."
    (interactive (list (elisp-slime-nav--read-symbol-at-point)))
    (when sym-name
      (let ((sym (intern sym-name)))
        (message "Searching for %s..." sym-name)
        (if (fboundp 'xref-push-marker-stack)
            (xref-push-marker-stack)
          (with-no-warnings
            (ring-insert find-tag-marker-ring (point-marker))))
        (cond
         ((fboundp sym)
          (find-function-do-it sym nil #'switch-to-buffer-other-window))
         ((boundp sym)
          (find-function-do-it sym 'defvar #'switch-to-buffer-other-window))
         ((or (featurep sym) (locate-library sym-name))
          (find-library sym-name)) ;; explicitly calls switch-to-buffer
         ((facep sym)
          (find-function-do-it sym 'defface #'switch-to-buffer-other-window))
         (t
          (pop-tag-mark)
          (error "Don't know how to find '%s'" sym))))))

  (define-key elisp-slime-nav-mode-map (kbd "C-M-.")
    #'aj/find-elisp-thing-at-point-other-window))


#+END_SRC
**** Timestamps
#+BEGIN_SRC emacs-lisp
(defun aj/elisp-timestamps ()
  (setq-local time-stamp-line-limit 10)
  (setq-local time-stamp-start "^;; Modified: ")
  (setq-local time-stamp-end "$")
  (setq-local time-stamp-format "%:y-%02m-%02d")
  (add-hook 'before-save-hook #'time-stamp nil t))

(add-hook 'emacs-lisp-mode-hook #'aj/elisp-timestamps)
#+END_SRC
**** Nameless
#+BEGIN_SRC emacs-lisp
(use-package nameless
  :defer t
  :init (add-hook 'emacs-lisp-mode-hook #'nameless-mode)
  (setq nameless-private-prefix t
        nameless-affect-indentation-and-filling nil))
#+END_SRC
**** Electric-quote-mode
#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-lisp-mode-hook #'electric-quote-local-mode)
(setq electric-quote-context-sensitive t)
#+END_SRC

*** aggressive-indent
#+begin_src emacs-lisp
(use-package aggressive-indent
  :commands aggressive-indent-mode
  :init (add-hook 'prog-mode-hook #'aggressive-indent-mode)
  :config (add-hook 'reb-mode-hook (lambda () (aggressive-indent-mode -1))) ;; meaningless and shadows the important keybinding C-c C-q
  )
#+end_src



*** Outline
**** Outshine :ARCHIVE:
Could be used better some day, need to define good keybindings and stuff, and then navigation could be very easy.
http://www.modernemacs.com/post/outline-ivy/
#+BEGIN_SRC emacs-lisp
(use-package outshine
  :init
  (add-hook 'outline-minor-mode-hook 'outshine-hook-function)
  :config  (setq outshine-use-speed-commands t))

#+END_SRC
**** outline-magic
Well?
#+BEGIN_SRC emacs-lisp
(use-package outline-magic
  :commands outline-cycle
  :init (with-eval-after-load 'outline
          (bind-key "<C-tab>" 'outline-cycle outline-minor-mode-map)))
#+END_SRC

**** Outline hydra
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'outline
  (defhydra hydra-outline (:color pink :hint nil)
    "
^Hide^             ^Show^           ^Move
^^^^^^------------------------------------------------------
_z_: sublevels     _a_: all         _u_: up
_t_: body          _e_: entry       _n_: next visible
_o_: other         _i_: children    _p_: previous visible
_c_: entry         _k_: branches    _f_: forward same level
_l_: leaves        _s_: subtree     _b_: backward same level
_d_: subtree     _<tab>_: toggle

"
    ;; Hide
    ("z" outline-hide-sublevels)    ; Hide everything but the top-level headings
    ("t" outline-hide-body)         ; Hide everything but headings (all body lines)
    ("o" outline-hide-other)        ; Hide other branches
    ("c" outline-hide-entry)        ; Hide this entry's body
    ("l" outline-hide-leaves)       ; Hide body lines in this entry and sub-entries
    ("d" outline-hide-subtree)      ; Hide everything in this entry and sub-entries
    ;; Show
    ("a" outline-show-all)          ; Show (expand) everything
    ("e" outline-show-entry)        ; Show this heading's body
    ("i" outline-show-children)     ; Show this heading's immediate child sub-headings
    ("k" outline-show-branches)     ; Show all sub-headings under this heading
    ("s" outline-show-subtree)      ; Show (expand) everything in this heading & below
    ("<tab>" outline-cycle)
    ;; Move
    ("u" outline-up-heading)                ; Up
    ("n" outline-next-visible-heading)      ; Next
    ("p" outline-previous-visible-heading)  ; Previous
    ("f" outline-forward-same-level)        ; Forward - same level
    ("b" outline-backward-same-level)       ; Backward - same level
    ("q" nil "leave"))

  (bind-key "C-c #" 'hydra-outline/body outline-minor-mode-map)) ; by example
#+END_SRC

*** Origami folding
#+BEGIN_SRC emacs-lisp
(use-package origami
  :commands origami-mode
  :config (bind-keys :map origami-mode-map
                     ("<tab>" . origami-recursively-toggle-node)
                     ("<backtab>" . origami-toggle-all-nodes)))
#+END_SRC

*** octave-mode
#+begin_src emacs-lisp
(autoload 'octave-mode "octave" nil t)
(setq auto-mode-alist
      (cons '("\\.m$" . octave-mode) auto-mode-alist))
#+end_src

*** Tabs or spaces
#+begin_src emacs-lisp
(setq-default tab-width 4)
(defvaralias 'cperl-indent-level 'tab-width)
(defvaralias 'js-indent-level 'tab-width)

;; (use-package smart-tabs-mode
;;   :commands smart-tabs-insinuate
;;   :init (smart-tabs-insinuate 'c 'c++ 'java 'javascript 'cperl 'python 'ruby 'nxml)
;;   )

(add-hook 'emacs-lisp-mode-hook
		  (lambda ()
			;; Use spaces, not tabs.
			(setq indent-tabs-mode nil)))
#+end_src

*** smartparens
#+begin_src emacs-lisp
(use-package smartparens
  :init (require 'smartparens-config)
  :config
  (smartparens-global-mode t)
  (add-to-list 'sp-ignore-modes-list 'org-agenda-mode)
  (show-smartparens-global-mode t)
  (sp-use-smartparens-bindings)
  (sp-pair "`" nil :actions :rem) ;den sabbar org-cdlatex-mode m.m.
  (sp-local-pair 'org-mode "\\(" "\\)" :trigger "$$")
  (face-spec-reset-face 'sp-show-pair-match-face)
  (face-spec-reset-face 'sp-show-pair-mismatch-face)
  (set-face-attribute 'sp-show-pair-match-face nil :inherit 'show-paren-match)
  (set-face-attribute 'sp-show-pair-mismatch-face nil :inherit 'show-paren-mismatch)
  (define-key smartparens-mode-map (kbd "M-<delete>") 'undefined))
;; sista sabbar mitt skrivande, borde bara kopplas till org-mode, men vet inte hur)
#+end_src

*** Comment-dwim-2
To only activate it in prog-mode, we define a minor mode with the binding.
#+begin_src emacs-lisp
(use-package comment-dwim-2
  :init
  (defvar comment-dwim-2-mode-map
    (let ((map (make-sparse-keymap)))
      (define-key map (kbd "C-c C-;") #'comment-dwim-2)
      map))

  (define-minor-mode comment-dwim-2-mode
    "Binds ‘comment-dwim-2’"
    :keymap comment-dwim-2-mode-map)


  (add-hook 'prog-mode-hook #'comment-dwim-2-mode))
#+end_src

*** Minibuffer evaluation
#+BEGIN_SRC emacs-lisp
(add-hook 'eval-expression-minibuffer-setup-hook #'smartparens-mode)
#+END_SRC
*** CPERL
cperl instead of perl-mode
#+begin_src emacs-lisp
(use-package cperl-mode
  :straight nil
  :defer t
  :init (defalias 'perl-mode 'cperl-mode)
  :functions cperl-set-style
  :config (cperl-set-style "GNU")
  (defun aj/cperl-eldoc-documentation-function ()
    "Return meaningful doc string for `eldoc-mode'."
    (car (let ((cperl-message-on-help-error nil))
           (cperl-get-help))))
  (add-hook 'cperl-mode-hook (eldoc-mode))
  (add-hook 'cperl-mode-hook
            (lambda () (setq-local eldoc-documentation-function
                              'aj/cperl-eldoc-documentation-function))))

;; ;; helm-perldoc:setup takes long time on low power platform
;; (helm-perldoc:setup)
;; (add-hook 'cperl-mode-hook 'helm-perldoc:carton-setup)

#+end_src

*** Notifications while compiling
#+begin_src emacs-lisp
  (autoload 'notifications-notify "notifications")
  (defun aj/compile-notify (_buffer message)
    (notifications-notify :title "Emacs kompilering" :body message :urgency "critical"))
  (add-to-list 'compilation-finish-functions 'aj/compile-notify)
#+end_src

*** Prettify
#+BEGIN_SRC emacs-lisp
(global-prettify-symbols-mode t)
(setq prettify-symbols-unprettify-at-point t)
#+END_SRC
*** A few fixes from ESK
#+begin_src emacs-lisp
(defun esk-local-comment-auto-fill ()
  (setq-local comment-auto-fill-only-comments t)
  (auto-fill-mode t))

(add-hook 'prog-mode-hook 'esk-local-comment-auto-fill)
#+end_src
*** Idle-highlight-mode
#+begin_src emacs-lisp
(use-package idle-highlight-mode
  :hook prog-mode)
#+end_src
** Text-modes and spelling

*** Visual-line-mode
**** Text-mode uses visual-line-mode and visual-fill-column-mode
#+begin_src emacs-lisp
(add-hook 'text-mode-hook 'turn-on-visual-line-mode)
(add-hook 'visual-line-mode-hook #'aj/hl-line-visual-line)

(defun aj/hl-line-visual-line ()
  (setq-local hl-line-range-function #'aj/hl-line-visual-line-range-function))

(defun aj/hl-line-visual-line-range-function ()
  (cons
   (save-excursion (beginning-of-visual-line))
   (save-excursion (beginning-of-visual-line 2))))

(use-package visual-fill-column
  :init (add-hook 'visual-line-mode-hook #'visual-fill-column-mode)
  :config
  (setq-default visual-fill-column-width 100)
  (setq split-window-preferred-function #'visual-fill-column-split-window-sensibly)
  (advice-add 'text-scale-increase :after #'visual-fill-column-adjust))
#+end_src

**** Define a binding for killing logical line in visual-line-mode, make sure this works also in org-mode, and that org-mode calls org-kill-line even if visual-line-mode is activated
#+begin_src emacs-lisp
;;(with-eval-after-load 'simple
(define-key visual-line-mode-map [remap kill-line] nil)
(bind-keys :map visual-line-mode-map
           ("C-k" . kill-visual-line)
           ("C-S-k" . kill-line))

(with-eval-after-load 'org
  (define-key org-mode-map [remap kill-line] nil)
  (bind-keys :map org-mode-map
             ("C-k" . org-kill-line)
             ("C-S-k" . kill-line))

  ;; Make org-kill-line take priority over kill-visual-line
  (defvar aj/org-visual-line-mode-map (copy-keymap visual-line-mode-map))
  (define-key aj/org-visual-line-mode-map (kbd "C-k") #'org-kill-line)
  (define-key aj/org-visual-line-mode-map  [remap kill-line] nil)
  (define-key aj/org-visual-line-mode-map  (kbd "C-S-k") #'kill-line)

  (defun aj/org-override-visual-line-mode-map ()
    (setq minor-mode-overriding-map-alist
          (list (cons visual-line-mode aj/org-visual-line-mode-map))))

  (add-hook 'org-mode-hook #'aj/org-override-visual-line-mode-map))

#+end_src

*** No, sentences don’t end with double space
That’s a stupid convention from the days of the typewriter (and in Swedish we don’t even use the longer (not double!) spaces after sentences that are good typographic practice in English).
#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
#+END_SRC
*** Fill-paragraph fixes + ~aj/one-sentence-per-line-mode~
I generally don’t want hard line breaks in my text-mode paragraphs, so a very wide fill-column allows me to use ~M-q~ to remove all line breaks in a paragraph.

However, sometimes I put every sentence on it’s own line (good for version control) and then it would be good if ~fill-paragraph~ made sure that this was the case instead.

The minor mode defined below takes care of this. I advice ~fill-region-as-paragraph~ which is called by ~org-fill-paragraph~ (which is the most common way for me of invoking it), but perhaps there can be some invocations that are not matched by this. It would probably be cleaner to remap some keys, but this covers many cases in one go.

#+BEGIN_SRC emacs-lisp
(add-hook 'text-mode-hook (lambda () (setq fill-column 99999)))

(define-minor-mode aj/one-sentence-per-line-mode
  "Minor mode that overrides `fill-region-as-paragraph' to
  arrange every sentence on its own line")

(defun aj/one-sentence-fill-override (fun from to &rest args)
  (if aj/one-sentence-per-line-mode
      (aj/one-sentence-per-line-region from to)
    (apply fun from to args)))

(advice-add 'fill-region-as-paragraph :around #'aj/one-sentence-fill-override)

(defun aj/one-sentence-per-line-region (from to)
  "Makes one sentence per line in region"
  (interactive "r")
  (let ((se (sentence-end)))
    (save-excursion
      (goto-char from)
      ;; start by removing all but the last line breaks
      (while (search-forward "\n" (1- to) t)
        (replace-match " " t t))
      (goto-char from)
      ;; has to changed? too much?
      (while (search-forward-regexp se (- to 2) t)
        (replace-match "\n" t nil nil 2)))))

(defun aj/set-org-sentence-end ()
  "Allow sentences to end with an org-bracket-link

I often put `org-annotate' comments after sentences, and these
should be kept together."
  (setq-local
   sentence-end
   (format
    "\\(?9:[.?!…‽][]\"'”’)}]*\\(?8:%s\\)?\\(?2:$\\|[	  ]\\)\\|[。．？！]+\\)[
]*"
    org-link-bracket-re)))

(add-hook 'org-mode-hook #'aj/set-org-sentence-end)
#+END_SRC

*** ~aj/one-sentence-per-line-highlight-mode~, highlight missing end of sentence characters
#+begin_src emacs-lisp
(defface aj/missing-eol-period '((t :inherit trailing-whitespace :extend t))
  "Face for marking missing end-of-sentence characters in
‘aj/one-sentence-per-line-highlight-mode’"
  :group 'aj)

(defvar aj/missing-eol-period-fl-keywords
  ;; anchored match: First matches lines starting with alnum (not
  ;; org-headlines for example), and then highlights words at eol
  ;; without periods etc.
  '(("^[[:alnum:]]" "\\b[[:word:]]+[^].?!:…‽\"'”’]$" nil nil
     (0 'aj/missing-eol-period prepend))))


(define-minor-mode aj/one-sentence-per-line-highlight-mode
  "Minor mode that marks missing end of senptence characters when
  writing one sentence per line"
  nil nil nil
  (if aj/one-sentence-per-line-highlight-mode
      (font-lock-add-keywords nil aj/missing-eol-period-fl-keywords)
    (font-lock-remove-keywords nil aj/missing-eol-period-fl-keywords)))
#+end_src

*** Fix text-mode syntax table and char table for quote symbols
When writing english with contractions using "right single quotation mark", ~’~, it needs to be treated as a word character, similar to how ~'~ is treated in ~text-mode-syntax-table~.

In addition, words made up of characters from different scripts won’t be considered a word by word-movement functions etc. Apperently the curly quote symbols in unicode is in the ~symbol~ script, whereas "ordinary" letters and the straight quotes are ~latin~ (I guess this is for historical reasons). I don’t know if there are any negative effects with putting the curly quotes in ~latin~, but it makes word navigation work. Maybe I should keep the changes to ~’~.

#+BEGIN_SRC emacs-lisp
(modify-syntax-entry ?’ "w" text-mode-syntax-table)
(dolist (c '(?“ ?” ?‘ ?’))
  (set-char-table-range char-script-table c 'latin))
#+END_SRC

*** WC-mode :ARCHIVE:
In some way interacts with the advice in delight.el to ~format-mode-line~ and causes ~wc-mode-count~ to be called even if ~wc-mode~ is not activated.
Disable for now. (I never use it).
 #+begin_src emacs-lisp
(use-package wc-mode
  :commands wc-mode
  :config (setq wc-modeline-format "[W:%tw]"))
#+end_src

*** Abbrev-mode
In the abbrev-file I have defined two tables to use as parents of ~text-mode-abbrev-table~, ~aj/swedish-abbrevs~ and ~aj/english-abbrevs~. They are activated when writing in English or Swedish as defined by the functions below (the ~:enable-function~ of the tables).

I also define abbrevs for english which expand "dont" to "do not" etc. in the table ~aj/formal-english-abbrevs~. This is activated via the minor mode ~aj/formal-english-minor-mode~.

Editing abbrevs with ~edit-abbrevs~ and saving them in the abbrev-file doesn’t seem to preserve properties. Therefore properties are added below (Some of this will be fixed in 27.1).
#+BEGIN_SRC emacs-lisp
(use-package abbrev
  :straight nil
  :init
  (add-hook 'text-mode-hook #'abbrev-mode)
  (setq abbrev-file-name "~/.emacs.d/config/abbrev_defs")
  :config
  ;; Define a special abbrev for i->I, use it only when writing non-Swedish
  (require 'ispell)
  (defun aj/make-i-I ()
    (when (or (bound-and-true-p orgqda-transcript-mode)
              (and
               ispell-local-dictionary
               (not (string-match-p "sv" ispell-local-dictionary))))
      (zap-to-char -1 ?i)
      (insert "I")))


  ;; TODO, check use of ispell-local-dictionary, ispell-dictionary, ispell-current-dictionary
  (defun aj/writing-english-p ()
    (if ispell-local-dictionary
        (string-match-p "en" ispell-local-dictionary)
      (and flyspell-mode ispell-dictionary
           (string-match-p "en" ispell-dictionary))))

  (defun aj/writing-swedish-p ()
    (if ispell-local-dictionary
        (string-match-p "sv" ispell-local-dictionary)
      (and flyspell-mode ispell-dictionary
           (string-match-p "sv" ispell-dictionary))))

  (with-eval-after-load abbrev-file-name
    (abbrev-table-put aj/english-abbrevs :enable-function #'aj/writing-english-p)
    (abbrev-table-put aj/swedish-abbrevs :enable-function #'aj/writing-swedish-p)
    (abbrev-table-put text-mode-abbrev-table
                      :parents (list aj/english-abbrevs aj/swedish-abbrevs))
    ;; to add or replace it every time abbrev-file is loaded:
    (setf (alist-get 'aj/formal-english-minor-mode abbrev-minor-mode-table-alist)
          aj/formal-english-abbrevs)))

(define-minor-mode aj/formal-english-minor-mode
  "Minor mode for expanding abbrevs like \"dont\" to \"do not\"."
  :lighter ""
  (if aj/formal-english-minor-mode
      (font-lock-add-keywords nil (aj/formal-english-fl-keywords))
    (font-lock-remove-keywords nil (aj/formal-english-fl-keywords)))
  (font-lock-flush))

(defvar aj/formal-english-highlights
  '("aren't" "aren’t" "can't" "can’t" "couldn't" "couldn’t" "could've" "could’ve" "didn't" "didn’t" "doesn't" "doesn’t" "don't" "don’t" "hadn't" "hadn’t" "hasn't" "hasn’t" "haven't" "haven’t" "i'll" "i’ll" "isn't" "isn’t" "mightn't" "mightn’t" "mustn't" "mustn’t" "shouldn't" "shouldn’t" "should've" "should’ve" "that's" "that’s" "there's" "there’s" "wasn't" "wasn’t" "we're" "we’re" "weren't" "weren’t" "we've" "we’ve" "what's" "what’s" "where's" "where’s" "won't" "won’t" "wouldn't" "wouldn’t" "would've" "would’ve"))

;; could be precomputed but ...
(defun aj/formal-english-fl-keywords ()
  `((,(regexp-opt aj/formal-english-highlights) 0 'hi-pink prepend)))
#+END_SRC

*** Spelling: Ispell + flyspell
**** Options, define languages, hunspell, etc.
#+begin_src emacs-lisp
(setq-default ispell-program-name "hunspell")

(setq ispell-silently-savep t
      ;; ispell-dictionary "sv_SE"
      )

;; (setq ispell-local-dictionary-alist
;;       '(("en_GB"
;;          "[[:alpha:]]" "[^[:alpha:]]"
;;          "[’'´.0-b:-]" t ("-d" "en_GBz-large")
;;          nil utf-8)
;;         ("en_US"
;;          "[[:alpha:]]" "[^[:alpha:]]"
;;          "[’'´.0-b:-]" t ("-d" "en_US")
;;          nil utf-8)
;;         ("en_GB,sv_SE"
;;          "[[:alpha:]]" "[^[:alpha:]]"
;;          "[’'´.0-b:-]" t ("-d" "en_GBz-large,sv_SE")
;;          nil utf-8)
;;         ("blandat"
;;          "[[:alpha:]]" "[^[:alpha:]]"
;;          "[ø’'´.0-b:-]" t ("-d" "en_GBz-large,sv_SE,da_DK")
;;          nil utf-8)
;;         ("en_US,sv_SE"
;;          "[[:alpha:]]" "[^[:alpha:]]"
;;          "[’'´.0-b:-]" t ("-d" "en_US,sv_SE")
;;          nil utf-8)))

;; (with-eval-after-load 'ispell

;; ispell-set-spellchecker-params has to be called
;; before ispell-hunspell-add-multi-dic will work
;; (ispell-set-spellchecker-params)
;;(ispell-hunspell-add-multi-dic "en_GB,sv_SE")
;;(ispell-hunspell-add-multi-dic "en_US,sv_SE")

;; but I want to have control over all parameters,
;; quoting characters and personal dictionaries.

(add-hook 'ispell-initialize-spellchecker-hook #'aj/extra-dicts)
(defun aj/extra-dicts ()
  (setq ispell-base-dicts-override-alist
        '(("en_GB"
           "[[:alpha:]]" "[^[:alpha:]]"
           "[’'´.0-b:-]" t ("-d" "en_GBz-large")
           nil utf-8)
          ("en_US"
           "[[:alpha:]]" "[^[:alpha:]]"
           "[’'´.0-b:-]" t ("-d" "en_US")
           nil utf-8)
          ("en_GB,sv_SE"
           "[[:alpha:]]" "[^[:alpha:]]"
           "[’'´.0-b:-]" t ("-d" "en_GBz-large,sv_SE")
           nil utf-8)
          ("blandat"
           "[[:alpha:]]" "[^[:alpha:]]"
           "[ø’'´.0-b:-]" t ("-d" "en_GBz-large,sv_SE,da_DK")
           nil utf-8)
          ("en_US,sv_SE"
           "[[:alpha:]]" "[^[:alpha:]]"
           "[’'´.0-b:-]" t ("-d" "en_US,sv_SE")
           nil utf-8))))

#+END_SRC

**** flyspell-hydra and custom commands
#+BEGIN_SRC emacs-lisp
(bind-key "C-c l" 'hydra-flyspell/body)
(defhydra hydra-flyspell (:color blue :hint nil)
  "
^Correct:^    _,_: auto-correct   _c_orrect Current: %(identity ispell-current-dictionary)
^Toggle:^     _l_: turn %(if flyspell-mode \"off\" \"on \") flyspell _L_ toggle+disable, turn: %(if flyspell-mode \"off\" \"on \")
^Languages:^  _s_venska   _b_ritish  _d_: svenska-british _a_: blandat  _u_s english
"
  ("l" flyspell-mode)
  ("L" aj/disable-enable-flyspell-permanently-in-file)
  ("c" ispell-word)
  ("," flyspell-auto-correct-word :color red)
  ("s" (aj/ispell-change-dictionary "sv_SE"))
  ("S" (aj/ispell-change-dictionary-store "sv_SE"))
  ("b" (aj/ispell-change-dictionary "en_GB"))
  ("B" (aj/ispell-change-dictionary-store "en_GB"))
  ("d" (aj/ispell-change-dictionary "en_GB,sv_SE"))
  ("D" (aj/ispell-change-dictionary-store "en_GB,sv_SE"))
  ("a" (aj/ispell-change-dictionary "blandat"))
  ("A" (aj/ispell-change-dictionary-store "blandat"))
  ("u" (aj/ispell-change-dictionary "en_US"))
  ("U" (aj/ispell-change-dictionary-store "en_US"))
  ("q" nil))

(defun aj/ispell-change-dictionary (dict)
  "Change dictionary, enable ‘flyspell-mode’, disable ‘guess-language-mode’"
  (ispell-change-dictionary dict)
  (flyspell-mode)
  (guess-language-mode -1))

(defun aj/disable-enable-flyspell-permanently-in-file ()
  (interactive)
  (save-excursion
    (save-restriction
      (widen)
      (if flyspell-mode
          (progn
            (flyspell-mode -1)
            (guess-language-mode -1)
            (add-file-local-variable 'aj/inhibit-flyspell t))
        (flyspell-mode)
        (goto-char (point-min))
        (when (search-forward "Local Variables" nil t)
          (flush-lines "aj/inhibit-flyspell: t"))))))

(defun aj/ispell-change-dictionary-store (dict)
  (interactive (list (completing-read
                      "Dictionary: "
                      (mapcar #'car ispell-dictionary-alist))))
  (save-excursion
    (aj/ispell-change-dictionary dict)
    (add-file-local-variable 'ispell-local-dictionary dict)))

(advice-add 'ispell-change-dictionary :after #'aj/ispell-change-dictionary-merge-personal)

(defun aj/ispell-change-dictionary-merge-personal (dict &rest _args)
  "If this is a combined dictionary (hunspell), merges all
personal dictionaries into a combined personal dictionary."
  (when (and dict
             (string-match "," dict))
    (let* ((filenamefn (apply-partially #'format "~/.hunspell_%s"))
           (dictfiles
            (cons (funcall filenamefn dict)
                  (mapcar filenamefn (split-string dict "," t " ")))))
      (with-temp-buffer
        (dolist (d dictfiles)
          (when (file-readable-p d) (insert-file-contents d)))
        (unless (eq (point-min) (point-max))
          (delete-duplicate-lines (point-min) (point-max))
          (write-file (car dictfiles))))
      ;; should be overridden in `ispell-buffer-local-dict' if we have
      ;; a local variable definition in the buffer
      ;; tvivlar på att detta är rätt kanske:
      ;; (setq-local ispell-local-pdict (car dictfiles))

      ;; eller så borde den avsättas om vi växlat till en icke-mergad.
      )))
#+end_src

**** Guess language, conditional enabling of flyspell and setting of languages for flyspell, typo and langtool.
#+BEGIN_SRC emacs-lisp
(use-package guess-language
  :defer t
  :config
  (setq guess-language-langcodes '((en . ("en_GB" "English"))
                                   (sv . ("sv_SE" "Swedish")))
        guess-language-languages '(en sv)
        guess-language-min-paragraph-length 45)
  (add-to-list 'guess-language-after-detection-functions
               #'aj/set-langtool-language)

  (defun aj/set-langtool-language (lang _beg _end)
    (cl-case lang
      (sv (setq-local langtool-default-language "sv-SE"))
      (en (setq-local langtool-default-language "en-GB")))))


(defvar aj/flyspell-modes '(org-mode))
(defvar-local aj/inhibit-flyspell nil)
(put 'aj/inhibit-flyspell 'safe-local-variable #'booleanp)

;; Activate flyspell if local ispell-language defined.

;; Functions that maybe enables flyspell and guess-language, a second
;; after local variables are read (to ensure ispell language and
;; aj/inhabit-flyspell is set).

(add-hook 'hack-local-variables-hook #'aj/maybe-enable-flyspell)

(defun aj/maybe-enable-flyspell ()
  (run-with-idle-timer 1 nil #'aj/maybe-enable-flyspell-fn (current-buffer)))

(defun aj/maybe-enable-flyspell-fn (buf)
  "Possibly enable ‘flyspell-mode’

Enable it for buffers in ‘aj/flyspell-modes’ with defined
‘ispell-local-dictionary’, or for ‘mu4e-compose-mode’ (then use
‘guess-language-mode’)"
  (when (buffer-live-p buf)
    (with-current-buffer buf
      (cond ((or (and (not aj/inhibit-flyspell)
                      (member major-mode aj/flyspell-modes)
                      ispell-local-dictionary))
             (flyspell-mode 1)
             (aj/set-langtool-language-from-ispell-dict))
            ((eq major-mode 'mu4e-compose-mode)
             (flyspell-mode 1)
             (guess-language-mode 1))))))

(defun aj/set-langtool-language-from-ispell-dict ()
  (when (and ispell-local-dictionary
             (< (length ispell-local-dictionary) 7))
    (setq-local langtool-default-language
                (replace-regexp-in-string "\_" "-" ispell-local-dictionary))))
#+END_SRC

**** Extra flyspell bindings
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'flyspell
  (bind-keys :map flyspell-mode-map
             ("C-,"   . flyspell-auto-correct-previous-word)
             ("C-;"   . flyspell-check-previous-highlighted-word)
             ("C-M-," . flyspell-goto-next-error)))
#+END_SRC
**** Helm flyspell, on C-ö
#+BEGIN_SRC emacs-lisp
(use-package helm-flyspell
  :commands helm-flyspell-correct
  :init (with-eval-after-load 'flyspell
          (bind-key "C-ö" 'helm-flyspell-correct flyspell-mode-map)))
#+END_SRC
**** Extra areas to skip in org-mode
#+BEGIN_SRC emacs-lisp
(defun aj/org-flyspell-skip-links (fun)
  (if (memq (face-at-point) '(org-link org-date org-scheduled))
      nil
    (funcall fun)))

(advice-add 'org-mode-flyspell-verify :around #'aj/org-flyspell-skip-links)
#+END_SRC

**** Ispell-multi, keep processes for multiple languages going. :ARCHIVE:

#+begin_src emacs-lisp
(use-package ispell-multi
  :load-path "~/kodat/elisp/ispell-multi"
  :after ispell
  :config (ispell-multi-activate))

#+end_src

**** COMMENT With wcheck :ARCHIVE:
#+BEGIN_SRC emacs-lisp
(setq ispell-really-hunspell t)

(setq  wcheck--timer-idle .1)
(set-face-attribute 'wcheck-default-face nil :underline 'unspecified :inherit 'flyspell-incorrect)

(setq-default
 wcheck-language "English"
 wcheck-language-data
 '(("English"
    (program . "/usr/bin/hunspell")
    (args . ("-l" "-d" "en_US"))
    (action-program . "/usr/bin/hunspell")
    (action-args . ("-a" "-d" "en_US"))
    (action-parser . wcheck-parser-ispell-suggestions))
   ("Swedish"
    (program . "/usr/bin/hunspell")
    (args . ("-l" "-d" "sv_SE"))
    (action-program . "/usr/bin/hunspell")
    (action-args . ( "-m" "-a" "-d" "sv_SE" "-i" "utf-8"))
    (action-parser . wcheck-parser-ispell-suggestions))
   ("sv-en"
    (program "/usr/bin/hunspell")
    (args . ("-l" "-d" "sv_SE,en_GB"))
    (action-program . "/usr/bin/hunspell")
    (action-args . ( "-m" "-a" "-d" "sv_SE,en_GB" "-i" "utf-8"))
    (action-parser . wcheck-parser-ispell-suggestions)))))


;; toggle between Danish and English easily
(let ((langs '("English" "Swedish")))
  (setq lang-ring (make-ring (length langs)))
  (dolist (elem langs) (ring-insert lang-ring elem)))

(defun aj/cycle-ispell-languages ()
  (interactive)
  (let ((lang (ring-ref lang-ring -1)))
	(ring-insert lang-ring lang)
	(wcheck-change-language lang)))

(global-set-key (kbd "C-c l") 'aj/cycle-ispell-languages)
(global-set-key (kbd "C-c L") 'wcheck-mode)


(global-set-key "\M-n" 'wcheck-spelling-suggestions)

#+END_SRC

*** Typo
For doing smart (curly) quotes, mainly in emails since org has it’s own mechanism
#+BEGIN_SRC emacs-lisp
(use-package typo
  :after mu4e
  :config
  (setq-default typo-language "Swedish")
  (typo-global-mode 1)
  (add-hook 'mu4e-compose-mode-hook #'typo-mode)
  (defun aj/toggle-en-sv-typo ()
    (interactive)
    (setq typo-language
          (if (string= typo-language "English")
              "Swedish"
            "English")))
  (bind-key "C-c C-ö" #'aj/toggle-en-sv-typo mu4e-compose-mode-map))
#+END_SRC

*** [[https://github.com/mhayashi1120/Emacs-langtool][Language tool]]
#+BEGIN_SRC emacs-lisp
(use-package langtool
  :bind (("C-x 4 w" . langtool-check)
         ("C-x 4 W" . langtool-check-done)
         ("C-x 4 l" . langtool-switch-default-language)
         ("C-x 4 4" . langtool-show-message-at-point)
         ("C-x 4 c" . langtool-correct-buffer))
  :config
  (setq langtool-language-tool-jar nil
        langtool-java-classpath
        "/usr/share/java/languagetool/*:/usr/share/languagetool"
        langtool-mother-tongue "sv"
        langtool-disabled-rules '("WHITESPACE_RULE"
                                  "EN_QUOTES")))
#+END_SRC

*** Word lookups (definition, translation, synonyms). Use define-word for online word definitions and SDCV for Webster's dictionary installed locally
My extra libraries can be found at:  https://gitlab.com/andersjohansson/define-word-thesaurus and  https://gitlab.com/andersjohansson/define-word-tyda.

Instructions for getting Webster’s dictionary: http://mbork.pl/2017-01-14_I'm_now_using_the_right_dictionary

#+BEGIN_SRC emacs-lisp
(use-package define-word
  :commands (define-word define-word-at-point))

(use-package define-word-thesaurus
  :straight (:host gitlab
                   :repo "andersjohansson/define-word-thesaurus"
                   :files ("*.el" "*.py"))
  :after define-word)
(use-package define-word-tyda
  :straight (:host gitlab :repo "andersjohansson/define-word-tyda")
  :after define-word)
;; (use-package define-word-synonymer
;;   :load-path "~/kodat/elisp/define-word-tyda/"
;;   :after define-word)
(use-package sdcv-mode
  :straight nil
  :commands 'sdcv-search)
(use-package google-translate
  :commands 'google-translate-smooth-translate
  :init (setq google-translate-translation-directions-alist
              '(("sv" . "en") ("en" . "sv") ("da" . "sv"))))

;; needs wn, installed with aur package wordnet-cli
(use-package wordnut)

(defhydra hydra-word-lookup
  (:color blue)
  ("w" sdcv-search "in Webster's")
  ("p" define-word-at-point "word at point")
  ("<RET>" define-word "define word")
  ("t" (define-word (read-from-minibuffer "Tyda: " ) 'tyda) "tyda")
  ("T" (define-word-at-point nil 'tyda) "Tyda at point")
  ("c" (define-word (read-from-minibuffer "Synonymer: " ) 'synonymer) "synonymer")
  ("C" (define-word-at-point nil 'synonymer) "Synonymer at point")
  ("s" (define-word (read-from-minibuffer "Thesaurus: " ) 'thesaurus) "Thesaurus")
  ("S" (define-word-at-point nil 'thesaurus) "Thesaurus at point")
  ("n" wordnut-search "wordnut")
  ("g" google-translate-smooth-translate "Google translate"))

(bind-key "C-x l"  #'hydra-word-lookup/body)
#+END_SRC
** Special modes
*** Extend archive-mode with functions to extract (copy out) single files
Taken from: https://emacs.stackexchange.com/a/3843
#+begin_src emacs-lisp
(with-eval-after-load 'arc-mode
  (define-key archive-mode-map "C" #'aj/archive-extract-marked-to-file)

  (defun aj/archive-extract-marked-to-file (output-dir)
    "Extract marked archive items to OUTPUT-DIR."
    (interactive "GOutput directory: ")
    (let ((command (symbol-value (archive-name "extract")))
          (archive (buffer-file-name))
          (items (archive-get-marked ?* t))) ; get marked items; t means
                                        ; get item under point if
                                        ; nothing is marked
      (dolist (item items)
        (archive-extract-to-file
         archive
         (aref item 0) ; get the name from the descriptor
         command output-dir))))

  (defun aj/archive-extract-to-file (archive-name item-name command dir)
    "Extract ITEM-NAME from ARCHIVE-NAME using COMMAND. Save to
DIR."
    (unwind-protect
        ;; remove the leading / from the file name to force
        ;; expand-file-name to interpret its path as relative to dir
        (let* ((file-name (if (string-match "\\`/" item-name)
                              (substring item-name 1)
                            item-name))
               (output-file (expand-file-name file-name dir))
               (output-dir (file-name-directory output-file)))
          ;; create the output directory (and its parents) if it does
          ;; not exist yet
          (unless (file-directory-p output-dir)
            (make-directory output-dir t))
          ;; execute COMMAND, redirecting output to output-file
          (apply #'call-process
                 (car command)            ;program
                 nil                      ;infile
                 `(:file ,output-file)    ;destination
                 nil                      ;display
                 (append (cdr command) (list archive-name item-name))))
      ;; FIXME: add unwind forms
      nil))
  )
#+end_src

*** Extra definitions for ~auto-mode-alist~
#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist
             '("\\.\\(timer\\|service\\)\\'" . conf-mode))
#+end_src
*** Pdf-view (pdf-tools)
**** Main settings
pdf-loader handles deferred loading. Then settings are applied after loading pdf-view
#+BEGIN_SRC emacs-lisp
(use-package pdf-tools
  :commands pdf-loader-install ;; TODO (fel?)
  :init (pdf-loader-install))

(with-eval-after-load 'pdf-view
  (defun pdf-view-current-pagelabel (&optional window)
    (nth (1- (pdf-view-current-page window)) (pdf-info-pagelabels)))

  (setq-default pdf-view-display-size 'fit-page)
  (add-hook 'pdf-view-mode-hook (lambda () (auto-revert-mode -1) (whole-line-or-region-local-mode -1)))

  (defvar aj/pdf-view-midnight-list
    '(("#282828" . "#f9f5d7")
      ("#fdf4c1" . "#282828")))
  (setq pdf-view-midnight-colors (car aj/pdf-view-midnight-list))

  (defun aj/pdf-view-midnight-toggle ()
    (interactive)
    (when-let ((ind (cl-position pdf-view-midnight-colors
                                 aj/pdf-view-midnight-list
                                 :test 'equal)))
      (setq pdf-view-midnight-colors
            (nth (mod (1+ ind) (length aj/pdf-view-midnight-list))
                 aj/pdf-view-midnight-list))
      (pdf-view-midnight-minor-mode 1)))

  (defvar aj/pdf-hl-color "#DED1EE")
  (defvar aj/pdf-ul-color "#633D91")
  (defvar aj/pdf-ol-color "#9C2F38")
  (defvar aj/pdf-note-color "#77599C")
  (defvar aj/pdf-hl-note-color "#E0EDD1" "used for highlights with notes")
  (setq pdf-annot-default-text-annotation-properties
        `((icon . "Comment")
          (color . ,aj/pdf-note-color)
          (label . ,user-full-name)
          (popup-is-open . nil)
          ;; (subject . "Comment")
          ))
  (defun aj/pdf-hl (edit) (interactive "P")
         (let ((pdf-annot-activate-created-annotations edit))
           (pdf-annot-add-markup-annotation (pdf-view-active-region t) 'highlight aj/pdf-hl-color)))
  (defun aj/pdf-hl-and-copy (edit) (interactive "P")
         (let ((pdf-annot-activate-created-annotations edit))
           (pdf-annot-add-markup-annotation (pdf-view-active-region) 'highlight aj/pdf-hl-color)
           (pdf-view-kill-ring-save)))
  (defun aj/pdf-ul (edit) (interactive "P")
         (let ((pdf-annot-activate-created-annotations edit))
           (pdf-annot-add-markup-annotation (pdf-view-active-region t) 'underline aj/pdf-ul-color)))
  (defun aj/pdf-ol (edit) (interactive "P")
         (let ((pdf-annot-activate-created-annotations edit))
           (pdf-annot-add-markup-annotation (pdf-view-active-region t) 'strike-out aj/pdf-ol-color)))
  (defun aj/pdf-sq (edit) (interactive "P")
         (let ((pdf-annot-activate-created-annotations edit))
           (pdf-annot-add-markup-annotation (pdf-view-active-region t) 'squiggly aj/pdf-ol-color)))
  (defun aj/pdf-hl-note () (interactive)
         (let ((pdf-annot-activate-created-annotations t))
           (pdf-annot-add-markup-annotation (pdf-view-active-region t) 'highlight aj/pdf-hl-note-color)))
  (defun aj/pdf-text (ev) (interactive "e")
         (let* ((pdf-annot-activate-created-annotations t)
                (posn (if (mouse-event-p ev)
                          (event-start ev)
                        (user-error "Not a mouse event")))
                (pw (posn-window posn)))
           ;;(with-current-buffer (window-buffer (posn-window posn))
           (unless (eq (window-buffer pw) (current-buffer))
             (select-window pw))
           (if (eq 'image (car-safe (posn-object posn)))
               (pdf-annot-add-text-annotation posn "Comment" `((color . ,aj/pdf-note-color)))
             (user-error "Not image?"))))
  (bind-keys
   :map pdf-view-mode-map
   ("s a" . pdf-view-auto-slice-minor-mode)
   ("q" . aj/pdf-quit)
   ("w" . aj/pdf-hl-and-copy)
   ;;("w" . aj/pdf-hl-and-copy)
   ("e" . aj/pdf-ul)
   ("r" . aj/pdf-ol)
   ("t" . aj/pdf-sq)
   ("y" . aj/pdf-hl-note)
   ("W" . (lambda () (interactive) (aj/pdf-hl t)))
   ("E" . (lambda () (interactive) (aj/pdf-ul t)))
   ("R" . (lambda () (interactive) (aj/pdf-ol t)))
   ("T" . (lambda () (interactive) (aj/pdf-sq t)))
   ("<C-S-mouse-1>" . aj/pdf-text))

  (defun aj/pdf-quit ()
    (interactive)
    (cl-case (read-char "Really close pdf? ")
      ((?q ?y) (kill-buffer))))

  ;; advice count-words
  (advice-add 'count-words :before-until #'aj/pdf-count-words)
  (defun aj/pdf-count-words (_start _end)
    (when (eq major-mode 'pdf-view-mode)
      (pdf-view-assert-active-region)
      (let ((txt (pdf-view-active-region-text)))
        (with-temp-buffer
          (insert (car txt))
          (count-words--message "PDF region" (point-min) (point-max))
          ))
      t))

  (defun aj/other-window-pdf-next-page (n)
    (interactive "p")
    (when-let ((other-pdf-window
                (or (get-window-with-predicate #'pdf-util-pdf-window-p nil 'thisframe)
                    (get-window-with-predicate #'pdf-util-pdf-window-p nil 'visible))))
      (with-selected-window other-pdf-window
        (with-demoted-errors "%s"
          (pdf-view-next-page n)))))
  (defun aj/other-window-pdf-previous-page (n)
    (interactive "p")
    (aj/other-window-pdf-next-page (- (or n 1))))
  (bind-keys ("M-n" . aj/other-window-pdf-next-page)
             ("M-p" . aj/other-window-pdf-previous-page))


  ;; No scrollbar!
  (add-hook 'pdf-view-mode-hook #'aj/no-scrollbars)
  (defun aj/no-scrollbars ()
    (setq vertical-scroll-bar nil)))
#+END_SRC

**** Multipage view
Package adopted from some code with "issues" from politza. But it initially seems to work ok for getting the pdf "book" experience.

https://github.com/politza/pdf-tools/issues/74#issuecomment-90224020
https://gist.github.com/politza/a3339a4f3b3901fcce4c
#+begin_src emacs-lisp
(use-package pdf-view-multipage
  :straight (:host gitlab :repo "andersjohansson/pdf-view-multipage"))
#+end_src

**** pdf-zotxt-quote
Copying from a pdf with correct org-zotxt references and page numbers
https://gitlab.com/andersjohansson/pdf-zotxt-quote
#+BEGIN_SRC emacs-lisp
(use-package pdf-zotxt-quote
  :straight nil
  :load-path ("~/kodat/elisp/pdf-zotxt-quote/" "~/kodat/elisp/zotxt-emacs/")
  :commands pdf-zotxt-quote-mode
  :custom (pdf-zotxt-quote-fill-column 999999))
#+END_SRC

** Display customizations: theme, modeline, etc.
*** Variable pitch
I want to use variable pitch for most things. But changing the default face to a variable pitch font is not a good idea, since so many tabular modes etc. depend on a monospace font. Setting it for ~prog-mode~, ~text-mode~ and in the modeline is good though.

#+begin_src emacs-lisp
(add-hook 'prog-mode-hook #'variable-pitch-mode)
(add-hook 'text-mode-hook #'variable-pitch-mode)
(set-face-attribute 'mode-line nil :family "Input Sans Condensed")
(set-face-attribute 'mode-line-inactive nil :family "Input Sans Condensed")
#+end_src
*** Document font
When editing longer text documents in org mode (or perhaps LaTeX) it’s good to use a nice sans serif like ET Book (https://github.com/edwardtufte/et-book).
This code defines a mode for doing a a local remapping to do that in a buffer.
Heavily inspired by the package ~mixed-pitch~ (https://gitlab.com/jabranham/mixed-pitch).
But also with some inspiration from here: https://lepisma.github.io/2017/10/28/ricing-org-mode/

#+begin_src emacs-lisp
(use-package doc-font
  ;; in /lisp
  :straight nil
  :commands doc-font-mode)
#+end_src

*** Toggle font size
Sometimes I feel the need for a generally bigger font. Especially when switching between my 13 inch 1920*1080-screen and my 24 inch 1920*1080-screen (systemwide screenwise fractional scaling is still not an option on linux).
#+begin_src emacs-lisp
(defvar aj/orig-font-size nil)

(add-hook 'after-init-hook (lambda () (setq aj/orig-font-size (face-attribute 'default :height))))

(defun aj/toggle-font-size ()
  (interactive)
  (if (> 7 (abs (- aj/orig-font-size (face-attribute 'default :height))))
      (set-face-attribute 'default nil :height 135)
    (set-face-attribute 'default nil :height aj/orig-font-size)))

(bind-key "C-s-T" #'aj/toggle-font-size)
#+end_src


*** Flash active window :ARCHIVE:
Another way of finding the active buffer, well I don’t use it right now.
https://gist.github.com/anonymous/d87a27cc544cb4dd2bb1
#+BEGIN_SRC emacs-lisp
(bind-key "M-å" 'aj/flash-active-buffer)

(make-face 'aj/flash-active-buffer-face)
(set-face-attribute 'aj/flash-active-buffer-face nil
                    :inherit 'highlight)
(defun aj/flash-active-buffer ()
  (interactive)
  (run-at-time 0.2 nil
               (lambda (remap-cookie)
                 (face-remap-remove-relative remap-cookie))
               (face-remap-add-relative 'default 'flash-active-buffer-face)))
#+END_SRC
*** Beacon :ARCHIVE:
A way of higlighting where you are, don’t use it now.
#+BEGIN_SRC emacs-lisp
(use-package beacon
  :defer 3
  :config (setq beacon-blink-duration 0.2
                beacon-blink-delay 0.1
                beacon-size 40
                beacon-color "#93a1a1")
  (dolist (l '(scroll-down-line scroll-up-line))
    (add-to-list 'beacon-dont-blink-commands l))
  (beacon-mode 1))
#+END_SRC
*** Stripe-buffer :ARCHIVE:
#+BEGIN_SRC emacs-lisp
(use-package stripe-buffer
  :config (progn
            (add-hook 'dired-mode-hook 'turn-on-stripe-buffer-mode)
            (add-hook 'org-mode-hook 'turn-on-stripe-table-mode)))
#+END_SRC
*** all the icons
**** Base package
#+BEGIN_SRC emacs-lisp
(use-package all-the-icons)
#+END_SRC

**** All the icons dired
Pretty icons in dired!

Also a hack to make it work with ~dired-subtree~, however this adds double icons when reverting a buffer with inserted subtrees.
#+BEGIN_SRC emacs-lisp
(use-package all-the-icons-dired
  :init (add-hook 'dired-mode-hook #'all-the-icons-dired-mode)
  :config
  (add-hook 'dired-subtree-after-insert-hook #'all-the-icons-dired--refresh)
  (add-hook 'dired-subtree-after-remove-hook #'all-the-icons-dired--refresh))
#+END_SRC

*** Modeline
**** mini-modeline + doom-modeline
#+BEGIN_SRC emacs-lisp
(use-package eldoc-eval)
(use-package doom-modeline
  :demand t
  :straight (doom-modeline :fork (:host github :repo "andersjohansson/doom-modeline" :branch "mini-modeline"))
  :custom
  (doom-modeline-buffer-file-name-style 'truncate-all)
  ;; (doom-modeline-bar-width (frame-parameter nil 'left-fringe))
  (doom-modeline-height 10)
  (doom-modeline-icon t)
  (doom-modeline-icons-scale-factor 0.75)
  (doom-modeline-icons-v-adjust-factor 0.75)
  :config

  (set-face-attribute 'doom-modeline nil :inherit 'default)
  (set-face-attribute 'doom-modeline-inactive nil :inherit 'default)

  ;;   ;; pdf pages with pagelabels
  (advice-add 'doom-modeline-update-pdf-pages :override #'aj/doom-modeline-update-pdf-pages)

  (defun aj/doom-modeline-update-pdf-pages ()
    "Update PDF pages. Use pagelabels if available."
    (setq doom-modeline--pdf-pages
          (let* ((cp (eval `(pdf-view-current-page)))
                 (physical (format "%d/%d"
                                   cp
                                   (pdf-cache-number-of-pages)))
                 (currlabel (pdf-view-current-pagelabel)))

            (propertize
             (if (equal currlabel (number-to-string cp))
                 (concat " P: " physical " ")
               (concat " P:" currlabel " (" physical ") "))
             'face (if (doom-modeline--active)
                       'mode-line
                     'mode-line-inactive)))))
  )

(use-package mini-modeline
  :straight (mini-modeline :fork (:host github :repo "andersjohansson/mini-modeline" :branch "buffer-local-formats"))
  :after doom-modeline
  :hook (after-init . mini-modeline-mode)
  :config
  (doom-modeline-def-modeline 'minibuffer-line
    '(workspace-name window-number matches buffer-info remote-host buffer-position word-count parrot selection-info objed-state misc-info persp-name battery grip irc mu4e gnus github debug lsp minor-modes input-method indent-info buffer-encoding major-mode process vcs checker))

  (setq mini-modeline-r-format (doom-modeline-format--minibuffer-line))

  (setq mini-modeline-right-padding 1
        mini-modeline-enhance-visual nil)

  (set-face-attribute 'mode-line nil :box t)
  (set-face-attribute 'mini-modeline-mode-line nil
                      :background (face-background 'modus-theme-intense-blue) :height 0.2)
  (set-face-attribute 'mini-modeline-mode-line-inactive nil
                      :background (face-background 'fringe) :height 0.2)

  (defun doom-modeline-segment--bar ()
    "Don’t show the bar when using mini-modeline"
    "")

  ;; use some special doom-modelines
  (defun aj/mini-modeline-set-doom-special (key)
    (when-let ((modeline (doom-modeline key)))
      (setq-local mini-modeline-r-format modeline)))

  (add-hook 'Info-mode-hook (lambda () (aj/mini-modeline-set-doom-special 'info)))
  (add-hook 'pdf-view-mode-hook (lambda () (aj/mini-modeline-set-doom-special 'pdf)))
  (add-hook 'dired-mode-hook (lambda () (aj/mini-modeline-set-doom-special 'project)))
  (add-hook 'dashboard-mode-hook (lambda () (aj/mini-modeline-set-doom-special 'project)))
  (add-hook 'image-mode-hook (lambda () (aj/mini-modeline-set-doom-special 'media)))
  (add-hook 'mu4e-compose-mode-hook (lambda () (aj/mini-modeline-set-doom-special 'message)))
  (add-hook 'git-commit-mode-hook (lambda () (aj/mini-modeline-set-doom-special 'message)))
  (add-hook 'magit-mode-hook (lambda () (aj/mini-modeline-set-doom-special 'vcs)))
  (add-hook 'org-src-mode-hook (lambda () (aj/mini-modeline-set-doom-special 'org-src)))
  (add-hook 'git-timemachine-mode-hook (lambda () (aj/mini-modeline-set-doom-special 'timemachine)))
  (add-hook 'xwidget-webkit-mode-hook (lambda () (aj/mini-modeline-set-doom-special 'minimal)))


  ;; show modeline for helm, it displays some needed info, like when
  ;; grep is finished running etc. Use doom-modeline for this.

  (advice-add #'helm-display-mode-line :after #'aj/visible-helm-modeline)
  (defun aj/visible-helm-modeline (&rest _)
    (with-helm-buffer
      (setq-local face-remapping-alist
                  '((mode-line . mode-line)
                    (doom-modeline . mode-line))))
    (doom-modeline-set-helm-modeline))

  )


;; (add-hook 'window-buffer-change-functions #'aj/no-face-remapping-in-minibuffer)
;; (defun aj/no-face-remapping-in-minibuffer (_frame)
;;   (when-let ((win (minibuffer-window))
;;              (buf (window-buffer win)))
;;     (with-current-buffer buf
;;       (set (make-local-variable 'face-remapping-alist)
;;            '((mode-line default)
;;              (mode-line-inactive default))))))


;; (use-package doom-modeline
;;   :defer t
;;   ;; :hook (after-init . doom-modeline-mode)
;;   :custom
;;   (doom-modeline-buffer-file-name-style 'truncate-all)
;;   (doom-modeline-bar-width (frame-parameter nil 'left-fringe))
;;   (doom-modeline-height 32)
;;   :config
;;   ;; shorten filenames when the window is narrow
;;   ;; (defun aj/doom-modeline-shorten-file-name (name)
;;   ;;   (let ((limit (/ (window-text-width) 3)))
;;   ;;     (if (< limit (length name))
;;   ;;         (concat (substring name 0 (1- limit)) " ⋯")
;;   ;;       name)))

;;   ;; (advice-add 'doom-modeline-update-buffer-file-name :override #'aj/doom-modeline-update-buffer-file-name)
;;   ;; (add-hook 'window-configuration-change-hook #'doom-modeline-update-buffer-file-name)

;;   ;; (defun aj/doom-modeline-update-buffer-file-name (&rest _)
;;   ;;     "Update buffer file name in mode-line."
;;   ;;     (setq doom-modeline--buffer-file-name
;;   ;;           (ignore-errors
;;   ;;             (save-match-data
;;   ;;               (if buffer-file-name
;;   ;;                   (aj/doom-modeline-shorten-file-name (doom-modeline-buffer-file-name))
;;   ;;                 (propertize (aj/doom-modeline-shorten-file-name (buffer-name))
;;   ;;                             'face (if (doom-modeline--active)
;;   ;;                                       'doom-modeline-buffer-file
;;   ;;                                     'mode-line-inactive)
;;   ;;                             'help-echo "Buffer name
;;   ;; mouse-1: Previous buffer\nmouse-3: Next buffer"
;;   ;;                             'local-map mode-line-buffer-identification-keymap))))))



;;   )
#+END_SRC

**** Moody :ARCHIVE:
#+BEGIN_SRC emacs-lisp
(use-package moody
  :config
  (setq x-underline-at-descent-line t)
  (setq moody-mode-line-height 26)
  ;; (moody-replace-mode-line-buffer-identification)
  ;; (moody-replace-vc-mode)
  :init
  (add-hook 'aj/face-definitions-hook #'aj/modeline-fix)

  (defun aj/modeline-fix (&optional theme)
    (when (aj/solarized-theme-p theme)
      (let ((line (face-attribute 'mode-line :underline)))
        (set-face-attribute 'mode-line          nil :overline line :box nil)
        (set-face-attribute 'mode-line-inactive nil :overline line :underline line :box nil)))))
#+END_SRC

**** [[https://github.com/TheBB/spaceline/][spaceline]] :ARCHIVE:
#+BEGIN_SRC emacs-lisp
(use-package spaceline-config
  :ensure spaceline
  :defer 3
  :config
  (setq spaceline-responsive t)
  (spaceline-helm-mode)
  (spaceline-info-mode)
  ;; (spaceline-emacs-theme)
  )
#+END_SRC

**** Spaceline all the icons :ARCHIVE:
#+BEGIN_SRC emacs-lisp
(use-package spaceline-all-the-icons
  :after spaceline
  :config
  (setq
   spaceline-all-the-icons-flycheck-alternate t
   spaceline-all-the-icons-clock-always-visible nil
   spaceline-all-the-icons-hide-long-buffer-path t
   spaceline-all-the-icons-buffer-path-p t
   spaceline-all-the-icons-highlight-file-name t
   powerline-default-separator nil
   spaceline-all-the-icons-separator-type 'none
   spaceline-all-the-icons-minor-modes-p t)

  (solarized-with-color-variables 'light
    (setq spaceline-all-the-icons-file-name-highlight base1))

  ;; Better conditions
  (put 'spaceline-all-the-icons-time-p :when
       '(or spaceline-all-the-icons-clock-always-visible
            (eq 'fullboth (frame-parameter nil 'fullscreen))))
  (put 'spaceline-all-the-icons-battery-status-p :when
       '(and active (bound-and-true-p fancy-battery-mode)
             (eq 'fullboth (frame-parameter nil 'fullscreen))))


  (put 'spaceline-all-the-icons-region-info-p :when
       '(and mark-active (not (eq major-mode 'pdf-view-mode))))
  ;; support pdf
  (spaceline-define-segment all-the-icons-position-aj
    "An `all-the-icons' Line & Column indicator"
    (propertize (if (eq major-mode 'pdf-view-mode)
                    (spaceline--pdfview-page-number)
                  (format-mode-line "%l:%2c"))

                'face `(:height ,(spaceline-all-the-icons--height 0.9) :inherit)
                'display '(raise 0.1))
    :tight t
    :priority -0.5)

  ;; shorten long buffer names:
  (spaceline-define-segment all-the-icons-buffer-id-aj
    "An `all-the-icons' segment to display current buffer id"
    (let* ((height (if spaceline-all-the-icons-slim-render 1.0 0.8))
           (raise  (if spaceline-all-the-icons-slim-render 0.1 0.2))

           (help-echo (format "Major-mode: `%s'" major-mode))

           (file-face `(:height ,(spaceline-all-the-icons--height height)))
           (show-path? (and active
                            spaceline-all-the-icons-buffer-path-p
                            (spaceline-all-the-icons--buffer-path)
                            (not spaceline-all-the-icons-slim-render)))

           (have-projectile? (and (fboundp 'projectile-project-p) (projectile-project-p)))
           (show-projectile? (and spaceline-all-the-icons-projectile-p have-projectile?))

           (buffer-id (if (and (buffer-file-name)
                               (or show-path? show-projectile?))
                          (file-name-nondirectory (buffer-file-name))
                        (format-mode-line "%b")))
           (limit (/ (window-text-width) 5))
           (buffer-id (if (< limit (length buffer-id))
                          (concat (substring buffer-id 0 (1- limit)) " ⋯")
                        buffer-id))

           (mouse-f (if have-projectile? 'projectile-find-file 'find-file)))

      (if (not (and spaceline-all-the-icons-highlight-file-name
                    show-path?))
          (add-to-list 'file-face :inherit t)
        (setq file-face (append `(:background ,(spaceline-all-the-icons--face-background default-face)) file-face))
        (setq file-face (append `(:foreground ,(or spaceline-all-the-icons-file-name-highlight
                                                   (spaceline-all-the-icons--face-background highlight-face))) file-face)))

      (propertize buffer-id
                  'face file-face
                  'display `(raise ,raise)
                  'help-echo help-echo
                  'mouse-face (spaceline-all-the-icons--highlight)
                  'local-map (make-mode-line-mouse-map 'mouse-1 mouse-f)))
    :tight t)


  ;; (spaceline-define-segment aj/all-the-icons-mode-icon
  ;;   "An `all-the-icons' segment indicating the current buffer's mode with an icon"
  ;;   (let ((icon (all-the-icons-icon-for-mode major-mode)))
  ;;     (unless (symbolp icon)
  ;;       (propertize icon
  ;;                   'help-echo (format "Major-mode: `%s'" major-mode)
  ;;                   'display '(raise 0)
  ;;                   'face `(:height ,(spaceline-all-the-icons--height 1.0)
  ;;                                   ,@(get-text-property 0 'face icon)
  ;;                                   ;; :inherit (powerline-active1)
  ;;                                   )))))


  (defun aj/spaceline-all-the-icons-theme (&rest additional-segments)
    "Install the `spaceline-ml-all-the-icons'.
Add ADDITIONAL-SEGMENTS to the end of the theme."
    (interactive)
    (spaceline-compile
      "all-the-icons"
      '((all-the-icons-anzu
         :face mode-line
         :skip-alternate t)

        ((all-the-icons-modified
          all-the-icons-bookmark
          all-the-icons-dedicated
          all-the-icons-window-number
          all-the-icons-eyebrowse-workspace
          all-the-icons-buffer-size) :face highlight-face :skip-alternate t)

        ;; all-the-icons-separator-left-active-1

        (all-the-icons-mode-icon
         ((all-the-icons-buffer-path
           all-the-icons-buffer-id-aj) :separator ""))

        ;; all-the-icons-separator-left-extra-2

        ;; all-the-icons-separator-left-extra-1
        ;; all-the-icons-separator-left-inactive

        (all-the-icons-minor-modes :separator " " :priority -0.1)

        ((all-the-icons-vc-icon
          all-the-icons-vc-status
          all-the-icons-git-ahead
          all-the-icons-git-status
          all-the-icons-flycheck-status
          all-the-icons-package-updates)
         ;; :face other-face
         :separator (spaceline-all-the-icons--separator
                     spaceline-all-the-icons-secondary-separator " ")
         :priority 0.5)

        (((all-the-icons-position-aj :priority -1)
          ((all-the-icons-process
            all-the-icons-region-info
            all-the-icons-text-scale)
           :priority 0.0)
          (all-the-icons-narrowed :priority -1))
         :separator (spaceline-all-the-icons--separator
                     spaceline-all-the-icons-primary-separator " "))

        ;; all-the-icons-separator-left-extra-2
        ;; all-the-icons-separator-left-inactive
        ;; all-the-icons-separator-right-active-1

        ((all-the-icons-which-function)
         :separator ""))

      ;; right
      `((spaceline-mu4e-alert-segment :when active :priority 1)
        (global :when active :priority 1)


        ((((org-pomodoro
            (all-the-icons-org-clock-current-task
             :global-override 'org-mode-line-string))
           :priority -0.7)
          all-the-icons-battery-status
          all-the-icons-time)
         :separator " " ;; (spaceline-all-the-icons--separator spaceline-all-the-icons-primary-separator " ")
         ;; :face default-face
         :when active
         :priority 0)))
    (setq-default mode-line-format spaceline-all-the-icons-theme))

  (aj/spaceline-all-the-icons-theme)

  (spaceline-all-the-icons--setup-anzu)
  (spaceline-toggle-all-the-icons-narrowed-on)
  )
#+END_SRC
***** Weather :ARCHIVE:
#+BEGIN_SRC emacs-lisp
(use-package yahoo-weather
  :after spaceline-all-the-icons
  :config (yahoo-weather-mode))
#+END_SRC

*** Themes
**** My own face definitions
Load my own face customizations after enabling a theme.
#+BEGIN_SRC emacs-lisp
(defun aj/apply-face-definitions (&optional theme)
  "Do face definition stuff after loading theme.
Also runs hook aj/face-definitions-hook."
  (unless (eq theme 'user) ;enable theme calls itself with user theme.

    ;; (set-face-attribute 'scroll-bar nil :foreground (face-attribute 'widget-field :background))

    (with-eval-after-load 'org-faces

      (set-face-attribute 'org-document-title nil :height 1.5 :weight 'bold)
      ;; (set-face-attribute 'org-meta-line nil :inherit 'org-drawer)

      (set-face-attribute 'org-block-begin-line nil :height 0.9 :extend t)
      ;; (set-face-attribute 'org-block-end-line nil :height 0.9 :extend t)
      (set-face-attribute 'org-block nil :extend t)

      (set-face-attribute 'org-quote nil :weight 'light :height 0.95 :inherit 'default)
      (set-face-attribute 'org-verse nil :inherit 'org-table)

      ;; (set-face-attribute 'org-special-keyword nil :weight 'normal :inherit 'shadow)

      ;; Use fixed-pitch for checkbox, compressed font for table
      (set-face-attribute 'org-checkbox nil :inherit 'fixed-pitch)
      (set-face-attribute 'org-table nil :family "Input Mono Compressed")

      (when (eq theme 'modus-operandi)
        (set-face-attribute 'org-block nil :background "#f8f8f8")
        (dolist (n '("1" "2" "3" "4" "5" "6" "7" "8"))
          (set-face-attribute (intern (concat "org-level-" n)) nil :weight 'light))

        ;; avoid tags inheriting headline color, make them bold but subdued.
        (set-face-attribute 'org-tag nil :foreground 'unspecified :inherit 'shadow :weight 'normal)
        )
      ;; level colors in gruvbox are bad... (I don’t like the red...)
      ;; (when (eq theme 'gruvbox-light-hard)
      ;;   (gruvbox-light-hard-with-palette
      ;;    (set-face-attribute 'org-level-1 nil :foreground gruvbox-bright_blue)
      ;;    (set-face-attribute 'org-level-2 nil :foreground gruvbox-bright_aqua)
      ;;    (set-face-attribute 'org-level-3 nil :foreground gruvbox-bright_purple)
      ;;    (set-face-attribute 'org-level-4 nil :foreground gruvbox-bright_green)
      ;;    (set-face-attribute 'org-level-5 nil :foreground gruvbox-bright_yellow)
      ;;    (set-face-attribute 'org-level-6 nil :foreground gruvbox-bright_orange)
      ;;    (set-face-attribute 'org-level-7 nil :foreground gruvbox-faded_blue)
      ;;    (set-face-attribute 'org-level-8 nil :foreground gruvbox-faded_aqua)))

      ;; specific for solarized
      ;; level colors in solarized are bad (demote red)
      ;; (when (aj/solarized-theme-p)
      ;;   (solarized-with-color-variables 'dark
      ;;                                   (set-face-attribute 'org-level-1 nil :foreground violet)
      ;;                                   (set-face-attribute 'org-level-2 nil :foreground blue)
      ;;                                   (set-face-attribute 'org-level-3 nil :foreground cyan)
      ;;                                   (set-face-attribute 'org-level-4 nil :foreground green)
      ;;                                   (set-face-attribute 'org-level-5 nil :foreground yellow)
      ;;                                   (set-face-attribute 'org-level-6 nil :foreground orange)
      ;;                                   (set-face-attribute 'org-level-7 nil :foreground red)
      ;;                                   (set-face-attribute 'org-level-8 nil :foreground magenta)))
      )

    ;; (cond
    ;;  ((eq theme 'solarized-light)
    ;;   (setq org-n-level-faces 8))
    ;;  ((eq theme 'solarized-dark)
    ;;   ;; the yellow-red ones are garish contrast-colors to the background
    ;;   (setq org-n-level-faces 4)))

    ;; the thing solarized does with mode-line underline is bad.
    ;; (when (member theme '(solarized-dark solarized-light))
    ;;   (set-face-attribute 'mode-line nil :underline nil :overline nil)
    ;;   (set-face-attribute 'mode-line-inactive nil :underline nil :overline nil)
    ;;   (set-face-attribute 'header-line nil :underline nil :overline nil))

    (with-eval-after-load 'idle-highlight-mode
      (set-face-attribute 'idle-highlight nil :inherit nil :underline t))

    ;; (with-eval-after-load 'org-inlinetask
    ;;   (set-face-attribute 'org-inlinetask nil :inherit 'org-level-5))

    (run-hook-with-args 'aj/face-definitions-hook theme)))

(advice-add 'enable-theme :after #'aj/apply-face-definitions)
#+END_SRC
**** Gruvbox
#+BEGIN_SRC emacs-lisp
(use-package gruvbox
  :straight (gruvbox-theme
             :depth nil
             :fork (:host github :repo "andersjohansson/emacs-theme-gruvbox" :branch "ajfixes2")))
#+END_SRC
**** Modus-operandi theme
#+begin_src emacs-lisp
(use-package modus-operandi-theme
  :custom (modus-operandi-theme-visible-fringes t))
#+end_src
**** Define themes to use for dark and light and load light theme
#+BEGIN_SRC emacs-lisp
(defvar aj/light-theme 'modus-operandi
  ;; 'gruvbox-light-hard
  )
(defvar aj/dark-theme 'gruvbox-dark-medium)

(load-theme aj/light-theme)
;; I’m not loading dark theme here, since I seldom use it.
#+END_SRC
**** Dark-light-switching
#+BEGIN_SRC emacs-lisp
(defun aj/toggle-light-dark ()
  "Toggles light and dark solarized theme in Emacs and Arc theme in gtk."
  (interactive)
  (cond
   ((custom-theme-enabled-p aj/light-theme)
    (disable-theme aj/light-theme)
    (unless (custom-theme-p aj/dark-theme)
      ;; I seldom use the dark theme, so now is the time to load it
      (load-theme aj/dark-theme t t))
    (enable-theme aj/dark-theme)
    (call-process-shell-command
     "xfconf-query -c xsettings -p /Net/ThemeName -s \"Arc-Dark\""
     ;; for gnome:
     ;; "dconf write /org/gnome/desktop/interface/gtk-theme \"'Arc-Dark'\""
     ))
   ((custom-theme-enabled-p aj/dark-theme)
    (disable-theme aj/dark-theme)
    (enable-theme aj/light-theme)
    (call-process-shell-command
     "xfconf-query -c xsettings -p /Net/ThemeName -s \"Arc\""
     ;; "dconf write /org/gnome/desktop/interface/gtk-theme \"'Arc'\""
     ))
   (t
    (enable-theme 'aj/light-theme))))

(bind-key "S-<f11>" #'aj/toggle-light-dark)
#+END_SRC
**** Base 16 :ARCHIVE:
Works ok... But also here, too bright oranges
Which are nice?
- Dark
  + base16-materia
  + base16-material (similar)
- light
  + mexico-light
  + tomorrow


#+BEGIN_SRC emacs-lisp
(use-package base16-theme
  :config
  (load-theme 'base16-mexico-light t))
#+END_SRC
**** Tomorrow :ARCHIVE:
Is almost good, but it lacks some definitions, and the yellow and orange have bad contrast against white (too bright)
#+BEGIN_SRC emacs-lisp
(use-package color-theme-sanityinc-tomorrow
:init (load-theme 'sanityinc-tomorrow-day))

#+END_SRC
**** bbatsov’s solarized :ARCHIVE:
#+begin_src emacs-lisp
(use-package solarized-theme
  :init
  (setq solarized-scale-org-headlines nil
        solarized-distinct-fringe-background t
        solarized-high-contrast-mode-line nil)
  (load-theme 'solarized-light))
#+end_src
**** sellout’s solarized :ARCHIVE:
I actually liked this more, especially the unified-branch which I used here. But it has kind of stagnated, and has so few definitions.
#+BEGIN_SRC emacs-lisp
(use-package solarized-definitions
  :if (display-graphic-p)
  :load-path "~/kodat/elisp/emacs-color-theme-solarized/"
  :demand t
  :init (add-to-list 'custom-theme-load-path
                     "~/kodat/elisp/emacs-color-theme-solarized/"))
(when (display-graphic-p)
  (setq frame-background-mode 'light)
  (load-theme 'solarized t)
  (mapc 'frame-set-background-mode (frame-list))

  (defun toggle-night-color-theme ()
    "Switch to/from night color scheme."
    (interactive)
    (if (eq frame-background-mode 'dark)
        (progn
          (setq frame-background-mode 'light)
          (setq pdf-view-midnight-colors '("#657b83" . "#fdf6e3")))
      (setq frame-background-mode  'dark)
      (setq pdf-view-midnight-colors '("#839496" . "#002b36" )))

    (load-theme 'solarized)
    (mapc 'frame-set-background-mode (frame-list))
    (powerline-reset)
    (aj/apply-face-definitions))
  (bind-key "<f9>" 'toggle-night-color-theme))
#+END_SRC


*** Hl-line
#+begin_src emacs-lisp
(add-hook 'prog-mode-hook 'hl-line-mode)
#+end_src

*** Cursor
#+begin_src emacs-lisp
(setq-default cursor-type 'bar)
(setq-default cursor-in-non-selected-windows 'hollow)
(blink-cursor-mode -1)
(setq blink-cursor-alist '((bar . (bar . 1))))
#+end_src

*** Fullscreen toggling
#+begin_src emacs-lisp
(defvar aj/last-fullscreen-param nil)

(defun aj/toggle-fullscreen ()
  (interactive)
  (let ((current-value (frame-parameter nil 'fullscreen)))
    (set-frame-parameter nil 'fullscreen
                         (if (equal 'fullboth current-value)
                             aj/last-fullscreen-param

                           (setq aj/last-fullscreen-param current-value)
                           'fullboth))))

(bind-key "<f11>" #'aj/toggle-fullscreen)
#+end_src

*** Writeroom
#+BEGIN_SRC emacs-lisp
(use-package writeroom-mode
  :commands writeroom-mode
  :bind ("<f12>" . writeroom-mode)
  :config (setq writeroom-width 80
                writeroom-mode-line t
                writeroom-extra-line-spacing 0.1
                writeroom-global-effects '(writeroom-set-fullscreen)))
#+END_SRC

*** Hide mode-line
#+begin_src emacs-lisp
(use-package hide-mode-line
  :defer t)
#+end_src

*** Readable-frame :ARCHIVE:
With some inspiration from here: https://lepisma.github.io/2017/10/28/ricing-org-mode/
Launches a frame with a serif font and writeroom, to read texts in org-mode.
#+BEGIN_SRC emacs-lisp
(use-package reading-frame
  :load-path "~/kodat/elisp/reading-frame/"
  :commands reading-frame-make-frame)
#+END_SRC

*** Colours in shell output
From: http://stackoverflow.com/questions/4726220/how-to-have-colors-in-the-output-of-emacs-shell-command/4729543#4729543
#+begin_src emacs-lisp
(use-package ansi-color
  :commands (ansi-color-apply-on-region ansi-color-make-color-map))

(defadvice display-message-or-buffer (before ansi-color activate)
  "Process ANSI color codes in shell output."
  (let ((buf (ad-get-arg 0)))
    (and (bufferp buf)
         (string= (buffer-name buf) "*Shell Command Output*")
         (with-current-buffer buf
           (ansi-color-apply-on-region (point-min) (point-max))))))
#+end_src


** Special libraries for research :org_async:
*** aj-forskning
Some special functions for managing my data files.
#+begin_src emacs-lisp
(use-package aj-forskning ;; private package
  :straight nil
  :commands (ajf/mount-forskningsdata ajf/swap-quotes-cycle aj/repeat-last-words))

;;; font-lock () och {}
(with-eval-after-load 'org
  (defvar ajf/font-lock-brackets-keywords
	'(("{[^}]+}" (0 '(face font-lock-type-face) append))
	  ("([^)]+)" (0 '(face font-lock-variable-name-face) append))))

  (defun ajf/font-lock-brackets ()
	(dolist (el ajf/font-lock-brackets-keywords)
	  (add-to-list 'org-font-lock-extra-keywords el t)))

  (add-hook 'org-font-lock-set-keywords-hook #'ajf/font-lock-brackets))
#+end_src

*** mplayer-mode
I use my fork, available here: https://github.com/andersjohansson/mplayer-mode/tree/org-sessions
(it’s messy and mixes up too many things in my current opinion...)
#+BEGIN_SRC emacs-lisp
(use-package mplayer-mode
  :straight (:host github :repo "andersjohansson/mplayer-mode" :depth full :branch "org-sessions")
  :defer t
  :config (setq mplayer-display-time-in-modeline nil
				mplayer-default-seek-step 3))
#+END_SRC

*** orgqda-helm-tags
Available at: https://github.com/andersjohansson/orgqda
#+BEGIN_SRC emacs-lisp
(use-package orgqda-helm-tags
  :straight nil
  :after orgqda
  :hook (org-mode . orgqda-helm-tags-mode)
  :config (setq orgqda-helm-tags-include-excluded t))
#+END_SRC

*** orgqda-transcript
Also at: https://github.com/andersjohansson/orgqda
#+BEGIN_SRC emacs-lisp
(use-package orgqda-transcript
  :straight nil ;; in orgqda
  :defer t
  :custom
  (orgqda-transcript-bind-fn-keys t)
  (orgqda-transcript-bind-1-4-keys t)
  (orgqda-transcript-set-up-speaker-keys t)
  (orgqda-transcript-set-up-speaker-keys-5-9 t)
  (orgqda-transcript-rebind-c-s-ret t)
  (orgqda-transcript-rebind-s-ret t)

  :config
  (defun aj/q-hydra-pre ()
    (undo-boundary)
    (insert "q"))
  (defhydra aj/q-hydra (:body-pre aj/q-hydra-pre
                                  :color blue
                                  :timeout 1)
    "other: "
    ("y" (progn (zap-to-char -1 ?q) (orgqda-transcript-insert-parenthesis-other-speaker "yeah")) "yeah")
    ("2" (progn (zap-to-char -1 ?q) (orgqda-transcript-insert-parenthesis-other-speaker "yeah yeah")) "yeah yeah")
    ("3" (progn (zap-to-char -1 ?q) (orgqda-transcript-insert-parenthesis-other-speaker "yeah yeah yeah")) "yeah yeah yeah")
    ("4" (progn (zap-to-char -1 ?q) (orgqda-transcript-insert-parenthesis-other-speaker "yeah yeah yeah yeah")) "yeah yeah yeah yeah")
    ("o" (progn (zap-to-char -1 ?q) (orgqda-transcript-insert-parenthesis-other-speaker "ok")) "ok")
    ("i" (progn (zap-to-char -1 ?q) (orgqda-transcript-insert-parenthesis-other-speaker "oh yeah")) "oh yeah")
    ("å" (progn (zap-to-char -1 ?q) (orgqda-transcript-insert-parenthesis-other-speaker "ok yeah")) "ok yeah")
    ("n" (progn (zap-to-char -1 ?q) (orgqda-transcript-insert-parenthesis-other-speaker "mhm")) "mhm")
    ("m" (progn (zap-to-char -1 ?q) (orgqda-transcript-insert-parenthesis-other-speaker "mmm")) "mmm")
    ("l" (progn (zap-to-char -1 ?q) (insert "(laugh)")))
    ("c" (progn (zap-to-char -1 ?q) (insert "[country]")))
    ("C" (progn (zap-to-char -1 ?q) (insert "[city]"))))

  (define-key orgqda-transcript-mode-map "q" #'aj/q-hydra/body)

  ;; (defun aj/say-yeah (&optional arg)
  ;;   (interactive "P")
  ;;   (zap-to-char -1 ?q)
  ;;   (orgqda-transcript-insert-parenthesis-other-speaker
  ;;    (pcase arg
  ;;      ('(4) "yeah yeah")
  ;;      ('(16) "yeah yeah yeah")
  ;;      ((pred integerp) (s-repeat arg "yeah "))
  ;;      (_ "yeah"))))

  (defhydra aj/hydra-mplayer (:color blue)
    ("SPC"     #'mplayer-toggle-pause "pause")
    ("RET"     #'mplayer-toggle-pause-with-rewind "pause rew")
    ("<right>" #'mplayer-seek-forward "forward" :color pink)
    ("<left>"  #'mplayer-seek-backward "backward" :color pink)
    ("f"       #'mplayer-faster "faster" :color pink)
    ("s"       #'mplayer-slower "slower":color pink)
    ("r"       #'mplayer-reset-speed "reset speed")
    ("p"       #'mplayer-seek-position "seek pos")
    ("g"       #'mplayer-seek-timestamp "seek ts")
    ("t"       #'mplayer-insert-position "insert pos")
    ("d"       #'mplayer-toggle-osd "toggle osd")
    ("i"       #'mplayer-insert-timestamp "insert ts")
    ("Q"       #'mplayer-quit-mplayer "Quit mplayer")
    ("q" nil))

  (define-key orgqda-transcript-mode-map (kbd "C-c m") #'aj/hydra-mplayer/body)

  ;; (defvar aj/mplayer-last-seek-f (current-time))
  ;; (defvar aj/mplayer-number-of-seeks-f 0)
  ;; (defvar aj/mplayer-last-seek-b (current-time))
  ;; (defvar aj/mplayer-number-of-seeks-b 0)
  ;; (defvar aj/mplayer-seek-sequence '(0 .9 1.5 2 4))
  ;; (put 'aj/mplayer-seek-sequence 'safe-local-variable
  ;;      (lambda (x) (cl-every #'numberp x)))

  ;; (defun aj/mplayer-seek-backward ()
  ;;   (interactive)
  ;;   (if (and (eq last-command 'aj/mplayer-seek-backward)
  ;;            (> 1.0 (float-time (time-subtract (current-time) aj/mplayer-last-seek-b))))
  ;;       (cl-incf aj/mplayer-number-of-seeks-b)
  ;;     (setq aj/mplayer-number-of-seeks-b 1))
  ;;   (mplayer-seek-backward
  ;;    (or (nth aj/mplayer-number-of-seeks-b aj/mplayer-seek-sequence) 5))
  ;;   (setq aj/mplayer-last-seek-b (current-time)))

  ;; (defun aj/mplayer-seek-forward ()
  ;;   (interactive)
  ;;   (if (and (eq last-command 'aj/mplayer-seek-forward)
  ;;            (> 1.0 (float-time (time-subtract (current-time) aj/mplayer-last-seek-f))))
  ;;       (cl-incf aj/mplayer-number-of-seeks-f)
  ;;     (setq aj/mplayer-number-of-seeks-f 1))
  ;;   (mplayer-seek-forward
  ;;    (or (nth aj/mplayer-number-of-seeks-f aj/mplayer-seek-sequence) 5))
  ;;   (setq aj/mplayer-last-seek-f (current-time)))

  ;; (bind-key "<f1>" #'aj/mplayer-seek-backward orgqda-transcript-mode-map)
  ;; (bind-key "<f2>" #'aj/mplayer-seek-forward orgqda-transcript-mode-map)

  (bind-key "C-S-a" #'orgqda-transcript-beginning-or-indentation orgqda-transcript-mode-map)
  (bind-key "C-S-e" #'end-of-line orgqda-transcript-mode-map)
  ;; (dolist (key `(("1" . mplayer-toggle-pause-with-rewind)
  ;;                ("2" . mplayer-seek-backward)
  ;;                ("3" . mplayer-seek-forward)))
  ;;   (define-key orgqda-transcript-mode-map (car key) (cdr key)))

  (bind-key "C-+" #'aj/repeat-last-words orgqda-transcript-mode-map))
#+END_SRC

** Standard frame parameters
I want my windows to launch at half screen width, to the left. But on my narrow laptop screen probably a little wider (90 chars).
#+begin_src emacs-lisp
(when (display-graphic-p)

  (scroll-bar-mode t)
  (set-scroll-bar-mode 'right)

  (defun aj/no-minibuffer-scrollbar-or-fringe (&optional frame)
    (set-window-scroll-bars (minibuffer-window frame) nil nil)
    ;; no right fringe in minibuffer:
    (set-window-fringes (minibuffer-window frame) nil 0))

  (aj/no-minibuffer-scrollbar-or-fringe)
  ;; not enough?
  ;; (add-hook 'after-make-frame-functions #'aj/no-minibuffer-scrollbar-or-fringe)

  ;; brute-force:
  (add-hook 'window-configuration-change-hook #'aj/no-minibuffer-scrollbar-or-fringe)


  (add-to-list 'default-frame-alist '(top . 0))
  (add-to-list 'default-frame-alist '(left . (+ -9)))
  (add-to-list 'default-frame-alist '(fullscreen . fullheight))
  ;; this is a bit narrower for arc-gtk-theme:
  (add-to-list 'default-frame-alist '(scroll-bar-width . 12))

  (defun aj/frame-to-left ()
    (interactive)
    (if (> (x-display-pixel-width) aj/large-screen-min-width)
        (let ((hw (/ (/ (x-display-pixel-width) 2 ) (frame-char-width))))
          (add-to-list 'default-frame-alist (cons 'width hw))
          (set-frame-parameter nil 'width hw))
      (set-frame-parameter nil 'width 90)
      (add-to-list 'default-frame-alist (cons 'width 90)) ;small
      )
    (set-frame-parameter nil 'fullscreen 'fullheight)
    (set-frame-parameter nil 'left '(+ -0))
    (set-frame-parameter nil 'top 0))

  (add-hook 'after-init-hook #'aj/frame-to-left))
#+end_src

** Auto-saving and reverting
*** Auto-saving of all buffers in visited files :ARCHIVE:
I don’t currently use this. It has caused more problems for me than it has solved. Over-eager auto-save interferes with some packages (most notably helm). And I’m kind of used to using unsaved buffers for some parts of my workflow.

Inspired by https://github.com/grettke/lolsmacs, it’s better to not keep inconsistent state in non-saved buffers. Especially since Emacs or my computer crashes from time to time.

#+begin_src emacs-lisp
(setq auto-save-default nil)
(auto-save-visited-mode)

;; also auto-save on various hooks

(defvar aj/save-all-buffers-hooks
  (append
   '(focus-out-hook mouse-leave-buffer-hook kill-emacs-hook suspend-hook))
  "When they run save all file buffers.")
(defvar aj/save-current-buffer-before-functions
  (append
   '(tex-compile vc-diff vc-next-action vc-revert))
  "Before they run save the buffer.")
(defvar aj/save-all-buffers-before-functions
  (append
   '(dired eshell grep ibuffer shell tex-compile)
   '(;; compile
     ns-do-hide-emacs goto-line)
   '(eval-buffer)
   '(org-export-dispatch org-babel-tangle org-babel-detangle)
   '(kill-current-buffer list-buffers save-buffers-kill-emacs save-buffers-kill-terminal switch-to-buffer pop-to-buffer)
   '(delete-frame delete-other-frames other-frame suspend-frame)
   '(delete-window quit-window)
   ;; doesn’t work with helm
   ;; other-window select-window
   )
  "Before they run save all file buffers.")

(defvar aj/save-buffers-debug nil "When non-nil message debug information for `aj/save-all-buffers'.")

(defun aj/save-all-buffers (&rest _args)
  "Save all file buffers.

When `aj/save-buffers-debug' is non-nil display performance information in
,*Messages* buffer.
Ignore all _ARGS. "
  (interactive)
  (let ((time (current-time)))
    (save-some-buffers t nil)
    (when aj/save-buffers-debug
      (message "aj/save-bufs completed in: %.06f seconds" (float-time (time-since time))))))

;; activate it all:
(cl-loop for hook in aj/save-all-buffers-hooks do
         (add-hook hook #'aj/save-all-buffers))

(cl-loop for fn in aj/save-all-buffers-before-functions do
         (advice-add fn :before #'aj/save-all-buffers))

;; (cl-loop for fn in aj/save-all-buffers-before-functions do
;;          (advice-remove fn #'aj/save-all-buffers))

(cl-loop for fn in aj/save-current-buffer-before-functions do
         (advice-add fn :before #'basic-save-buffer))


(define-key special-event-map [sigusr1] #'aj/save-all-buffers)
#+end_src

*** Auto reverting
#+begin_src emacs-lisp
(global-auto-revert-mode t)
;; Don't update pdfs in process of being built though:
(setq global-auto-revert-ignore-modes '(pdf-view-mode))
;; why ever query if not changed?
(setq revert-without-query '(".*"))
;; Also auto refresh dired, but be quiet about it
(setq global-auto-revert-non-file-buffers t)
(setq auto-revert-verbose nil)
;; I’m always on a reasonable system
(setq auto-revert-use-notify t)
#+end_src

A function for reverting all opened files, even remote files (because auto-revert doesn’t work there)
#+begin_src emacs-lisp
(defun aj/revert-all-buffers ()
  "Refreshes all open buffers from their respective files."
  (interactive)
  (dolist (buf (buffer-list))
	(with-current-buffer buf
	  (when (and (buffer-file-name) (not (buffer-modified-p)))
		(revert-buffer t t t) )))
  (message "Refreshed open files."))
#+end_src

** Helm for recent org files at startup
#+begin_src emacs-lisp
(require 'helm-for-files)
(defclass aj/helm-recentf-org-source (helm-source-sync helm-type-file)
  ((init :initform (lambda ()
                     (require 'recentf)
                     (recentf-mode 1)))
   (candidates :initform (seq-filter
                          (lambda (it) (and (string-match "\\.org$" it)
                                       (not (org-agenda-file-p it))
                                       (not (string-match "\\.emacs\\.d" it))))
                          recentf-list))
   (match-part :initform (lambda (candidate)
                           (if (or helm-ff-transformer-show-only-basename
                                   helm-recentf--basename-flag)
                               (helm-basename candidate) candidate)))
   (pattern-transformer :initform 'helm-recentf-pattern-transformer)
   (filtered-candidate-transformer :initform '(aj/helm-recentf-filtered-candidates-shorten))
   (persistent-action :initform 'helm-ff-kill-or-find-buffer-fname)
   (fuzzy-match :initform t)))

(defvar aj/helm-source-recentf-org
  (helm-make-source "Recentf org" 'aj/helm-recentf-org-source))

(defun aj/helm-recentf-org ()
  (interactive)
  (helm :sources aj/helm-source-recentf-org
        :buffer "*helm-recentf-org*"
        :ff-transformer-show-only-basename nil))

(add-hook 'window-setup-hook #'aj/helm-recentf-org 95)
#+end_src
* Final
** Load custom loaddefs :org_async:ARCHIVE:
#+BEGIN_SRC emacs-lisp
(load-file aj/custom-loaddefs-file)
#+END_SRC
** Local variables for lisp
#+BEGIN_SRC emacs-lisp
;; Local Variables:
;; byte-compile-warnings: '(not free-vars)
;; End:
#+END_SRC

*  Local Variables :ARCHIVE:

# Local Variables:
# eval: (progn (require 'use-package))
# aj/inhibit-flyspell: t
# End:
