# -*-coding: utf-8; -*-
#+TITLE: Emacs init file
#+AUTHOR: Anders Johansson
#+PROPERTY: header-args :tangle yes :comments no :no-expand t
#+TODO: CHECK TODO | DONE

This is my init file. Kept as an org file which is tangled and compiled to ~init.elc~

Additional configuration is in [[file:lisp/aj-org-config.org][aj-org-config.org]] and [[file:lisp/aj-mail-config.org][aj-mail-config.org]], and some of my configurations have been put in separate packages which are generally available in gitlab or github repositories.

Hopefully some of this could be useful to others.

* All configuration
** Meta
*** Tangling
Inspired by: https://github.com/larstvei/dot-emacs/blob/master/init.org

Emacs can only load =.el=-files. We can use =C-c C-v t= to run =org-babel-tangle=, which extracts the code blocks from the current file into a source-specific file (in this case a =.el=-file).

To avoid doing this each time a change is made we can add a function to the =after-save-hook= ensuring to always tangle and byte-compile the =org=-document after changes. But this generally annoys me, it’s easier to just choose when it should be done.

These functions possibly create two files from each org-file. When doing org-mode asynchronous exports, a small init file should be loaded, and this is automatically generated through tangling all trees tagged with "org_async". Even more specificity can be achieved with the tag "org_async_exclude" (which means a subtree of an "org_async"-tree can still be excluded). Additionally, "no_default_tangle" excludes trees from the standard init-files, and archived trees are always excluded (I use it for "commenting out" stuff). All to make as small and lean init files as possible.

#+BEGIN_SRC emacs-lisp
(defvar aj/org-init-files
  (list (expand-file-name "init.org" user-emacs-directory)
        (expand-file-name "aj-org-config.org" (concat user-emacs-directory "lisp"))
        (expand-file-name "aj-mail-config.org" (concat user-emacs-directory "lisp"))))

(defun aj/tangle-init (&optional file)
  (interactive)
  "If the current file is listed in aj/org-init-files the
code-blocks are tangled, and the tangled file is compiled.

Two files are possibly created, one with all trees, and one for
org mode async exports, using only trees tagged with “org_async”."
  (let* ((file (or file (buffer-file-name)))
         (file-noext (file-name-sans-extension file)))
    (when (or (called-interactively-p 'interactive)
              (and (member file aj/org-init-files)
                   ;; (y-or-n-p-with-timeout "Tangle+compile file?" 3 nil)
                   ))

	  (let* ((file-el (concat file-noext ".el"))
             (file-async (concat file-noext "-org-async.el"))
             (prog-mode-hook nil)
             ;; avoid garbage-collection for this
             (gc-cons-threshold most-positive-fixnum))
        (aj/org-tangle-matching "-no_default_tangle-ARCHIVE" file file-el)
        (aj/org-tangle-matching "org_async-org_async_exclude-ARCHIVE" file file-async))
      ;; (load file-noext)
      )))

(defun aj/org-tangle-matching (match origin-file target-file)
  (with-current-buffer
      (find-file-noselect origin-file)
    (let* ((todo-only nil)
           (trees (mapconcat #'identity
                             (org-scan-tags #'aj/org-return-entry
                                            (cdr (org-make-tags-matcher match))
                                            todo-only) "\n\n"))
           (ofile (make-temp-file "org-init-tangle" nil ".org"))
           (ofb (find-file-noselect ofile t))
           (byte-compile-warnings '(not free-vars)))
	  (with-current-buffer ofb
        (insert trees)
        (let ((text-mode-hook nil)
              (outline-mode-hook nil)
              (org-mode-hook nil)
              (org-agenda-inhibit-startup t)
              (org-inhibit-startup t))
          (org-mode)
          (org-babel-tangle nil target-file "emacs-lisp")))
      (kill-buffer ofb)
      (when (and (file-exists-p target-file) (file-writable-p target-file))
        (chmod target-file 333)
        (byte-compile-file target-file)))))

(defun aj/org-return-entry ()
  (buffer-substring-no-properties
   (org-entry-beginning-position)
   (org-entry-end-position)))


;; attempts at doing this async

;; this is difficult, because it seems I need to have all my
;; load-paths initiated. In particular it didn’t work with
;; pdf-zotxt-quote which couldn’t find org-zotxt in the compilation.
;; But why was this needed?

;; tried to add only the neccesary stuff to init-async, but ...

;; (async-start
;;  ;; What to do in the child process
;;  (lambda ()
;;    (load-file "~/.emacs.d/init-async.elc")
;;    (aj/tangle-init "~/.emacs.d/init.org")
;;    (sleep-for 1)
;;    (message "hej!")
;;    (with-current-buffer "*Messages*"
;;      (buffer-string)))

;;  ;; What to do when it finishes
;;  (lambda (result)
;;    (message "Async process done, result should be 222: %s"
;;             result)))



;; (let ((weal (aj/org-get-weal)))
;;   (concat
;;    (when weal
;;      (format "#+BEGIN_SRC emacs-lisp\n ;;(with-eval-after-load '%s\n#+END_SRC
;; " weal))

;;    (when weal "#+BEGIN_SRC emacs-lisp\n;;)\n#+END_SRC")))

;; (defun aj/org-get-weal ()
;;   (save-excursion
;;     (save-match-data
;;       (when (search-forward-regexp
;;              ":weal_\\([a-z_]+\\):"
;;              (point-at-eol) t)
;;         (replace-regexp-in-string "_" "-" (match-string 1))))))
#+END_SRC

*** Autoloading in all custom load-paths :ARCHIVE:
Some of my own packages or libraries added in /lisp don’t normally get their autoloads parsed (like happens for libraries included in emacs or those handled via ~package.el~). This is my solution for that problem.
**** Loaddefs file :org_async:
To be loaded [[*Load custom loaddefs][at the end of init]].
#+BEGIN_SRC emacs-lisp
(defvar aj/custom-loaddefs-file (expand-file-name "custom-loaddefs.el" user-emacs-directory))
#+END_SRC
**** Functions
#+BEGIN_SRC emacs-lisp
(defvar aj/original-load-path load-path) ;; has to be initialized early

(defun aj/generate-custom-loaddefs ()
  (cl-letf ((generated-autoload-file aj/custom-loaddefs-file)
            (ignored-local-variables
             (cons 'generated-autoload-file ignored-local-variables))
            ((symbol-function 'file-relative-name) #'aj/identity-first)
            ((symbol-function 'autoload-file-load-name) #'aj/autoload-file-load-name))
    (apply #'update-directory-autoloads (aj/custom-load-paths))))

(defun aj/identity-first (arg &rest _r)
  arg)

(defun aj/autoload-file-load-name (name)
  (if (string-match "\\.elc?\\(\\.\\|\\'\\)" name)
      (substring name 0 (match-beginning 0))
    name))

(defun aj/custom-load-paths ()
  "Returns load paths added in init file, outside package area"
  (cl-remove-if
   (apply-partially #'string-match-p ".emacs.d/elpa")
   (cl-set-difference
    load-path aj/original-load-path :test 'equal)))

(defun aj/generate-loaddefs-after-byte-compile (filename &rest rest)
  (when (and
         ;; no autoloads in my config files
         (not (string-match-p "-config" filename))
         (cl-some (apply-partially #'file-in-directory-p filename)
                  (aj/custom-load-paths)))
    (aj/generate-custom-loaddefs)))

(advice-add 'byte-compile-file :after #'aj/generate-loaddefs-after-byte-compile)
#+END_SRC

** Early settings and loading
*** garbage-collection settings
Avoid garbage collection when initializing and in minibuffer.
https://bling.github.io/blog/2016/01/18/why-are-you-changing-gc-cons-threshold/
#+BEGIN_SRC emacs-lisp
(defun aj/set-no-gc ()
  (setq gc-cons-threshold most-positive-fixnum))

(defun aj/set-normal-gc ()
  (setq gc-cons-threshold 8000000))

(add-hook 'minibuffer-setup-hook #'aj/set-no-gc)
(add-hook 'minibuffer-exit-hook #'aj/set-normal-gc)

(aj/set-no-gc)
(add-hook 'after-init-hook #'aj/set-normal-gc)
#+END_SRC

*** Remove unnecessary GUI-elements
#+begin_src emacs-lisp
(setq inhibit-startup-message t)

(when window-system
  (setq frame-title-format '(buffer-file-name "%f" ("%b")))
  
  (defun aj/deactivate-gui (mode on)
    "Activate or deactivate MODE depending on ON, and defines a variable stating my choice."
    (when (fboundp mode)
      (funcall mode (or on -1))
      (eval `(defconst ,(intern (concat "aj/" (symbol-name mode) "-on")) ,on))))

                                        ; I always want it to the right
  (dolist (mm '((menu-bar-mode nil) (tool-bar-mode nil) (mouse-wheel-mode t)))
    (aj/deactivate-gui (car mm) (cadr mm))))
#+END_SRC

*** Enable scroll-bars
#+begin_src emacs-lisp
(when window-system
  (scroll-bar-mode t)  
  (set-scroll-bar-mode 'right)
  (set-window-scroll-bars (minibuffer-window) nil nil)
  (set-window-fringes (minibuffer-window) nil 0) ; no right fringe in minibuffer
  )

#+end_src
*** Fontset stuff
I never get this to work really well, the issue is with special (fancy) symbols in [[*Mail-config][mu4e]] that gets the columns misaligned when the characters are taken from another font than the default mono-space (I use Ubuntu mono, which lacks many symbols). The "monospacified" version of Symbola is supposed to solve this problem but seemingly doesn’t. For now, I have switched to symbols that are in Ubuntu mono ([[file:lisp/aj-mail-config.org::*Symbols][defined here]]).
#+BEGIN_SRC emacs-lisp
(dolist (ft (fontset-list))
  ;; (set-fontset-font ft 'unicode (font-spec :name "Ubuntu Mono"))
  (set-fontset-font ft nil (font-spec :name "Symbola") nil 'append)
  (set-fontset-font ft 'cjk-misc (font-spec :name "Noto Sans CJK") nil)
  ;; (set-fontset-font ft 'unicode (font-spec :name "Symbola monospacified for Ubuntu Mono") nil 'append)
  ;; (set-fontset-font ft nil (font-spec :name "Symbola monospacified for Ubuntu Mono") nil 'append)
  )
#+end_src

*** Determine which of my two computers we are running on
#+begin_src emacs-lisp
(defvar aj/ajeb (string= "ajeb" (system-name)))
#+end_src

*** My own custom variables, utility hooks and functions
Some variables are not suitable to keep in the init-file, I add these via customize to the custom-file, which is not checked in.
#+BEGIN_SRC emacs-lisp
(defgroup aj nil "Group for my private variables"
  :group 'emacs)

(defvar aj/large-screen-min-width 1500
  "The minimum pixel-width for a screen to be considered large.
  Used by `aj/frame-to-left'")

(defvar aj/face-definitions-hook nil
  "Extra functions for defining faces after loading themes etc.")

(defun aj/solarized-theme-p (&optional theme)
  (or (and theme (member theme '(solarized-light solarized-dark)))
      (custom-theme-enabled-p 'solarized-light)
      (custom-theme-enabled-p 'solarized-dark)))

#+END_SRC

*** Add /lisp to load-path :org_async:
#+begin_src emacs-lisp
(eval-and-compile
  (add-to-list 'load-path  "~/.emacs.d/lisp"))
#+end_src

*** Package-manager setup (use straight.el) :org_async:
#+begin_src emacs-lisp
(setq straight-use-package-by-default t
      straight-vc-git-default-clone-depth 1
      straight-cache-autoloads t
      straight-repository-branch "develop")

(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))
#+end_src

*** Bootstrap ~use-package~ :org_async:
#+begin_src emacs-lisp
  ;; (unless (package-installed-p 'use-package)
  ;;   (package-refresh-contents)
  ;;   (package-install 'use-package))
  ;; (unless (package-installed-p 'validate)
  ;;   (package-refresh-contents)
  ;;   (package-install 'validate))
  ;; (eval-when-compile
  ;;   (require 'validate)
  ;;   (require 'use-package))

  ;; (setq use-package-compute-statistics t)

  (straight-use-package 'use-package)

  (use-package validate
	:demand t)
  (use-package bind-key
	:demand t)
  ;;(require 'bind-key)

  (use-package delight
	:demand t)
#+end_src

*** Hydra (used for definitions later on) :org_async:
#+BEGIN_SRC emacs-lisp
(use-package hydra
  :demand t)
#+END_SRC

*** Activate org early :ARCHIVE:
To get the fix for ~org-version~ from straight org needs to be activated early
#+begin_src emacs-lisp
(straight-use-package 'org)
#+end_src
*** Org init
**** org init
#+begin_src emacs-lisp
(use-package org
  :bind (("C-c a" . org-agenda) ("C-c c" . org-capture))
  :commands org-mode
  :defer t
  :init
  ;; (require 'org-protocol) ;; move to modules? autoload the entry commands (don’t seem to be)
  (setq org-directory "~/org"
        org-ellipsis " ⤵"
        org-export-backends '(beamer odt ascii html icalendar latex)
        org-modules '(org-habit org-inlinetask org-mu4e org-id org-bullets org-pdfview)
        org-list-allow-alphabetical t
        org-id-link-to-org-use-id 'use-existing
        org-agenda-files (expand-file-name "agenda-files" org-directory))
  (defcustom aj/org-work-agenda-files nil
    "Agenda files connected to work"
    :group 'aj
    :type '(repeat file))
  :config
  ;; (message "Laddade org")
  ;; (load-library "helm-mode)"
  (load-library "aj-org-config")
  ;; (require 'helm-mode)
  ;; (require 'aj-org-config)
  )
#+end_src
**** org init async                             :org_async:no_default_tangle:
#+begin_src emacs-lisp
(use-package org
  :demand t
  :commands org-mode
  :init (progn
          (setq org-directory "~/org"
                org-export-backends '(beamer odt ascii html icalendar latex)
                org-modules '(org-inlinetask org-zotxt org-id)
                org-list-allow-alphabetical t))
  :config (require 'ox) (require 'aj-org-config-org-async))
#+end_src
*** Swallow
#+begin_src emacs-lisp

#+end_src

*** No littering! :org_async:
#+begin_src emacs-lisp
(use-package no-littering
  :demand t
  :init
  (setq no-littering-etc-directory
        (expand-file-name "config/" user-emacs-directory)
        no-littering-var-directory "~/.emacs.data/")
  :config
  (with-eval-after-load 'recentf
    (add-to-list 'recentf-exclude no-littering-var-directory)
    (add-to-list 'recentf-exclude no-littering-etc-directory))
  (setq auto-save-file-name-transforms
        `((".*" ,(no-littering-expand-var-file-name "auto-save/") t))))
#+end_src

*** Save-hist (don't use session, but save many useful history variables)
#+BEGIN_SRC emacs-lisp
(setq savehist-additional-variables
      '(kill-ring search-ring regexp-search-ring extended-command-history
                 helm-M-x-input-history
                  ;; mindre viktiga kanske
                  helm-adaptive-history helm-build-regexp-history
                  helm-eshell-command-on-file-input-history
                  helm-external-command-history helm-ff-history
                  helm-file-name-history helm-grep-history
                  helm-surfraw-engines-history
                  helm-surfraw-input-history Info-history
                  Info-search-history compile-history
                  dired-regexp-history dired-shell-command-history
                  face-name-history grep-files-history
                  grep-find-history grep-history grep-regexp-history
                  org-agenda-search-history org-insert-link-history
                  org-refile-history org-tags-history
                  pdf-occur-history query-replace-history
                  shell-command-history))
(savehist-mode)
#+END_SRC
*** Tooltip-mode
#+begin_src emacs-lisp
(tooltip-mode t)
(setq x-gtk-use-system-tooltips t)
#+end_src

*** Center frame (used for helm)
Code adapted from ime-frame
#+begin_src emacs-lisp
(defun aj/center-frame (&optional frame)
  "Center a frame on the screen."
  (interactive)
  (apply 'set-frame-position
         (let* ((frame (or (and (boundp 'frame) frame) (selected-frame)))
                (center (aj/center-frame--get-center frame)))
           `(,frame ,@center))))

(defun aj/center-frame--get-center (frame)
  "Return the center position of FRAME on it's display."
  (let ((screengeometry (assq 'geometry (frame-monitor-attributes frame))))
    (aj/center-frame--box-get-center
     (frame-pixel-width frame)
     (frame-pixel-height frame)
     (nth 3 screengeometry)
     (nth 4 screengeometry))))

(defun aj/center-frame--box-get-center (w h cw ch)
  "Center a box inside another box.

Returns a list of `(TOP LEFT)' representing the centered position
of the box `(w h)' inside the box `(cw ch)'."
  (list (/ (- cw w) 2) (/ (- ch h) 2)))


#+end_src
*** Helm
**** Loading helm
(Really too much in config section here. Should probably move it to another file)
#+begin_src emacs-lisp
(defcustom aj/shortened-helm-paths nil
  "List of replacements to do in `helm-recentf-source' and
`helm-source-files-in-current-dir' lists of files
Order is important! Only the first matching entry will be replaced.

Example of alist entry:
\(\"^~/my/favorite/path\" . \"MFP\"\)"
  :group 'aj
  :type '(alist :key-type regexp :value-type string))

(use-package helm
  :bind (("<f2>" . helm-imenu))
  :delight helm-mode
  :defer 2
  :config
  (setq-default helm-command-prefix-key "C-c h")
  (require 'helm-config)
  (helm-mode)
  (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action) ; rebind tab to run persistent action
  (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action) ; make TAB works in terminal
  (define-key helm-map (kbd "C-z")  'helm-select-action) ; list actions using C-z

  (when (executable-find "curl")
    (setq helm-net-prefer-curl-p t))
  (setq
   helm-M-x-always-save-history t ; ska spara även kraschade kommandon
   helm-ff-search-library-in-sexp t ; search for library in `require' and `declare-function' sexp.
   helm-scroll-amount 8 ; scroll 8 lines other window using M-<next>/M-<prior>
   helm-ff-file-name-history-use-recentf t)
  ;;fuzzy matching
  (setq helm-buffers-fuzzy-matching t
        helm-recentf-fuzzy-match t
        helm-locate-fuzzy-match t
        helm-file-cache-fuzzy-match t
        helm-mode-fuzzy-match t
        helm-M-x-fuzzy-match t
        helm-semantic-fuzzy-match t
        helm-imenu-fuzzy-match t
        helm-apropos-fuzzy-match t
        helm-lisp-fuzzy-completion t)
  (helm-adaptive-mode 1)

  ;; display
  (setq helm-split-window-inside-p t)
  ;; from: https://www.reddit.com/r/emacs/comments/3asbyn/new_and_very_useful_helm_feature_enter_search/
  (defun helm-hide-minibuffer-maybe ()
    (when (with-helm-buffer helm-echo-input-in-header-line)
      (let ((ov (make-overlay (point-min) (point-max) nil nil t)))
        (overlay-put ov 'window (selected-window))
        (overlay-put ov 'face (let ((bg-color (face-background 'default nil)))
                                `(:background ,bg-color :foreground ,bg-color)))
        (setq-local cursor-type nil))))

  (add-hook 'helm-minibuffer-set-up-hook
            'helm-hide-minibuffer-maybe)

  (setq helm-display-function
        ;;#'aj/helm-display-child-frame
        #'helm-default-display-buffer 
        helm-display-buffer-reuse-frame t
        helm-display-buffer-width 120
        helm-display-buffer-height 35
        helm-echo-input-in-header-line t)

  ;; (defun aj/helm-display-child-frame (buffer &optional resume)
  ;;     "Display `helm-buffer' in a separate frame.
  ;; Function suitable for `helm-display-function',
  ;; `helm-completion-in-region-display-function'
  ;; and/or `helm-show-completion-default-display-function'.
  ;; See `helm-display-buffer-height' and `helm-display-buffer-width' to
  ;; configure frame size."
  ;;     (if (not (display-graphic-p))
  ;;         ;; Fallback to default when frames are not usable.
  ;;         (helm-default-display-buffer buffer)
  ;;       (setq helm--buffer-in-new-frame-p t)
  ;;       (let ((default-frame-alist
  ;;               `((parent . ,(selected-frame))
  ;;                 (width . ,helm-display-buffer-width)
  ;;                 (height . ,helm-display-buffer-height)
  ;;                 (undecorated . t)
  ;;                 (left-fringe . 2)
  ;;                 (right-fringe . 2)
  ;;                 (tool-bar-lines . 0)
  ;;                 (line-spacing . 0)
  ;;                 (desktop-dont-save . t)
  ;;                 (no-special-glyphs . t)
  ;;                 (tool-bar-lines . 0)
  ;;                 (left . 0)
  ;;                 (top . 0)
  ;;                 (title . "Helm")
  ;;                 (vertical-scroll-bars . nil)
  ;;                 (menu-bar-lines . 0)
  ;;                 (fullscreen . nil)
  ;;                 (visibility . ,(null helm-display-buffer-reuse-frame))
  ;;                 (minibuffer . nil)))
  ;;             display-buffer-alist)
  ;;         (helm-display-buffer-popup-frame buffer default-frame-alist)
  ;;         (set-face-attribute 'header-line (selected-frame)
  ;;                             :background nil :foreground 'unspecified :height 1.15
  ;;                             :inherit 'default)
  ;;         (aj/center-frame))
  ;;       (helm-log-run-hook 'helm-window-configuration-hook)))

  ;; Only show headers if several sources
  ;; https://www.reddit.com/r/emacs/comments/2z7nbv/lean_helm_window/
  (defun helm-toggle-header-line ()
    (if (eq 1 (length (ignore-errors (with-helm-buffer helm-sources))))
        (set-face-attribute 'helm-source-header nil :height 1)
      (set-face-attribute 'helm-source-header nil :height 1.0)))

  (add-hook 'helm-before-initialize-hook #'helm-toggle-header-line)


  ;;; bindings
  (define-key global-map [remap execute-extended-command] #'helm-M-x)
  (global-set-key (kbd "M-y") 'helm-show-kill-ring)

  (bind-key "<f1> a" #'helm-apropos)

  (global-set-key (kbd "C-x b") 'helm-mini)
  (global-set-key (kbd "C-x B") 'helm-mini)

  (global-set-key (kbd "C-x C-f") 'helm-find-files)
  (global-set-key (kbd "C-c h g") 'helm-google-suggest)

;;; Helm mini:
  
  (setq helm-mini-default-sources
        '(helm-source-buffers-list
          aj/helm-source-favourite-files
          helm-source-recentf
          helm-source-files-in-current-dir
          aj/helm-source-dired-recent
          helm-source-buffer-not-found))
  (defvar aj/helm-source-dired-recent
    (helm-build-sync-source "Recent directories"
      :candidates 'dired-recent-directories
      :action '(("Open directory" . dired)
                ("Delete from dired-recent list" . aj/helm-action-dired-recent-delete))))

  (defun aj/shorten-helm-path (path)
    (cl-loop
     with disp = (or (car-safe path) path) with real = (or (cdr-safe path) path)
     for s in aj/shortened-helm-paths
     when (string-match (car s) disp)
     return (cons
             (concat (substring disp 0 (match-beginning 0))
                     (propertize (cdr s) 'face '(bold helm-ff-symlink))
                     (substring disp (match-end 0)))
             real)
     finally return path))

  (defun aj/helm-recentf-filtered-candidates-shorten (candidates source)
    (mapcar #'aj/shorten-helm-path candidates))

  (with-eval-after-load "helm-for-files"
    (dolist (source '(helm-source-recentf helm-source-files-in-current-dir))
      (cl-callf append
          (alist-get 'filtered-candidate-transformer (symbol-value source))
        '(aj/helm-recentf-filtered-candidates-shorten))))

  ;;; grep --> ripgrep

  (setq helm-grep-ag-command "rg -u --color=never --smart-case --no-heading --line-number %s %s %s"
        helm-grep-file-path-style 'relative)
  (bind-key "C-s" #'helm-ff-run-grep-ag helm-find-files-map)

  (defun aj/helm-rg-org-files ()
    "Function for searching through all org files in home directory."
    (interactive)
    (advice-add 'helm-grep--filter-candidate-1 :filter-return
                #'aj/shorten-helm-path)
    (unwind-protect
        (let ((helm-grep-file-path-style 'absolute))
          (helm-grep-ag-1 (expand-file-name "~") '("-torg")))
      (advice-remove 'helm-grep--filter-candidate-1
                     #'aj/shorten-helm-path)))

  ;;; google-suggest
  (with-eval-after-load 'helm-net
    (add-to-list 'helm-google-suggest-actions
                 '("Thesaurus" . (lambda (candidate)
                                   (helm-search-suggest-perform-additional-action
                                    "http://www.thesaurus.com/browse/%s" candidate))) t)
    (add-to-list 'helm-google-suggest-actions
                 '("Tyda" . (lambda (candidate)
                              (helm-search-suggest-perform-additional-action
                               "http://tyda.se/search/%s" candidate))) t))

  ;;; more candidates for helm-ucs
  (defun aj/helm-500-candidates (fn &rest args)
    (let ((helm-candidate-number-limit 500))
      (apply fn args)))

  (advice-add 'helm-ucs :around #'aj/helm-500-candidates)

  ;;; mark-ring extra
  (defun aj/pop-to-mark-invoke-helm (fun)
    (interactive)
    (if (eq last-command 'pop-to-mark-command)
        (helm-all-mark-rings)
      (funcall fun)))

  (defvar helm-mark-ring-map
    (let ((map (make-sparse-keymap)))
      (set-keymap-parent map helm-map)
      (define-key map (kbd "C-<SPC>") 'helm-next-line) map)
    "Keymap for `helm-all-mark-rings'.")

  (setq set-mark-command-repeat-pop t)
  (with-eval-after-load 'helm-ring
    (add-to-list 'helm-source-mark-ring `(keymap . ,helm-mark-ring-map)))
  (advice-add 'pop-to-mark-command :around #'aj/pop-to-mark-invoke-helm)


  ;; Don’t want launched processes lying around being children to
  ;; emacs (and being killed when I have to kill emacs). Therefore I
  ;; use ‘call-process-shell-command’ instead of
  ;; ‘start-process-shell-command’.

  (defun aj/helm-run-or-raise (exe &optional file)
    (let ((real-com (car (split-string exe))))
      (when (member real-com helm-external-commands-list)
        (message "Starting %s..." real-com)
        (if file
            (call-process-shell-command
             (format "%s %s"
                     real-com
                     (shell-quote-argument
                      (if (eq system-type 'windows-nt)
                          (helm-w32-prepare-filename file)
                        (expand-file-name file))))
             nil 0)
          (call-process-shell-command real-com nil 0)))))

  (advice-add 'helm-run-or-raise :override #'aj/helm-run-or-raise)

  )


#+end_src
**** helm-flx
Different fuzzy search algorithm, is this needed?
#+BEGIN_SRC emacs-lisp
(use-package helm-flx
  :after helm
  :init (helm-flx-mode t))

#+END_SRC
**** Open zotero library files
#+BEGIN_SRC emacs-lisp
(use-package dash)
(eval-when-compile (require 'dash))

(with-eval-after-load 'helm-files
  (defcustom aj/helm-zotero-library nil
    "Directory of Zotero library files"
    :group 'aj
    :type 'directory)

  (defvar aj/helm-zoterofile-history)
  (defvar aj/zoterofiles-frame-manage nil)

  (defun aj/open-zoterofile-new-frame ()
    (interactive)
    (let ((ocframe
           (make-frame '((width . 100) (height . 20) (name . "helm-zotero")
                         (window-system . x) (fullscreen . nil))))
          (helm-full-frame t)
          (aj/zoterofiles-frame-manage t))
      (select-frame-set-input-focus ocframe)
      (aj/center-frame)
      (aj/helm-open-zoterofile)))

  (defun aj/helm-open-zoterofile ()
    (interactive)
    (let* ((oe '("Open externally" . aj/helm-open-file-externally-delete-frame))
           (ff '("Find file" . aj/helm-find-many-files-widen-frame))
           (active-actions (if aj/zoterofiles-frame-manage
                               (list oe ff)
                             (list ff oe))))
      (helm :sources
            (list
             (helm-build-sync-source "Zotero recently modified"
               :action active-actions
               :pattern-transformer 'helm-recentf-pattern-transformer
               :keymap helm-generic-files-map
               :candidates #'aj/helm-zotero-recently-modified)
             (helm-build-sync-source "Zotero recentf"
               :candidates #'aj/recentf-list-zotero
               :action active-actions
               :fuzzy-match t
               :filtered-candidate-transformer #'helm-highlight-files
               :pattern-transformer #'helm-recentf-pattern-transformer
               :match-part #'aj/helm-zotero-match-part
               :keymap helm-generic-files-map)
             (helm-build-sync-source "Zotero files"
               :candidates #'aj/helm-zotero-files
               :action active-actions
               :fuzzy-match t
               :candidate-transformer #'helm-skip-boring-files
               :filtered-candidate-transformer #'helm-highlight-files
               :pattern-transformer #'helm-recentf-pattern-transformer
               :match-part #'aj/helm-zotero-match-part
               :keymap helm-generic-files-map
               ))


            :buffer "*helm-zoterofile*"
            :history 'aj/helm-zoterofile-history
            :ff-transformer-show-only-basename t)))


  (defun aj/helm-zotero-recently-modified ()
    (when (file-accessible-directory-p aj/helm-zotero-library)
      (with-temp-buffer
        (call-process "ls" nil t nil "-t" "-1" aj/helm-zotero-library)
        (mapcar (lambda (x) (cons x (expand-file-name x aj/helm-zotero-library)))
                (split-string
                 (buffer-substring (point-min)
                                   (progn (goto-char (point-min))
                                          (forward-line 20) (point)))
                 "\n"
                 t)))))

  (defun aj/recentf-list-zotero ()
    (--filter (string-match-p aj/helm-zotero-library it)
              recentf-list))

  (defun aj/helm-zotero-files ()
    (when (file-accessible-directory-p aj/helm-zotero-library)
      (directory-files aj/helm-zotero-library t "\\.\\(pdf\\|djvu\\|vue\\)$")))

  (defun aj/helm-zotero-match-part (candidate)
    (if (or helm-ff-transformer-show-only-basename
            helm-recentf--basename-flag)
        (helm-basename candidate) candidate))

  (defun aj/helm-find-many-files-widen-frame (_ignore)
    (helm-find-many-files t)
    (when aj/zoterofiles-frame-manage
      (aj/frame-to-left)
      (set-frame-name (buffer-file-name))))
  (defun aj/helm-open-file-externally-delete-frame (file)
    (helm-open-file-externally file)
    (when aj/zoterofiles-frame-manage
      (delete-frame))))
#+END_SRC
**** TODO Utvärdera om vi borde använda helm-multi-files istället för att lägga allt i helm-mini
**** COMMENT Helm omni-files, buffers, recentf                      :ARCHIVE:

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x C-b") 'aj/helm-omni-buffers)
  (global-set-key (kbd "C-x b") 'aj/helm-omni-buffers)
  (global-set-key (kbd "C-x C-r") 'aj/helm-omni-recent)

  (defvar aj/helm-omni-history nil)

  (defun aj/helm-omni-buffers (&rest arg)
    (interactive)
    (require 'helm-files)
    (unless helm-source-buffers-list
      (setq helm-source-buffers-list
            (helm-make-source "Buffers" 'helm-source-buffers)))
    (helm :sources
          '(helm-source-buffers-list
            helm-source-recentf
            helm-source-files-in-current-dir
            helm-source-locate
            helm-source-bookmarks
            helm-source-buffer-not-found)
          :buffer "*helm omni recentf*"
          :truncate-lines t
          :history 'aj/helm-omni-history
          :ff-transformer-show-only-basename nil))

  (defun aj/helm-omni-recent (&rest arg)
    (interactive)
    (require 'helm-files)
    (unless helm-source-buffers-list
      (setq helm-source-buffers-list
            (helm-make-source "Buffers" 'helm-source-buffers)))
    (helm :sources
          '(helm-source-recentf
            helm-source-buffers-list
            helm-source-locate
            helm-source-files-in-current-dir
            helm-source-bookmarks
            helm-source-buffer-not-found)
          :buffer "*helm omni recent*"
          :truncate-lines t
          :history 'aj/helm-omni-history
          :ff-transformer-show-only-basename nil))

#+END_SRC


**** Helm-recoll                                                    :ARCHIVE:
#+begin_src emacs-lisp
(use-package helm-recoll
  :commands helm-recoll
  :config (helm-recoll-create-source "default" "~/.recoll/"))
#+end_src

**** Favourite files (to mark files which should be prioritized in helm matches)
#+BEGIN_SRC emacs-lisp
(defvar aj/favourite-files nil)
(with-eval-after-load "savehist-mode"
  (add-to-list 'savehist-additional-variables 'aj/favourite-files))

(defun aj/add-favourite-file ()
  (interactive)
  (if-let ((name (or
                  (buffer-file-name)
                  (and (eq major-mode 'dired-mode) default-directory))))
      (cl-pushnew name aj/favourite-files :test #'string=)
    (user-error "Not in a file- or dired-buffer")))

(with-eval-after-load "helm-for-files"
  (defun aj/remove-favourite-file (_candidate)
    ;; to be run from helm
    (cl-loop for file in (helm-marked-candidates)
             do (setq aj/favourite-files (delete file aj/favourite-files))))

  (defclass aj/helm-favourite-files-source (helm-source-sync helm-type-file)
    ((candidates :initform (lambda () aj/favourite-files))
     (pattern-transformer :initform 'helm-recentf-pattern-transformer)
     (match-part :initform (lambda (candidate)
                             (if (or helm-ff-transformer-show-only-basename
                                     helm-recentf--basename-flag)
                                 (helm-basename candidate) candidate)))
     (persistent-action :initform 'helm-ff-kill-or-find-buffer-fname)
     (fuzzy-match :initform t)))

  (defmethod helm--setup-source :after ((source aj/helm-favourite-files-source))
    (setf (slot-value source 'action)
          (append (symbol-value (helm-actions-from-type-file))
                  '(("Delete file(s) from aj/favourite-files" .
                     aj/remove-favourite-file))))
    (setf (slot-value source 'filtered-candidate-transformer)
          (append (slot-value source 'filtered-candidate-transformer)
                  '(aj/helm-recentf-filtered-candidates-shorten))))

  (defvar aj/helm-source-favourite-files
    (helm-make-source "Favourite files" 'aj/helm-favourite-files-source)))
#+END_SRC

**** Favorite directories
http://endlessparentheses.com/visit-directory-inside-a-set-of-directories.html
#+begin_src emacs-lisp
(defcustom aj/favorite-directories nil
  "List of favorite directories.
Used in `aj/visit-favorite-dir'. The order here affects the order
that completions will be offered. Each element is a list of
directory, search depth, and whether to include files."
  :type '(repeat (list (directory :tag "Directory")
                       (integer :tag "Search depth")
                       (boolean :tag "Include files")))
  :group 'aj)

(defvar aj/fav-dir-history nil)

(defun aj/visit-favorite-dir (files-too)
  "Offer all directories inside a set of directories.
Compile a list of all directories inside each element of
`aj/favorite-directories', and visit one of them with
`ido-completing-read'.
With prefix argument FILES-TOO also offer to find files."
  (interactive "P")
  (let ((completions
         (apply #'append
                (mapcar (lambda (x)
                          (aj/get-dir-list (car x) (cadr x) (or files-too (nth 2 x))))
                        aj/favorite-directories)))
        (helm-candidate-number-limit nil))
    (dired
     (helm-comp-read "Open directory: " completions
                     :input-history aj/fav-dir-history))))


(defun aj/get-dir-list (dir level &optional files-too)
  "Get list of directories (or files with FILES-TOO) to a certain level"
  (if (and (file-directory-p dir) (> level 0))
      ;; recurse into directories if we have levels left
      (apply #'append
             (list dir)
             (mapcar
              (lambda (sdir) (aj/get-dir-list sdir (1- level) files-too))
              (mapcar
               #'abbreviate-file-name
               (cl-remove-if-not
                (if files-too #'file-readable-p
                  #'file-directory-p)
                (directory-files
                 (expand-file-name dir)
                 t "^[^\.].*" t)))))
    ;; just return dir or file
    (list dir)))

;;TODO, define as helm-source
;; (defclass aj/helm-favorit-dir-class (helm-source-sync helm-type-timers)
;;   ((candidates :initform timer-idle-list)
;;    (allow-dups :initform t)
;;    (volatile :initform t)
;;    (filtered-candidate-transformer
;;     :initform
;;     (lambda (candidates _source)
;;       (cl-loop for timer in candidates
;;                collect (cons (helm-elisp--format-timer timer) timer))))))

;; (defvar helm-source-idle-time-timers
;;   (helm-make-source "Idle Time Timers" 'helm-idle-time-timers-class))
#+end_src

Note that C-x d is usually bound to dired. I find
this redundant with C-x C-f, so I don't mind
overriding it, but you should know before you do.
#+begin_src emacs-lisp
(define-key ctl-x-map "d" #'aj/visit-favorite-dir)

#+end_src


*** org-mode extra

**** Things to load with org
***** Stuff
#+begin_src emacs-lisp
;; TODO, why here?
(use-package orgqda
  :straight (:host gitlab :repo "andersjohansson/orgqda")
  :defer t
  :after org
  :init (put 'orgqda-csv-dir 'safe-local-variable #'file-directory-p)
  :config (setq orgqda-exclude-tags
                (append (mapcar #'car org-tag-persistent-alist)
                        '("ARCHIVE" "Reflektion" "Observation" "Forskningsdagbok")))
  (defhydra aj/orgqda-hydra (:color blue :hint t)
	("m" #'orgqda-mode "Toggle mode")
	("ö" #'orgqda-list-tags "List tags")
	("C-ö" #'orgqda-list-tags nil)
	("ä" #'normal-mode "Normal mode")
	("Ö" #'orgqda-list-tags-full "List and extract")
	("c" #'orgqda-collect-tagged "Collect tagged")
	("C-c" #'orgqda-collect-tagged "Collect tagged")
	("v" #'orgqda-collect-tagged-csv "Collect csv")
	("V" #'orgqda-collect-tagged-csv-save "Collect csv save")
	("b" #'orgqda-collect-tagged-csv-save-all "Save all as csv"))
  (bind-key "C-c C-ö" 'aj/orgqda-hydra/body orgqda-mode-map))

(use-package org-pomodoro
  :after org)
(use-package org-download
  :after org)
#+end_src
***** org-pdfview
#+BEGIN_SRC emacs-lisp
(use-package org-pdfview
  :after org)
#+END_SRC
***** org clock hydra
#+BEGIN_SRC emacs-lisp
(bind-key "C-c w" #'hydra-org-clock/body)
;; make byte-compiler happy?
(dolist (x '(org-clock-in org-clock-out org-clock-in-last org-clock-modify-effort-estimate org-clock-cancel org-clock-goto org-clock-display org-clock-report org-clocking-p))
  (autoload x "org-clock"))

(defhydra hydra-org-clock (:color blue :hint nil)
  "
 In/out^        ^Edit^         ^Summary     (_?_)
---------------------------------------------
 _i_n, select    _e_dit effort  _g_oto entry
 _I_n here       _C_ancel       _d_isplay
 _c_ontinue ^ ^ _r_eport
 _o_ut
 _D_one
 _p_omodoro (select)
 _l_ast task pomodoro (continue)
 _P_omodoro here"
  ("i" aj/org-clock-in-list)
  ("I" aj/org-clock-in-here)
  ("o" org-clock-out)
  ("D" aj/org-mark-current-clocking-done)
  ("c" org-clock-in-last)
  ("p" (org-pomodoro '(4)))
  ("l" (org-pomodoro '(16)))
  ("P" org-pomodoro)
  ("e" org-clock-modify-effort-estimate)
  ("C" org-clock-cancel)
  ("g" org-clock-goto)
  ("d" org-clock-display)
  ("r" org-clock-report)
  ("?" (org-info "Clocking commands")))

(defun aj/org-clock-in-list ()
  (interactive) (org-clock-in '(4)))

(defun aj/org-clock-in-here ()
  (interactive)
  (cond
   ((eq major-mode 'org-mode)
    (org-clock-in))
   ((eq major-mode 'org-agenda-mode)
    (org-agenda-clock-in))
   (t (message "Not in org file or agenda"))))

(defun aj/helm-org-clock-in (marker)
  (save-window-excursion
    (switch-to-buffer (marker-buffer marker))
    (goto-char (marker-position marker))
    (org-clock-in)))

(defun aj/org-mark-current-clocking-done ()
  (interactive)
  (when (org-clocking-p)
    (save-window-excursion
      (org-clock-goto)
      (org-todo 'done))))
#+END_SRC


*** Flycheck
#+begin_src emacs-lisp
(use-package flycheck
  :commands (global-flycheck-mode)
  :init (add-hook 'after-init-hook #'global-flycheck-mode)
  :defer 5
  :delight ""
  :config (progn
            (setq-default flycheck-emacs-lisp-load-path 'inherit)
            (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc))
            (add-hook 'text-mode-hook (lambda ()(flycheck-mode -1)))))
#+end_src

*** Saveplace is neccessary
#+BEGIN_SRC emacs-lisp
(require 'saveplace)
(setq save-place-limit 1000)
(save-place-mode 1)
#+END_SRC
*** Custom file :org_async:
#+begin_src emacs-lisp
(setq custom-file "~/.emacs.d/custom.el")
(load custom-file)
#+end_src
** Debugging
#+BEGIN_SRC emacs-lisp
(use-package profiler
  :bind (("<C-f7>" . aj/start-profiler)
         ("<C-f8>" . profiler-report))
  :init
  (defun aj/start-profiler () (interactive)
         (profiler-start 'cpu)))
#+END_SRC

** Mail-config (mu4e)
Use mu4e, the extensive config is in an [[file:lisp/aj-mail-config.org][external file]].
#+BEGIN_SRC emacs-lisp
(when aj/ajeb
  (use-package mu4e
	:bind (("C-x ö" . mu4e)
		   ("C-x m" . mu4e-compose-new)
		   ("C-x i" . mu4e~headers-jump-to-maildir)
		   ("C-x å" . mu4e-headers-search-bookmark))
	:defer 10
	:init (setq mu4e-get-mail-command "aj-mailsync" ; bash script running 3 offlineimap
				mu4e-update-interval 1800
				mu4e-view-show-images t
				mu4e-use-fancy-chars t
                mu4e-headers-results-limit 200 ; easier on my slow computer
				mu4e-attachment-dir "~/Hämtningar"
				;; mu4e-change-filenames-when-moving t ;;for mbsync
				mu4e-completing-read-function #'completing-read) ; hands it to helm
	:config (require 'aj-mail-config)
	(mu4e t) ;; start delayed in background
	))
#+END_SRC

*** Fix parse-time-string :ARCHIVE:
Why do I need this? For something with mu4e emailing? I don’t remember. It messes with ~org-read-date-analyze~, which is smarter anyway.

Disable it for now.
#+BEGIN_SRC emacs-lisp
(declare-function parse-iso8601-time-string "parse-time" (str)) ; make byte-compiler happy

(defun aj/parse-time-string (oldfun &rest r)
  "Filter `parse-time-string' to additionally try parsing iso8601 strings"
  (let ((ptret (apply oldfun r)))
    (when (cl-every #'null ptret)
      (if-let ((ip (ignore-errors (parse-iso8601-time-string (car r)))))
          (decode-time ip)
        ptret))))

(advice-add 'parse-time-string :around #'aj/parse-time-string)
#+END_SRC
** Elfeed (feed-reader)
#+BEGIN_SRC emacs-lisp
(use-package elfeed
  :bind ("C-x y" . elfeed)
  :config (add-hook 'elfeed-show-mode-hook #'visual-line-mode))

;;just the split-pane part extracted from the elfeed-goodies package
;; (use-package elfeed-goodies-split-pane
;;   :straight (elfeed-goodies-split-pane
;;              :host github
;;              :repo "algernon/elfeed-goodies"
;;              :files ("elfeed-goodies-split-pane.el"))
;;   :after elfeed
;;   :demand t
;;   :bind (:map elfeed-show-mode-map
;;               ("n" . elfeed-goodies/split-show-next)
;;               ("p" . elfeed-goodies/split-show-prev))
;;   :config
;;   (setq elfeed-goodies/entry-pane-size 0.5
;;         elfeed-show-entry-switch #'elfeed-goodies/switch-pane
;;         elfeed-show-entry-delete #'elfeed-goodies/delete-pane))

#+END_SRC
** Unfixed dependencies
#+BEGIN_SRC emacs-lisp
(use-package dash-functional)
#+END_SRC

** News :ARCHIVE:
#+BEGIN_SRC emacs-lisp
(setq gnus-select-method '(nntp "news.gmane.org"))
#+END_SRC
** Unicode-fonts :ARCHIVE:
Don’t remember the point of this package
#+BEGIN_SRC emacs-lisp
;; (use-package unicode-fonts
;;   :defer 3
;;   :config (unicode-fonts-setup))

;;(set-fontset-font t 'unicode (font-spec :name "Symbola monospacified for Ubuntu Mono") nil 'append)
#+END_SRC
** Filetypes etc
*** Add pdfbz2 and pdfgz filetypes and decompress correctly
I need this for adding files with .pdfbz2 or .pdfgz suffixes to Zotero with Zotfile, which can't handle double suffixes like .pdf.bz2.

But why do I need to compress pdf-files this way? Shouldn’t pdf-files have reasonable compression?
#+BEGIN_SRC emacs-lisp
(dolist (var '("\\.pdfbz2\\'" "\\.pdfgz\\'"))
  (add-to-list 'auto-mode-alist (cons var 'pdf-view-mode)))
(add-to-list 'jka-compr-compression-info-list
             ["\\.pdfbz2\\'" "bzip2ing" "bzip2" nil "bunzip2ing" "bzip2"
              ("-d")
              nil t "BZh"])
(add-to-list 'jka-compr-compression-info-list
             ["\\.pdfgz\\'" "compressing" "gzip"
              ("-c" "-q")
              "uncompressing" "gzip"
              ("-c" "-q" "-d")
              t t "\213"])
(jka-compr-update)
#+END_SRC

** File management
*** Dired
**** Some settings
#+begin_src emacs-lisp
(setq dired-recursive-deletes 'always
      dired-recursive-copies 'always
      dired-dwim-target t)
#+end_src
**** dired: use ~hl-line-mode~ and hide cursor
But show cursor in ~wdired-mode~
#+begin_src emacs-lisp
(add-hook 'dired-mode-hook #'hl-line-mode)

(defun aj/dired-no-cursor ()
  (setq cursor-type nil))

(add-hook 'dired-mode-hook #'aj/dired-no-cursor)

(defun aj/reset-cursor ()
  (kill-local-variable 'cursor-type))

(add-hook 'wdired-mode-hook #'aj/reset-cursor)

(advice-add 'wdired-change-to-dired-mode :after #'aj/dired-no-cursor)
#+end_src
**** dired-git-info
#+begin_src emacs-lisp
(use-package dired-git-info
    :bind (:map dired-mode-map
                (")" . dired-git-info-mode)))
#+end_src
**** Dired collapse
#+BEGIN_SRC emacs-lisp
(use-package dired-collapse
  ;; :after dired
  :defer t
  :init (add-hook 'dired-mode-hook #'dired-collapse-mode))
#+END_SRC
**** dired-hide-dotfiles
#+BEGIN_SRC emacs-lisp
(use-package dired-hide-dotfiles
  :bind (:map dired-mode-map
              ("å" . dired-hide-dotfiles)))
#+END_SRC
**** Dired subtree
#+BEGIN_SRC emacs-lisp
(use-package dired-subtree
  :defer t
  :after dired
  :config (setq dired-subtree-use-backgrounds nil)
  (bind-keys :map dired-mode-map
             ("TAB" . dired-subtree-cycle)))
#+END_SRC
**** Dired-narrow
#+BEGIN_SRC emacs-lisp
(use-package dired-narrow
  :commands dired-narrow)
#+END_SRC

**** Dired-du
#+BEGIN_SRC emacs-lisp
(use-package dired-du
  :defer t
  :config (validate-setq dired-du-size-format t
                         dired-du-update-headers t))
#+END_SRC

**** Dired-ranger :ARCHIVE:
#+BEGIN_SRC emacs-lisp
(use-package dired-ranger
  :commands dired-ranger)
#+END_SRC

**** Sorting and listing-switches (dired-quick-sort)
https://gitlab.com/xuhdev/dired-quick-sort/
But also my branch for persistent per-directory options.
https://gitlab.com/andersjohansson/dired-quick-sort/tree/dir-save
(including some other unmerged fixes).
#+begin_src emacs-lisp
(setq dired-listing-switches "-lhA")
(use-package dired-quick-sort
  :straight nil ; TODO fork
  :load-path "~/kodat/elisp/dired-quick-sort"
  :after dired
  :custom
  (dired-quick-sort-use-per-directory-options t)
  (dired-quick-sort-default-options '("version" ?n ?y "default"))
  (dired-quick-sort-key "s")
  :config
  (dired-quick-sort-setup))
#+end_src

But some of the options for listing-switches doesn’t work with remote sessions in tramp. Avoid this!
#+begin_src emacs-lisp
(add-hook 'dired-before-readin-hook #'aj/dired-no-remote-lsv)

(defun aj/dired-no-remote-lsv ()
  (when (file-remote-p default-directory)
    (setq-local
     dired-listing-switches "-al")
    (setq-local
     dired-actual-switches "-al")))
#+end_src

**** dired-toggle-sudo
#+begin_src emacs-lisp
(use-package dired-toggle-sudo
  :commands dired-toggle-sudo
  :init
  (with-eval-after-load 'dired
    (bind-key "C-c C-s" 'dired-toggle-sudo dired-mode-map)))
#+end_src

**** Dired-recent
Store visited directories in a list, make it accessible from helm
#+BEGIN_SRC emacs-lisp
(use-package dired-recent
  :after (:all dired)
  :config
  (dired-recent-mode 1)
  (setq dired-recent-mode-map nil)
  (with-eval-after-load "helm-for-files"
    (defun aj/remove-dired-recent-dir (_c)
      ;; to be run from helm
      (cl-loop for c in (helm-marked-candidates)
               do (setq dired-recent-directories (delete c dired-recent-directories))))

    (defclass aj/helm-dired-recent-source (helm-source-sync helm-type-file)
      ((candidates :initform (lambda () dired-recent-directories))
       (pattern-transformer :initform 'helm-recentf-pattern-transformer)
       (match-part :initform (lambda (candidate)
                               (if (or helm-ff-transformer-show-only-basename
                                       helm-recentf--basename-flag)
                                   (helm-basename candidate) candidate)))
       (fuzzy-match :initform t)))


    ;; FIX: should be able to use helm-add-action-to-source
    (defmethod helm--setup-source :after ((source aj/helm-dired-recent-source))
      (setf (slot-value source 'action)
            (append (symbol-value (helm-actions-from-type-file))
                    '(("Delete file(s) from aj/favourite-files" .
                       aj/remove-dired-recent-dir))))
      (setf (slot-value source 'filtered-candidate-transformer)
            (append (slot-value source 'filtered-candidate-transformer)
                    '(aj/helm-recentf-filtered-candidates-shorten))))

    (defvar aj/helm-source-dired-recent
      (helm-make-source "Recent directories" 'aj/helm-dired-recent-source))))


#+END_SRC

*** Recentf
#+begin_src emacs-lisp
(use-package recentf
  :demand t
  :init (setq-default recentf-exclude '("xhtml-loader\\.rnc$" "\\.elc$"
                                        "elpa.*-autoloads.el"
                                        "/tmp/org-init-tangle"
                                        "~/.emacs.d/init.el"
                                        "~/.emacs.d/lisp/aj-org-config.el"
                                        "~/.emacs.d/lisp/aj-mail-config.el"
                                        aj/recentf-exclude)
                      recentf-max-menu-items 500
                      recentf-max-saved-items 500)
  :config
  (defun aj/recentf-exclude (filename)
    (cl-loop for reg in completion-ignored-extensions
             when
             (string-match-p
              (if (equal "$" (substring reg -1))
                  reg
                (concat reg "$"))
              filename)
             return t))

  (recentf-mode 1))
#+end_src

*** Zeitgeist :ARCHIVE:
#+BEGIN_SRC emacs-lisp
(use-package zeitgeist
  :straight nil
  :load-path "~/kodat/elisp/zeitgeist/"
  :demand t)
#+END_SRC
*** Ignore more files for normal completion
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'latex
  (dolist (ext LaTeX-clean-intermediate-suffixes)
    (add-to-list 'completion-ignored-extensions (replace-regexp-in-string "\\\\" "" ext))))
#+END_SRC
*** Always offer to create new directories for ~read-file-name~
Advises ~read-file-name~ to always ask if non-existent directories should be created. Adding a non-existent directory otherwise causes errors in lots of commands calling ~read-file-name~.

This works for instance in ~dired-do-rename~ or ~mu4e-view-save-attachment~ (also with ~helm-mode~ activated).
#+BEGIN_SRC emacs-lisp
(defun aj/create-non-existent-directories (filename)
  (unless (file-exists-p filename)
    (let ((dirname (file-name-directory filename)))
      (when (and (not (file-directory-p dirname))
                 (y-or-n-p (format "Directory %s doesn't exist, create it?" dirname)))
        (make-directory dirname t))))
  filename)

(advice-add 'read-file-name :filter-return #'aj/create-non-existent-directories)
#+END_SRC

*** Make directories as needed (overlap with above?)
#+begin_src emacs-lisp
(defun aj/ff-mkdir ()
  (let ((filename (buffer-file-name)))
	(unless (or (eq nil filename) (file-exists-p filename))
	  (let ((dir (file-name-directory filename)))
		(unless (file-exists-p dir)
		  (make-directory dir t))))))

(add-hook 'find-file-hook 'aj/ff-mkdir)
(add-hook 'before-save-hook 'aj/ff-mkdir)
#+end_src


*** Auto reverting
#+begin_src emacs-lisp
(global-auto-revert-mode t)
;; Don't update pdfs in process of being built though:
(setq global-auto-revert-ignore-modes '(pdf-view-mode))
;; why ever query if not changed?
(setq revert-without-query '(".*"))
;; Also auto refresh dired, but be quiet about it
(setq global-auto-revert-non-file-buffers t)
(setq auto-revert-verbose nil)
;; I’m always on a reasonable system
(setq auto-revert-use-notify t)
#+end_src

A function for reverting all opened files, even remote files (because auto-revert doesn’t work there)
#+begin_src emacs-lisp
(defun aj/revert-all-buffers ()
  "Refreshes all open buffers from their respective files."
  (interactive)
  (dolist (buf (buffer-list))
	(with-current-buffer buf
	  (when (and (buffer-file-name) (not (buffer-modified-p)))
		(revert-buffer t t t) )))
  (message "Refreshed open files."))
#+end_src

** Password-store
Customizations for ~password-store~ and ~pass-mode.~
In particular, I want good completion when generating a password, so, inspired by the directory-completion in ~helm-find-files~, I define a helm source which lists the password directories and allows completion on them.

I also want a function that places the newly generated password in the kill ring: ~aj/password-store-generate-and-copy.~

Last, a few functions to git push, pull and run ~magit~ on the password store.

#+BEGIN_SRC emacs-lisp
(use-package auth-source-pass
  :after auth-source
  :config (auth-source-pass-enable))

(use-package password-store
  :defer t
  :config (setq password-store-password-length 47)

  (defun aj/password-store-generate (oldfun entry &optional password-length no-symbols)
    (interactive (list (aj/password-store-get-new-entry-with-completion)
                       (when current-prefix-arg
                         (abs (prefix-numeric-value current-prefix-arg)))))
    ;;we get nil when everything is fine, otherwise probably an error
    ;;is signalled
    (unless (apply oldfun entry password-length) entry))

  (advice-add 'password-store-generate :around #'aj/password-store-generate)

  (defun aj/password-store-generate-and-copy ()
    (interactive)
    (password-store-copy
     (call-interactively #'password-store-generate)))

  (defun aj/password-store-generate-and-copy-simpler ()
    (interactive)
    (let ((entry (aj/password-store-get-new-entry-with-completion)))
      (password-store--run-generate entry 19 t t)
      (password-store-copy entry)))

  (defun aj/password-store-get-new-entry-with-completion ()
    (helm
     :prompt: "Password entry:"
     :sources
     (list (helm-build-sync-source "Pass dirs"
             :candidates #'aj/password-store-list-dirs
             :action #'identity
             :persistent-action #'aj/password-helm-complete-persistent)
           (helm-build-dummy-source "Insert"))))

  (defun aj/password-helm-complete-persistent (candidate)
    (with-selected-window (or (active-minibuffer-window)
                              (minibuffer-window))
      (delete-minibuffer-contents)
      (set-text-properties 0 (length candidate)
                           nil candidate)
      (insert candidate)))

  (defun aj/password-store-list-dirs (&optional subdir)
    "List password entries under SUBDIR."
    (unless subdir (setq subdir ""))
    (let ((dir (f-join (password-store-dir) subdir)))
      (when (f-directory-p dir)
        (-reject
         (lambda (d) (string-match-p "\\(/\\.\\|^\\.\\)" d))
         (mapcar (lambda (f) (file-name-as-directory (password-store--file-to-entry f)))
                 (f-directories dir nil t))))))
  )

(use-package pass
  :defer t
  :config
  (bind-keys :map pass-mode-map
             ("P" . aj/pass-git-push)
             ("F" . aj/pass-git-pull)
             ("m" . aj/pass-magit)
             ("W" . aj/password-store-generate-and-copy)
             ("V" . aj/password-store-generate-and-copy-simpler))

  (defun aj/pass-git-push ()
    (interactive)
    (password-store--run-git "push"))
  (defun aj/pass-git-pull ()
    (interactive)
    (password-store--run-git "pull"))
  (defun aj/pass-magit ()
    (interactive)
    (magit-status "~/.password-store"))

  (defun aj/pass-display-header-extra ()
    (pass--display-keybindings '((aj/password-store-generate-and-copy . "Generate and copy")
                                 (aj/password-store-generate-and-copy-simpler . "Generate and copy simpler")))
    (insert "\n")
    (pass--display-keybindings '((aj/pass-git-push . "Git push")
                                 (aj/pass-git-pull . "Git pull")
                                 (aj/pass-magit . "Launch magit")))
    (newline)
    (newline))

  (advice-add 'pass-display-header :after #'aj/pass-display-header-extra)
  )





#+END_SRC
** LaTeX
*** Config variables for latex :org_async:
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'tex
  (setq TeX-process-asynchronous t
        TeX-auto-save t
        TeX-parse-self t ;parse on load
        TeX-auto-save t ;parse on save
        TeX-auto-local ".auctex-auto" ; more sensible directory name
        TeX-style-local ".auctex-auto"
        TeX-auto-private '("~/.emacs.d/auctex/.auctex-auto")
        LaTeX-babel-hyphen nil ; Disable language-specific hyphen insertion.
        LaTeX-clean-intermediate-suffixes
        '("\\.aux" "\\.bbl" "\\.blg" "\\.brf" "\\.fot" "\\.glo" "\\.gls" "\\.idx" "\\.ilg" "\\.ind" "\\.lof"  "\\.lot" "\\.nav" "\\.out" "\\.snm" "\\.toc" "\\.url" "\\.synctex\\.gz" "\\.run\\.xml" "\\.bcf" "\\.fdb_latexmk" "\\.upa" "\\.fls" "\\.lox" "\\.log")
        LaTeX-clean-output-suffixes '("\\.dvi" "\\.pdf" "\\.ps" "\\.xdv" "\\.pdfpc")
        LaTeX-csquotes-close-quote "}"
        LaTeX-csquotes-open-quote "\\enquote{"
        TeX-arg-cite-note-p t
        TeX-fold-auto nil
        TeX-fold-macro-spec-list
        '(("[f]"
           ("footnote" "marginpar"))
          ("[n:{1}]"
           ("fxnote" "fxwarning" "fxerror" "fxfatal"))
          ("[nr: {1}]"
           ("fxrnote" "fxrwarning" "fxrerror" "fxrfatal"))
          ("[nri: {1}]"
           ("fxrnoteinline" "fxrwarninginline" "fxrerrorinline" "fxrfatalinline"))
          ("[c]"
           ("cite"))
          ("[l]"
           ("label"))
          ("[r]"
           ("ref" "pageref" "eqref"))
          ("[i]"
           ("index" "glossary"))
          ("[1]:||*"
           ("item"))
          ("…"
           ("dotsppp"))
          ("(C)"
           ("copyright"))
          ("(R)"
           ("textregistered"))
          ("TM"
           ("texttrademark"))
          (1
           ("part" "subparagraph" "part*" "subparagraph*" "emph" "textit" "textsl" "textmd" "textrm" "textsf" "texttt" "textbf" "textsc" "textup"))
          ("C. {1}"
           ("chapter" "chapter*"))
          ("S. {1}"
           ("section" "section*"))
          ("SS. {1}"
           ("subsection" "subsection*"))
          ("SSS. {1}"
           ("subsubsection" "subsubsection*"))
          ("━━━━━━━━━━━━━━━━{1}"
           ("paragraph" "paragraph*"))
          ("({1}:[1])"
           ("autocite" "autocite*"))
          ("[A: {1}]"
           ("citeauthor" "citeauthor*"))
          ("[T: {1}]"
           ("citetitle" "citetitle*"))
          ((lambda
             (&rest ci)
             (setq ret nil)
             (concat "("
                     (substring
                      (dolist
                          (cc ci ret)
                        (setq ret
                              (concat ret cc ", ")))
                      0 -2)
                     ")"))
           ("autocites" "autocites*"))
          ("»{2}«"
           ("foreigntextquote" "foreignquote"))
          ("»{1}«"
           ("textquote" "enquote"))
          ("―»{3}« ({2}:[1])―"
           ("foreignblockcquote"))
          ("»{3}« ({2}:[1])[2]"
           ("foreigntextcquote"))
          ("―»{2}« ({1}:[1])―"
           ("blockcquote"))
          ("»{2}« ({1}:[1])[2]"
           ("textcquote"))
          ("[…][{1}]||[…]"
           ("textelp"))
          ("[{1}][…]||[…]"
           ("textelp*"))
          ("[{1}]"
           ("textins" "textins*"))
          ("{2}"
           ("foreignlanguage")))
        TeX-macro-private '("~/texmf/tex/" "~/texmf/bibtex/bst/" "~/.texmf-config/tex/")
        TeX-modes '(texinfo-mode latex-mode doctex-mode)
        TeX-quote-language-alist '(("swedish" "\\enquote{" "}" nil))
        TeX-style-private '("~/.emacs.d/auctex/.auctex-style")
        bibtex-dialect 'biblatex
        cdlatex-command-alist
        '(("bra" "Insert bra, place point inside" "\\bra{?}" cdlatex-position-cursor nil nil t)
          ("ket" "Insert ket, place point inside" "\\ket{?}" cdlatex-position-cursor nil nil t)
          ("braket" "Insert bracket, point inside" "\\braket{?}" cdlatex-position-cursor nil nil t))
        cdlatex-math-symbol-alist '((43 ("\\cup" "\\dagger")))
        flyspell-tex-command-regexp
        "\\(\\(begin\\|end\\)[ 	]*{\\|\\(cite[a-z*]*\\|label\\|ref\\|eqref\\|input\\|usepackage\\|documentclass\\)[ 	]*\\(\\[[^]]*\\]\\)?{[^{}]*\\)"
        font-latex-math-environments
        '("display" "displaymath" "equation" "eqnarray" "gather" "multline" "align" "alignat" "xalignat" "dmath")
        font-latex-user-keyword-classes
        '(("fxnote"
           (("fxnote" "[{")
            ("fxrnote" "{"))
           font-lock-comment-face command)
          ("fxwarningerrorfatal"
           (("fxfatal" "[{")
            ("fxerror" "[{")
            ("fxwarning" "[{")
            ("fxrfatal" "{")
            ("fxrerror" "{")
            ("fxrwarning" "{"))
           font-latex-warning-face command)
          ("autocites"
           (("autocites" "[[{[[{")
            ("autocites" "[[{[[{[[{")
            ("autocites" "[[{[[{[[{[[{")
            ("autocites" "[[{[[{[[{[[{[[{"))
           font-lock-constant-face command))
        reftex-bibliography-commands '("bibliography" "nobibliography" "addbibresource")))

(setq-default TeX-master 'dwim
              TeX-PDF-mode t) ;PDF by default


;; replacing \\par with a non-displaying character is just stupid
(with-eval-after-load "tex-mode"
  (setq tex--prettify-symbols-alist (delete '("\\par" . ?  
) tex--prettify-symbols-alist)))
#+END_SRC

*** Use pdf-tools
#+BEGIN_SRC emacs-lisp
(defun th/pdf-view-revert-buffer-maybe (file)
  (when-let ((buf (find-buffer-visiting file)))
    (with-current-buffer buf
      (when (derived-mode-p 'pdf-view-mode)
        (pdf-view-revert-buffer t t)))))

(with-eval-after-load 'tex-buf
  ;; only care about pdf
  (setq TeX-view-program-selection '((output-pdf "PDF Tools")))
  (add-hook 'TeX-after-compilation-finished-functions
            #'th/pdf-view-revert-buffer-maybe))


;; (with-eval-after-load 'pdf-sync
;;   (defun aj/locate-synctex-file (pdffile)
;;     (let ((default-directory
;;             (concat (file-name-directory pdffile) "/.tex-aux"))
;;           (basename (file-name-sans-extension
;;                      (file-name-nondirectory pdffile))))
;;       (cl-labels ((file-if-exists-p (file)
;;                                     (and (file-exists-p file)
;;                                          file)))
;;         (or (file-if-exists-p
;;              (expand-file-name (concat basename ".synctex.gz")))
;;             (file-if-exists-p
;;              (expand-file-name (concat basename ".synctex")))
;;             ;; Some pdftex quote the basename.
;;             (file-if-exists-p
;;              (expand-file-name (concat "\"" basename "\"" ".synctex.gz")))
;;             (file-if-exists-p
;;              (expand-file-name (concat "\"" basename "\"" ".synctex")))))))

;;   (add-hook 'pdf-sync-locate-synctex-file-functions #'aj/locate-synctex-file))
#+END_SRC
*** Open pdf in emacsclient in async mode :org_async:no_default_tangle:
DONE?:
skriva wrapper/alternativ funktion till TeX-pdf-tools-sync-view, som tar ett filnamn och sedan binder den så att TeX-pdf-tools-sync-view ser den, alt gör motsvarande saker. Denna funktion ska köras i normala emacsclient.

Filnamnet måste skickas med till "processen" emacsclient, hur inline en emacsvariabel i ett emacs-process-call?

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'tex
  (setq TeX-view-program-list
        '(("emacsclient pdft"
           "emacsclient -e \"(progn (pop-to-buffer (or (find-buffer-visiting \\\"%o\\\") (find-file-noselect \\\"%o\\\"))) (revert-buffer) (alert \\\"Latexmk klar\\\" :title \\\"Org export latexmk\\\" :style 'libnotify))\"")))
  (setq TeX-view-program-selection '((output-pdf "emacsclient pdft"))))
#+END_SRC

*** Extra latex bindings
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'latex
  (bind-keys
   :map LaTeX-mode-map
   ("C-c ä" . TeX-next-error)
   ("C-c w" . latex-word-count)
   ("C-<f1>" . TeX-doc)
   ("C-c C-a" . TeX-command-two-paragraphs)))
#+END_SRC

*** Extra latex commands
**** latex word count
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'latex
  (defun latex-word-count (&optional arg)
    (interactive "P")
    (let*
        ((this-file (buffer-file-name))
         (this-dir default-directory)
         (enc-str (symbol-name buffer-file-coding-system))
         (enc-opt
          (cond
           ((string-match "utf-8" enc-str) "-utf8")
           ((string-match "latin" enc-str) "-latin1")
           ("-encoding=guess")
           )))
      (if arg
          ;; (shell-command (concat "texcount" " -inc" " -v2 " "-opt=$HOME/.texcount "
          ;;                         enc-opt " \"" this-file
          ;; "\""))
          (let ((tcb (generate-new-buffer "*texcount*")))
            (call-process "texcount" nil tcb nil "-inc"
                          "-v2 " (concat "-opt=" (getenv "HOME") "/.texcount") enc-opt this-file)
            (pop-to-buffer tcb)
            (ansi-color-apply-on-region (point-min) (point-max)))
        (message
         (with-output-to-string
           (with-current-buffer standard-output
             (cd this-dir) ;för att inkluderade filer ska läsas rätt
             (call-process "texcount" nil t nil "-total" "-0" "-inc"
                           "-opt=~/.texcount" enc-opt this-file))))))))
#+END_SRC

**** tex-command-two-paragraphs
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'latex
  (defun TeX-command-two-paragraphs ()
    "Mark two sentences backward and run TeX-command-region, useful for exporting the latest text"
    (interactive)
    (save-excursion
      (mark-paragraph -2)
      (TeX-command-region))))
#+END_SRC

*** Extra modes to enable for latex-mode
#+BEGIN_SRC emacs-lisp
(dolist (mode '(turn-on-reftex
                latex-extra-mode
                TeX-fold-mode))
  (add-hook 'LaTeX-mode-hook mode))
#+END_SRC

*** Latexmk-command for normal export
#+BEGIN_SRC emacs-lisp
(declare-function TeX-run-TeX "tex-buf")
(with-eval-after-load 'tex-buf
  (defun aj/TeX-run-latexmk (name command file)
    (interactive)
    (let ((TeX-save-query nil))
      (TeX-save-document "")
      (TeX-run-TeX name command file)))

  (setq TeX-error-overview-open-after-TeX-run t))
#+END_SRC
*** Latexmk-commands for org-async export :org_async:no_default_tangle:
#+BEGIN_SRC emacs-lisp
(declare-function TeX-run-TeX "tex-buf") (defvar TeX-command-buffer nil)
(with-eval-after-load 'tex-buf
  (defun aj/TeX-run-latexmk (name command file)
    (interactive)
    (let ((TeX-save-query nil)
          (TeX-process-asynchronous nil))
      (TeX-save-document "")
      (TeX-run-TeX name command file)
      (with-current-buffer TeX-command-buffer (TeX-view)))))
#+END_SRC
*** Customize Tex-commands :org_async:
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'tex-buf
  (setq LaTeX-command-style '(("" "%(PDF)%(latex) -file-line-error %(extraopts) %S%(PDFout)")))

  (add-to-list 'TeX-command-list '("LaTeX shell-escape" "%`%l --shell-escape %(mode)%' %t" TeX-run-TeX t (latex-mode doctex-mode)))
  (add-to-list 'TeX-command-list '("Nomenclature" "makeindex %s.nlo -s nomencl.ist -o %s.nls" TeX-run-command t t))
  (add-to-list 'TeX-command-list '("cleanmk" "latexmk -c -g -pdf -e '$pdflatex=~s/pdflatex %%O %%S/%l%(mode) %%O %%S/' %s" TeX-run-discard nil t :help "Clean with latexk"))
  (add-to-list 'TeX-command-list '("xelatexmk" "latexmk -g -recorder -xelatex -pv %s" aj/TeX-run-latexmk nil nil :help "Run XeLatexmk on file"))
  (add-to-list 'TeX-command-list '("latexmk" "latexmk -g -pdf -e '$pdflatex=~s/pdflatex %%O %%S/%l%(mode) %%O %%S/' %s" aj/TeX-run-latexmk nil t :help "Run Latexmk on file")))

(setq-default TeX-command-default "latexmk")
#+END_SRC
*** Reftex
Add biblatex formats
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'reftex-vars
  (setq reftex-cite-prompt-optional-args t
        reftex-plug-into-AUCTeX t
        reftex-cite-format
        '((?a . "\\autocite[]{%l}")
          (?\C-a . "\\autocite*[]{%l}")
          (?A . "\\autocites[]{%l}")
          (?t . "\\textcite[]{%l}")
          (?u . "\\citeauthor[]{%l}")
          (?\C-u . "\\citeauthor*{%l}")
          (?\C-t . "\\citetitle[]{%l}")
          (?l . "%l")
          (?\C-l . "[]{%l}") ;for adding more references in an autocites
          (?\C-m . "\\cite[]{%l}")
          (?f . "\\footcite[]{%l}")
          (?p . "\\parencite[]{%l}")
          (?\C-y . "\\citeyear[]{%l}")
          (?n . "\\nocite{%l}"))))
#+END_SRC
*** Tex-fold linebreaks
https://github.com/andersjohansson/tex-fold-linebreaks
#+BEGIN_SRC emacs-lisp
(use-package tex-fold-linebreaks
  :straight (:host gitlab :repo "andersjohansson/tex-fold-linebreaks")
  :commands tex-fold-linebreaks-mode
  :config (setq tex-fold-linebreaks-non-sentence-punctuation-regexp
                "\\([0-9]\\|[[:space:]]\\([[:alpha:]]\\|t\\.ex\\|m\\.fl\\|bl\\|bl\\.a\\|e\\.g\\|i\\.e\\)?\\)$"))
#+END_SRC
** Window management and navigation
*** beginend (redefine beginning and end of buffer in a smart way for special buffers)
#+BEGIN_SRC emacs-lisp
(use-package beginend
  :init (beginend-setup-all)
  :delight beginend-global-mode
  :config (cl-loop for x in beginend-modes do
                   (delight (cdr x) "" 'beginend)))
#+END_SRC
*** Buffer flip :ARCHIVE:
#+begin_src emacs-lisp
(use-package buffer-flip
  :bind ("C-<tab>" . #'buffer-flip)
  :init
  ;; transient keymap used once cycling starts
  (setq buffer-flip-map
        (let ((map (make-sparse-keymap)))
          (define-key map (kbd "C-<tab>")   'buffer-flip-forward) 
          (define-key map (kbd "C-S-<iso-lefttab>") 'buffer-flip-backward)
          (define-key map (kbd "ESC")     'buffer-flip-abort)
          map))
  (setq buffer-flip-skip-patterns helm-boring-buffer-regexp-list)
  (with-eval-after-load "org-keys"
    (bind-key "C-<tab>" nil org-mode-map)))
#+end_src
*** Med iflipb? :ARCHIVE:
#+begin_src emacs-lisp
(setq iflipb-wrap-around t)
(setq iflipb-ignore-buffers helm-boring-buffer-regexp-list)

(bind-key "C-§" #'iflipb-previous-buffer)
(bind-key "C-½" #'iflipb-next-buffer)


(defun aj/switch-to-other-buffer ()
  (interactive)
  (iflipb-next-buffer nil)
  (aj/cycle-buffers/body))

(bind-key "C-x C-b" #'aj/switch-to-other-buffer)

(defhydra aj/cycle-buffers (:color red)
  "Cycle buffers"
  ("n" #'iflipb-next-buffer "Next buffer")
  ("b" #'iflipb-previous-buffer "Previous buffer")
  ("q" nil "Quit"))

(setq iflipb-wrap-around t)
#+end_src
*** Flip buffers with nswbuff :ARCHIVE:
#+begin_src emacs-lisp
(use-package nswbuff)

(setq nswbuff-exclude-buffer-regexps helm-boring-buffer-regexp-list
      nswbuff-start-with-current-centered t
      nswbuff-display-intermediate-buffers t
      nswbuff-status-window-layout 'scroll)

(set-face-attribute 'nswbuff-special-buffers-face nil :foreground nil :inherit 'shadow)
(set-face-attribute 'nswbuff-current-buffer-face nil :foreground nil)
(set-face-attribute 'nswbuff-separator-face nil :foreground nil :inherit 'shadow)


(defun aj/switch-to-other-buffer ()
  (interactive)
  (nswbuff-switch-to-next-buffer)
  (aj/cycle-buffers/body))

(bind-key "C-x C-b" #'aj/switch-to-other-buffer)

(defhydra aj/cycle-buffers (:color red)
  "Cycle buffers"
  ("n" #'nswbuff-switch-to-previous-buffer "Previous buffer")
  ("b" #'nswbuff-switch-to-next-buffer "Next buffer")
  ("q" nil "Quit"))
#+end_src
*** aj/switch-to-buffer
#+BEGIN_SRC emacs-lisp
(defun aj/switch-to-other-buffer ()
  (interactive)
  (switch-to-buffer nil)
  (aj/cycle-buffers/body))

(bind-key "C-x C-b" #'aj/switch-to-other-buffer)

(defhydra aj/cycle-buffers (:color red)
  "Cycle buffers"
  ("n" #'next-buffer "Next buffer")
  ("b" #'previous-buffer "Previous buffer")
  ("q" nil "Quit"))
#+END_SRC
*** Eyebrowse
#+BEGIN_SRC emacs-lisp
(use-package eyebrowse
  :init (setq eyebrowse-keymap-prefix (kbd "C-c C-å"))
  (eyebrowse-mode t))
#+END_SRC
*** Window management variables
#+BEGIN_SRC emacs-lisp
(setq split-width-threshold 140)
#+END_SRC
*** Window management hydra
#+BEGIN_SRC emacs-lisp
(bind-key "C-§" #'hydra-window/body)

(defhydra hydra-window ()
  "
Movement^^     ^Split^           ^Switch^      ^Resize^
_h_ ←         _v_ertical         _r_otate      _2_ X←
_j_ ↓         _x_ horizontal     _t_ranspose   _3_ X↓
_k_ ↑         _z_ undo           _d_ delete      _4_ X↑
_l_ →        _Z_ reset           _0_ delete   _5_ X→
_F_ollow      _1_ only this
_q_ cancel
"
  ("h" windmove-left)
  ("j" windmove-down)
  ("k" windmove-up)
  ("l" windmove-right)
  ("2" hydra-move-splitter-left)
  ("3" hydra-move-splitter-down)
  ("4" hydra-move-splitter-up)
  ("5" hydra-move-splitter-right)
  ("F" follow-mode)
  ("v" (lambda ()
         (interactive)
         (split-window-right)
         (windmove-right)))
  ("x" (lambda ()
         (interactive)
         (split-window-below)
         (windmove-down)))
  ("r" aj/rotate-windows :color blue)
  ("t" transpose-frame)
  ("0" delete-window :color blue)
  ("d" delete-window :color blue)
  ("1" delete-other-windows)
  ("z" (progn
         (winner-undo)
         (setq this-command 'winner-undo)))
  ("Z" winner-redo)
  ("q" nil))

(defun aj/rotate-windows (arg)
  "Rotate your windows; use the prefix argument to rotate the other direction"
  (interactive "P")
  (if (not (> (count-windows) 1))
      (message "You can't rotate a single window!")
    (let* ((rotate-times (if (and (numberp arg) (not (= arg 0))) arg 1))
           (direction (if (or (< rotate-times 0) (equal arg '(4)))
                          'reverse
                        (lambda (x) x)))
           (i 0))
      (while (not (= rotate-times 0))
        (while  (< i (- (count-windows) 1))
          (let* ((w1 (elt (funcall direction (window-list)) i))
                 (w2 (elt (funcall direction (window-list)) (+ i 1)))
                 (b1 (window-buffer w1))
                 (b2 (window-buffer w2))
                 (s1 (window-start w1))
                 (s2 (window-start w2))
                 (p1 (window-point w1))
                 (p2 (window-point w2)))
            (set-window-buffer-start-and-point w1 b2 s2 p2)
            (set-window-buffer-start-and-point w2 b1 s1 p1)
            (setq i (1+ i))))

        (setq i 0
              rotate-times
              (if (< rotate-times 0) (1+ rotate-times) (1- rotate-times)))))))

(use-package windmove
  :commands windmove-find-other-window)

(defun hydra-move-splitter-left (arg)
  "Move window splitter left."
  (interactive "p")
  (if (let ((windmove-wrap-around))
        (windmove-find-other-window 'right))
      (shrink-window-horizontally arg)
    (enlarge-window-horizontally arg)))

(defun hydra-move-splitter-right (arg)
  "Move window splitter right."
  (interactive "p")
  (if (let ((windmove-wrap-around))
        (windmove-find-other-window 'right))
      (enlarge-window-horizontally arg)
    (shrink-window-horizontally arg)))

(defun hydra-move-splitter-up (arg)
  "Move window splitter up."
  (interactive "p")
  (if (let ((windmove-wrap-around))
        (windmove-find-other-window 'up))
      (enlarge-window arg)
    (shrink-window arg)))

(defun hydra-move-splitter-down (arg)
  "Move window splitter down."
  (interactive "p")
  (if (let ((windmove-wrap-around))
        (windmove-find-other-window 'up))
      (shrink-window arg)
    (enlarge-window arg)))
#+END_SRC
*** Transpose-frame
#+BEGIN_SRC emacs-lisp
  (use-package transpose-frame
    :commands (transpose-frame flip-frame flop-frame rotate-frame
                              rotate-frame-clockwise rotate-frame-anti-clockwise))
#+END_SRC
*** swap window buffers by drag and drop
#+BEGIN_SRC emacs-lisp
(defun th/swap-window-buffers-by-dnd (drag-event)
  "Swaps the buffers displayed in the DRAG-EVENT's start and end
window."
  (interactive "e")
  (let ((start-win (cl-caadr drag-event))
        (end-win   (cl-caaddr drag-event)))
    (when (and (windowp start-win)
               (windowp end-win)
               (not (eq start-win end-win))
               (not (memq (minibuffer-window)
                          (list start-win end-win))))
      (let ((bs (window-buffer start-win))
            (be (window-buffer end-win)))
        (unless (eq bs be)
          (set-window-buffer start-win be)
          (set-window-buffer end-win bs))))))

(bind-key "<C-S-drag-mouse-1>" #'th/swap-window-buffers-by-dnd)
#+END_SRC
*** Narrowing
Do everything with ~C-x n~.
http://endlessparentheses.com/emacs-narrow-or-widen-dwim.html
#+BEGIN_SRC emacs-lisp
(put 'narrow-to-region 'disabled nil)

(defun aj/narrow-or-widen-dwim (p)
  "Widen if buffer is narrowed, narrow-dwim otherwise.
Dwim means: region, org-src-block, org-subtree, or defun,
whichever applies first. Narrowing to org-src-block actually
calls `org-edit-src-code'.

With prefix P, don't widen, just narrow even if buffer is
already narrowed."
  (interactive "P")
  (declare (interactive-only))
  (cond ((and (buffer-narrowed-p) (not p)) (widen))
        ((and (boundp 'org-src-mode) org-src-mode (not p))
         (org-edit-src-exit)) ;leave org-src, we don’t narrow
                                        ;automatically there
        ((region-active-p)
         (narrow-to-region (region-beginning) (region-end)))
        ((derived-mode-p 'org-mode)
         ;; `org-edit-src-code' is not a real narrowing command.
         ;; Remove this first conditional if you don't want it.
         (cond ((ignore-errors (org-edit-src-code))
                t)
               ;; (delete-other-windows))
               ((ignore-errors (org-narrow-to-block) t))
               (t (org-narrow-to-subtree))))
        (t (narrow-to-defun))))

(define-key ctl-x-map "n" #'aj/narrow-or-widen-dwim)
(with-eval-after-load 'org-keys
  ;; override three separate C-x n * bindings
  (bind-keys :map org-mode-map
             ("C-x n s" . nil)
             ("C-x n b" . nil)
             ("C-x n e" . nil)
             ("C-x n" . aj/narrow-or-widen-dwim)))
;; (unbind-key "C-x n" org-mode-map)

;; For leaving org-src-edit, use C-c C-c, like magit-commit etc.
(with-eval-after-load 'org-src
  (define-key org-src-mode-map "\C-c\C-c" #'org-edit-src-exit))

(defun aj/narrow-clone ()
  (interactive)
  (unless (and (boundp 'org-src-mode) org-src-mode)
    (if-let ((bb (buffer-base-buffer)))
        (progn
          (kill-buffer)
          (pop-to-buffer bb))
      (clone-indirect-buffer nil t)
      (aj/narrow-or-widen-dwim nil))))

(define-key ctl-x-map "N" #'aj/narrow-clone)
#+END_SRC

** Searching, file-management, completion (helm and others)
*** Anzu: Shows number of search matches in modeline, replacements inline etc.
#+BEGIN_SRC emacs-lisp
(use-package anzu
  :delight
  :defer 12
  :bind (("M-%" . anzu-query-replace)
         ("C-M-%" . anzu-query-replace-regexp))
  :config
  (progn
    (global-anzu-mode +1)
    (dolist (f '((anzu-mode-line . font-lock-variable-name-face)
                 (anzu-replace-to . match)
                 (anzu-match-1 . font-lock-constant-face)
                 (anzu-match-2 . font-lock-keyword-face)
                 (anzu-match-3 . font-lock-type-face)))
      (set-face-attribute (car f) nil :foreground 'unspecified :background 'unspecified
                          :inherit (cdr f)))))

#+END_SRC

*** Company
#+BEGIN_SRC emacs-lisp
(use-package company
  :defer 3
  :delight ""
  :custom (company-idle-delay 1)
  :config (global-company-mode))

(use-package company-emoji
  :after company
  :config (add-to-list 'company-backends 'company-emoji))

;; see https://github.com/sebastiencs/company-box/pull/65
(use-package company-box
  :straight nil
  :load-path "~/kodat/elisp/company-box"
  :delight ""
  :after company
  :hook (company-mode . company-box-mode)
  :init (setq company-box-enable-icon nil
              company-box-scrollbar 'default))
#+END_SRC

*** COMMENT yasnippet
#+begin_src emacs-lisp
(use-package yasnippet
  :defer 6
  :delight yas-minor-mode ""
  :config
  (yas-global-mode 1) ;välja specifika?
  (define-key yas-minor-mode-map (kbd "<tab>") nil)
  (define-key yas-minor-mode-map (kbd "TAB") nil)
  (add-hook 'yas-before-expand-snippet-hook (lambda () (smartparens-mode -1)))
  (add-hook 'yas-after-exit-snippet-hook (lambda () (smartparens-mode 1))))
#+end_src

*** Hippie expand
#+BEGIN_SRC emacs-lisp
(bind-key "C-å" #'hippie-expand)

;;some kind of default
(setq hippie-expand-try-functions-list
      '(;; yas-hippie-try-expand
        try-complete-file-name
        try-expand-all-abbrevs
        try-expand-dabbrev
        try-expand-dabbrev-all-buffers
        try-expand-dabbrev-from-kill
        try-complete-lisp-symbol-partially
        try-complete-lisp-symbol
        ;; ispell-complete-word
        try-complete-file-name-partially))

(add-hook 'text-mode-hook #'aj/hippie-expand-for-text-mode)
(add-hook 'prog-mode-hook #'aj/hippie-expand-for-prog-mode)
(add-hook 'emacs-lisp-mode-hook #'aj/hippie-expand-for-elisp)

(defun aj/hippie-expand-for-text-mode ()
  (setq-local hippie-expand-try-functions-list
              '(;; yas-hippie-try-expand
                try-expand-all-abbrevs
                try-expand-dabbrev
                try-expand-dabbrev-all-buffers
                try-expand-dabbrev-from-kill
                ;; ispell-complete-word
                try-complete-file-name
                try-complete-file-name-partially
                ;; try-complete-lisp-symbol-partially
                ;; try-complete-lisp-symbol
                )))

(defun aj/hippie-expand-for-prog-mode ()
  (setq-local hippie-expand-try-functions-list
              '(;; yas-hippie-try-expand
                try-complete-file-name
                try-expand-all-abbrevs
                try-expand-list
                try-expand-line
                try-complete-lisp-symbol-partially
                try-complete-lisp-symbol
                try-expand-dabbrev
                try-expand-dabbrev-all-buffers
                try-expand-dabbrev-from-kill
                try-complete-file-name-partially)))

(defun aj/hippie-expand-for-elisp ()
  (setq-local hippie-expand-try-functions-list
              '(;; yas-hippie-try-expand
                try-complete-lisp-symbol-partially
                try-complete-lisp-symbol
                try-complete-file-name
                try-complete-file-name-partially
                try-expand-all-abbrevs
                try-expand-dabbrev
                try-expand-dabbrev-all-buffers
                try-expand-dabbrev-from-kill
                try-expand-list
                try-expand-line)))
#+END_SRC

** info+ :ARCHIVE: 
#+begin_src emacs-lisp
(use-package info+
  ;; :after info
  :defer t
  :config
  (define-key Info-mode-map [mouse-4] nil)
  (define-key Info-mode-map [mouse-5] nil))
#+end_src

** undo-tree
#+begin_src emacs-lisp
(use-package undo-tree
  :defer 3
  :bind (("C-z" . undo-tree-undo) ("S-C-z" . undo-tree-redo))
  :config (global-undo-tree-mode)
  (setq undo-tree-auto-save-history nil
        undo-tree-visualizer-timestamps t
        undo-tree-visualizer-diff t)
  (defun aj/undo-tree-compress (filename)
    (concat filename ".gz"))
  (advice-add 'undo-tree-make-history-save-file-name :filter-return
              #'aj/undo-tree-compress))
#+end_src

** Version control, git and magit
*** Magit config
#+begin_src emacs-lisp
(use-package magit
  ;; :pin melpa-stable
  :bind ("C-x g" . magit-status)
  :config
  (magit-auto-revert-mode -1) ;; I use global-auto-revert
  (setq magit-diff-refine-hunk t
        magit-bury-buffer-function #'magit-mode-quit-window)

  (add-hook 'git-commit-setup-hook #'git-commit-turn-on-flyspell)
  (add-hook 'git-commit-setup-hook
            (lambda () (setq fill-column 70)
              (ispell-change-dictionary "en_GB,sv_SE"))
            t))
#+end_src
*** magit-todos
#+begin_src emacs-lisp
(use-package magit-todos
  :after magit
  :commands magit-todos-mode
  :config (magit-todos-mode t))
#+end_src
*** Display tracked files
Sometimes I want to see what is tracked in a repository.
Define this as a global minor mode which adds a section in the magit status buffer (global because it seemed buggy to modify local value of ~magit-status-sections-hook~).  Inspired by magit-todos mode definition.

~j t~ (default magit binding) jumps to the section of tracked files.
#+begin_src emacs-lisp
(define-minor-mode magit-tracked-files-mode
  "Show list of tracked files in magit status buffer"
  nil
  :global t
  (if magit-tracked-files-mode
      (magit-add-section-hook 'magit-status-sections-hook
                              #'magit-insert-tracked-files
                              nil
                              'append)
    (remove-hook 'magit-status-sections-hook #'magit-insert-tracked-files))
  (magit-refresh))
#+end_src
*** forge
#+begin_src emacs-lisp
(use-package forge
  :after magit)
#+end_src
*** Use visual-line-mode in magit for repositories with mostly prose text
#+BEGIN_SRC emacs-lisp
(defvar-local aj/magit-visual-line-mode nil
  "Enable visual-line-mode for magit if non-nil.")
(put 'aj/magit-visual-line-mode 'safe-local-variable #'booleanp)

(add-hook 'magit-mode-hook #'aj/magit-maybe-enable-visual-line-mode)
(defun aj/magit-maybe-enable-visual-line-mode ()
  "Enables ‘visual-line-mode’ for repositories with mostly prose."
  (when aj/magit-visual-line-mode
    (visual-line-mode)))
#+END_SRC

*** Dired display of untracked git files
#+BEGIN_SRC emacs-lisp
(defvar-local aj/dired-untracked-filter nil)
(put 'aj/dired-untracked-filter 'safe-local-variable #'stringp)

(defun aj/dired-untracked ()
  "List untracked git files with dired"
  (interactive)
  (switch-to-buffer (get-buffer-create "*untracked*"))
  (let ((dired-mode-hook
         (remq 'dired-collapse-mode dired-mode-hook))
        (filter (if aj/dired-untracked-filter
                    (concat "| grep -ve \"" aj/dired-untracked-filter "\" ")
                  "")))
    (shell-command (concat "git ls-files --others " filter "| xargs ls -lL")
                   (current-buffer))
    (dired-mode)
    (setq-local dired-subdir-alist
                (list (cons default-directory (point-min-marker))))))

#+END_SRC

*** git-timemachine
#+begin_src emacs-lisp
(use-package git-timemachine)
#+end_src
** visible-bookmarks (bm)
#+begin_src emacs-lisp
(use-package bm
  :defer 2
  :init (setq bm-restore-repository-on-load t)

  :bind (("<C-f5>" . bm-toggle)
         ("<f5>" . bm-next)
         ("<S-f5>" . bm-previous)
         ("<left-fringe> <mouse-5>" . bm-next-mouse)
         ("<left-fringe> <mouse-4>" . bm-previous-mouse)
         ("<left-fringe> <mouse-1>" . bm-toggle-mouse))
  :config
  (setq-default bm-buffer-persistence t)
  (setq bm-highlight-style 'bm-highlight-only-fringe
        bm-fringe-face 'gnus-summary-selected
        bm-fringe-persistent-face 'query-replace)
  (add-hook' after-init-hook 'bm-repository-load)
  (add-hook 'find-file-hooks 'bm-buffer-restore)
  (add-hook 'kill-buffer-hook 'bm-buffer-save)
  (add-hook 'kill-emacs-hook (lambda nil (bm-buffer-save-all) (bm-repository-save)))
  (add-hook 'after-save-hook 'bm-buffer-save)
  (add-hook 'after-revert-hook 'bm-buffer-restore))
#+end_src

** uniquify
#+begin_src emacs-lisp
(use-package uniquify
  :straight nil
  :demand t
  :config (setq uniquify-buffer-name-style 'post-forward-angle-brackets
                uniquify-after-kill-buffer-p t ; rename after killing uniquified
                uniquify-ignore-buffers-re "^\\*") ; ignore special buffers
  )
#+end_src

** New (custom) utility commands
#+begin_src emacs-lisp
(use-package aj-custom-commands
  :straight (aj-custom-commands :repo "/home/aj/kodat/elisp/aj-custom-commands/" :host nil)
  :defer t
  :bind (("C-x C-k" . aj/delete-current-buffer-file)
         ("C-x C-r" . aj/rename-current-buffer-file)
         ("C-S-<return>" . ergoemacs-open-in-external-app)
         ("C-c m" . aj/message-peek))
  :init (bind-key "C-a" 'aj/beginning-or-indentation prog-mode-map)
  (with-eval-after-load "dired"
    (bind-key "<s-return>" #'aj/sudo-edit dired-mode-map)))
#+end_src

** Editing. Marking, killing, yanking, etc.
*** Whole-line-or-region
#+BEGIN_SRC emacs-lisp
(use-package whole-line-or-region
  :demand t
  :config (whole-line-or-region-global-mode)
  :delight whole-line-or-region-local-mode)
#+END_SRC
*** Volatile-highlight
Highlights previously changed (yanked, undone, etc.) with a temporary highlight.
#+BEGIN_SRC emacs-lisp
(use-package volatile-highlights
  :delight
  :commands volatile-highlights-mode
  :init (volatile-highlights-mode t)
  :config
  (with-eval-after-load 'undo-tree
    (vhl/define-extension 'undo-tree 'undo-tree-yank 'undo-tree-move)
    (vhl/install-extension 'undo-tree))
  (vhl/define-extension 'abbrev 'expand-abbrev)
  (vhl/install-extension 'abbrev)
  (vhl/define-extension 'helm-yank 'helm-kill-ring-action-yank)
  (vhl/install-extension 'helm-yank)
  (vhl/define-extension 'flyspell-prev 'flyspell-auto-correct-previous-word)
  (vhl/install-extension 'flyspell-prev)

  (defun aj/vhl-face (&optional theme)
    (when (aj/solarized-theme-p theme)
      (set-face-attribute 'vhl/default-face nil :background nil :foreground nil :inherit 'flycheck-info)))

  (aj/vhl-face)
  (add-hook 'aj/face-definitions-hook #'aj/vhl-face))
#+END_SRC
*** [[https://github.com/rejeep/drag-stuff.el][Drag stuff]] :ARCHIVE:
#+BEGIN_SRC emacs-lisp
(use-package drag-stuff
  :delight drag-stuff-mode
  :config
  (defhydra aj/hydra-drag-stuff (:color pink)
    "Drag stuff"
    ("f" drag-stuff-right)
    ("b" drag-stuff-left)
    ("p" drag-stuff-up)
    ("n" drag-stuff-down)
    ("q" nil nil))
  (bind-key [f9] #'aj/hydra-drag-stuff/body))
#+END_SRC
*** Save interprogram-paste, so it won’t be overwritten by kills done in emacs and is instead kept in the kill ring.
#+BEGIN_SRC emacs-lisp
(setq save-interprogram-paste-before-kill t)
#+END_SRC
*** expand-region
#+begin_src emacs-lisp
(use-package expand-region
  :bind ("C-ä" . er/expand-region))
#+end_src

*** Join line to following is my favourite command
#+begin_src emacs-lisp
(bind-key "M-j" #'aj/join-following)  ;; no use for comment-indent-new-line
(defun aj/join-following ()
  (interactive)
  (join-line -1))
#+end_src

*** cycle-spacing
#+begin_src emacs-lisp
(global-set-key (kbd "S-SPC") 'cycle-spacing)
#+end_src

*** hungry-delete                                                   :ARCHIVE:
Deleting a whitespace character deletes all whitespace up till non ws
#+begin_src emacs-lisp
(use-package hungry-delete
  :demand t
  :config (global-hungry-delete-mode))
#+end_src

** Various key binding customizations
*** Kill emacs instead of terminal
I often have more use for killing emacs (including all GUI-windows).
#+BEGIN_SRC emacs-lisp
(global-set-key [remap save-buffers-kill-terminal] #'save-buffers-kill-emacs)
#+END_SRC
*** No shift select
#+BEGIN_SRC emacs-lisp
(setq shift-select-mode nil)
#+END_SRC
*** Rectangle mark-mode hydra
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x SPC") 'hydra-rectangle/body)

(defhydra hydra-rectangle (:body-pre (rectangle-mark-mode 1)
                                     :color pink
                                     :post (deactivate-mark))
  "
    ^_k_^     _d_elete    _s_tring
  _h_   _l_   _q_uit      _y_ank
    ^_j_^     _n_ew-copy  _r_eset
  ^^^^        _e_xchange  _u_ndo
  ^^^^        ^ ^         _p_aste
  "
  ("h" backward-char nil)
  ("l" forward-char nil)
  ("k" previous-line nil)
  ("j" next-line nil)
  ("e" hydra-ex-point-mark nil)
  ("n" copy-rectangle-as-kill nil)
  ("d" delete-rectangle nil)
  ("r" (if (region-active-p)
           (deactivate-mark)
         (rectangle-mark-mode 1)) nil)
  ("y" yank-rectangle nil)
  ("u" undo nil)
  ("s" string-rectangle nil)
  ("p" kill-rectangle nil)
  ("q" nil nil))

(defvar rectangle-mark-mode)
(defun hydra-ex-point-mark ()
  "Exchange point and mark."
  (interactive)
  (if rectangle-mark-mode
      (exchange-point-and-mark)
    (let ((mk (mark)))
      (rectangle-mark-mode 1)
      (goto-char mk))))
#+END_SRC

*** Reasonable binding (~C-'~) for ~other-window~, define backwards command as well.
(But I never seem to remember this, my fingers are stuck with ~C-x o~)
#+BEGIN_SRC emacs-lisp
(bind-key "C-'" #'other-window)
(with-eval-after-load 'org
  (unbind-key "C-'" org-mode-map))

(defun aj/back-window ()
  (interactive)
  (other-window -1))
(bind-key "C-x O" #'aj/back-window)
(bind-key "C-*" #'aj/back-window)
#+END_SRC

*** Kill this buffer instead of kill-buffer
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x k") #'aj/kill-this-buffer)
(global-set-key (kbd "C-x K") #'kill-buffer-and-window)


(defun aj/kill-this-buffer ()
  "Kill the current buffer.
When called in the minibuffer, get out of the minibuffer using
`abort-recursive-edit'."
  (interactive)
  (if (minibufferp)
      (abort-recursive-edit)
    (kill-buffer (current-buffer))))
#+END_SRC
*** count-words instead of count-words-region
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-=") #'count-words)
#+END_SRC
*** Emacs-which-key
#+BEGIN_SRC emacs-lisp
(use-package which-key
  :delight
  :defer 4
  :config (which-key-setup-side-window-right-bottom)
  (which-key-mode)
  (setq which-key-paging-prefixes '("C-x"))
  (setq which-key-paging-key "<f2>"))
#+END_SRC
*** Hydra for launch
#+BEGIN_SRC emacs-lisp
(defhydra aj/hydra-launch (:color blue)
  "Launch"
  ("z" aj/helm-open-zoterofile "Öppna zoterofil")
  ;;("c" calc "calc")
  ("d" ediff-buffers "ediff buffers")
  ;;("f" 'find-dired "")
  ;;("g" 'lgrep)
  ;;("G" 'rgrep)
  ;;("h" 'man) ; Help
  ("l" list-processes "List processes")
  ("p" paradox-list-packages "paradox")
  ("e" eshell "eshell")
  ("t" proced "proced") ; top
  ("q" nil "quit"))

(bind-key "C-x L" #'aj/hydra-launch/body)
#+END_SRC
*** Hydra for toggle
#+BEGIN_SRC emacs-lisp
(defvar whitespace-mode nil)
(defhydra hydra-toggle (:color pink)
  "
_a_ abbrev-mode:       %`abbrev-mode
_d_ debug-on-error:    %`debug-on-error
_f_ auto-fill-mode:    %`auto-fill-function
_t_ truncate-lines:    %`truncate-lines
_w_ whitespace-mode:   %`whitespace-mode
_v_ variable-pitch:
"
  ("a" abbrev-mode nil)
  ("d" toggle-debug-on-error nil)
  ("f" auto-fill-mode nil)
  ("t" toggle-truncate-lines nil)
  ("w" whitespace-mode nil)
  ("v" variable-pitch-mode nil)
  ("q" nil "quit"))
;; Recommended binding:
(bind-key "C-x t" 'hydra-toggle/body)

;; Here, using e.g. "_a_" translates to "a" with proper face.
;; More interestingly:
;;
;;     "foobar %`abbrev-mode" means roughly (format "foobar %S" abbrev-mode)
;;
;; This means that you actually see the state of the mode that you're changing.
#+END_SRC
*** Mark-paragraph, backward-kill-word
#+begin_src emacs-lisp
(global-set-key (kbd "M-?") 'mark-paragraph)
(global-set-key (kbd "M-h") 'backward-kill-word)
#+end_src

*** Text-scale (zoom), and variable-pitch
#+begin_src emacs-lisp
;;Free the keys for it
(bind-keys ("C-x =" . balance-windows)
           ("C-x )" . what-cursor-position))

(defhydra hydra-zoom (global-map "C-x +")
  "zoom"
  ("+" text-scale-increase "in")
  ("-" text-scale-decrease "out")
  ("´" variable-pitch-mode "variable-pitch")
  ("0" (text-scale-increase 0) "reset"))

;; also zoom with C-scroll (like in Firefox)
(bind-key "<C-down-mouse-4>" #'text-scale-increase)
(bind-key "<C-down-mouse-5>" #'text-scale-decrease)
#+end_src

** Movement
*** ~C-S-a~ as back-to-indentation
#+begin_src emacs-lisp
(bind-key "C-S-a" 'back-to-indentation)
#+end_src

*** Up and down for line scrolling, C-n, C-p for moving cursor.
#+begin_src emacs-lisp
(global-set-key [up]  #'scroll-down-line)
(global-set-key [down] #'scroll-up-line)
#+end_src

*** Forward-word med bara whitespace som word-boundary
#+begin_src emacs-lisp
(defun aj/forward-word-ws ()
  (interactive)
  (forward-whitespace 1)
  (forward-whitespace -1))
(defun aj/backward-word-ws ()
  (interactive)
  (forward-whitespace -1)
  (forward-whitespace 1))

(global-set-key (kbd "C-c f") 'aj/forward-word-ws)
(global-set-key (kbd "C-c b") 'aj/backward-word-ws)
#+end_src


*** Scrolling
#+begin_src emacs-lisp
(setq scroll-conservatively 10000
      scroll-margin 3
      next-screen-context-lines 3
      scroll-error-top-bottom t
      scroll-preserve-screen-position 'in-place)
#+end_src

** Mixed stuff
This could perhaps be sorted better.
*** Don’t kill scratch-buffer
#+BEGIN_SRC emacs-lisp
(defun aj/unkillable-scratch-buffer ()
  (if (equal (buffer-name (current-buffer)) "*scratch*")
      (progn
        (erase-buffer)
        (bury-buffer)
        nil)
    t))
(add-hook 'kill-buffer-query-functions 'aj/unkillable-scratch-buffer)
#+END_SRC

*** Print to pdf
#+begin_src emacs-lisp
(defun aj/print-to-pdf (filename)
  (interactive "F")
  (ps-spool-buffer-with-faces)
  (switch-to-buffer "*PostScript*")
  (write-file "/tmp/tmp.ps")
  (kill-buffer "tmp.ps")
  (let ((cmd (format "ps2pdf14 /tmp/tmp.ps \"%s\"" filename )))
    (shell-command cmd)
    (shell-command "rm /tmp/tmp.ps")
    (message (concat "Saved to:  " filename))))

#+end_src

*** No pictures for speedbar
#+begin_src emacs-lisp
(setq speedbar-use-images nil)
#+end_src

*** Trash can be good
#+begin_src emacs-lisp
(setq delete-by-moving-to-trash t)

(defun aj/dired-do-delete-no-trash (&optional arg)
  "Delete without trashing all marked (or next ARG) files.
`dired-recursive-deletes' controls whether deletion of
non-empty directories is allowed."
  (interactive "P")
  (dired-internal-do-deletions
   ;; this may move point if ARG is an integer
   (nreverse
    (dired-map-over-marks (cons (dired-get-filename) (point))
                          arg))
   arg nil))

(eval-after-load 'dired
  '(progn
	 (define-key dired-mode-map (kbd "ä") 'aj/dired-do-delete-no-trash)
	 (define-key dired-mode-map (kbd "ö") 'aj/dired-do-last-mod-rename)))

(defun aj/visit-trash ()
  "Visit trash with dired, with `delete-by-moving-to-trash' set to nil."
  (interactive)
  (dired (concat (or (getenv "XDG_DATA_HOME") "~/.local/share") "/Trash/files"))
  (setq-local delete-by-moving-to-trash nil))

(defun aj/dired-restore-from-trash (&optional arg)
  "Restore marked (or next ARG) files in dired from Trash.

Only works with XDG trash dir."
  (interactive "P")
  (let* ((xdg-data-dir ;; these variables copied from ‘move-file-to-trash’
          (directory-file-name
           (expand-file-name "Trash"
                             (or (getenv "XDG_DATA_HOME")
                                 "~/.local/share"))))
         (trash-files-dir (expand-file-name "files" xdg-data-dir))
         (trash-info-dir (expand-file-name "info" xdg-data-dir)))

    (cl-loop for file in (dired-map-over-marks (dired-get-filename) arg)
             if (string-prefix-p trash-files-dir file) do
             (if-let ((trashinfo (expand-file-name
                                  (concat (file-name-nondirectory file)
                                          ".trashinfo")
                                  trash-info-dir))
                      (restorepath (with-temp-buffer
                                     (save-match-data
                                       (insert-file-contents trashinfo)
                                       (when (search-forward-regexp "^Path=\\(.+\\)$")
                                         (decode-coding-string
                                          (url-unhex-string (match-string 1))
                                          'utf-8 t)
                                         )))))
                 (when (y-or-n-p
                        (format "Restore %s → %s" (file-name-nondirectory file) restorepath))
                   (dired-rename-file file restorepath t)
                   (delete-file trashinfo))
               (user-error "Couldn’t find path to restore to."))
             else do (user-error "Can only restore files in trash dir"))))

(defun aj/dired-trash-remove (&optional arg)
  "Remove marked (or next ARG) files from trash using the trash-rm program."
  (interactive "P")
  (cl-loop for file in (dired-map-over-marks (dired-get-filename) arg) do
           (shell-command (format "trash-rm %s" (file-name-nondirectory file)))
           (dired-remove-file file)))
#+END_SRC

*** Fix ediff locale
ediff expects diff to return results in C-locale, I’ve made a wrapper script
(it’s: ~LANG=C diff "$1" "$2"~) to solve this.
#+begin_src emacs-lisp
(setq ediff-diff-program "aj-diff-no-locale")
#+end_src


*** y-or-n instead of yes-or-no
#+begin_src emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+end_src

*** Source my ~.bash_env~.
Needed when starting in a non-interactive shell.
#+begin_src emacs-lisp
(setenv "BASH_ENV" "~/.bash_env")
#+end_src

*** backup-files :org_async:
#+begin_src emacs-lisp
(setq delete-old-versions t
	  kept-new-versions 6
	  kept-old-versions 2
	  version-control t)
#+end_src

** prog-modes

*** Highlight todos (hl-todo)
#+begin_src emacs-lisp
(use-package hl-todo
  :commands global-hl-todo-mode
  :defer 10
  :config (global-hl-todo-mode t))
#+end_src

*** eldoc
#+BEGIN_SRC emacs-lisp
(global-eldoc-mode t)
#+END_SRC

*** Some settings for whitespace and ediff
#+BEGIN_SRC emacs-lisp
(setq whitespace-style '(face trailing lines-tail tabs)
      whitespace-line-column 80
      ediff-window-setup-function 'ediff-setup-windows-plain)
#+END_SRC
*** paren-face
Dims parantheses in lisp modes.
#+BEGIN_SRC emacs-lisp
(use-package paren-face
  :init (global-paren-face-mode))
#+END_SRC
*** Elisp
**** Some settings from ESK
#+begin_src emacs-lisp
(add-hook 'emacs-lisp-mode-hook 'aj/remove-elc-on-save)

(defun aj/remove-elc-on-save ()
  "If you're saving an elisp file, likely the .elc is no longer valid."
  (add-hook 'after-save-hook
            (lambda ()
              (if (file-exists-p (concat buffer-file-name "c"))
                  (delete-file (concat buffer-file-name "c"))))
            nil t))

(define-key read-expression-map (kbd "TAB") #'completion-at-point)
(define-key lisp-mode-shared-map (kbd "RET") 'reindent-then-newline-and-indent)
#+end_src
**** Elisp-slime-nav
#+BEGIN_SRC emacs-lisp
(use-package elisp-slime-nav
  :init (add-hook 'emacs-lisp-mode-hook #'elisp-slime-nav-mode)
  :config
  (defun aj/find-elisp-thing-at-point-other-window (sym-name)
    "Find the elisp thing at point, be it a function, variable, library or face. Display in other window.

With a prefix arg, or if there is no thing at point, prompt for
the symbol to jump to.

Argument SYM-NAME is the thing to find."
    (interactive (list (elisp-slime-nav--read-symbol-at-point)))
    (when sym-name
      (let ((sym (intern sym-name)))
        (message "Searching for %s..." sym-name)
        (if (fboundp 'xref-push-marker-stack)
            (xref-push-marker-stack)
          (with-no-warnings
            (ring-insert find-tag-marker-ring (point-marker))))
        (cond
         ((fboundp sym)
          (find-function-do-it sym nil #'switch-to-buffer-other-window))
         ((boundp sym)
          (find-function-do-it sym 'defvar #'switch-to-buffer-other-window))
         ((or (featurep sym) (locate-library sym-name))
          (find-library sym-name)) ;; explicitly calls switch-to-buffer
         ((facep sym)
          (find-function-do-it sym 'defface #'switch-to-buffer-other-window))
         (t
          (pop-tag-mark)
          (error "Don't know how to find '%s'" sym))))))

  (define-key elisp-slime-nav-mode-map (kbd "C-M-.")
    #'aj/find-elisp-thing-at-point-other-window))


#+END_SRC
**** Timestamps
#+BEGIN_SRC emacs-lisp
(defun aj/elisp-timestamps ()
  (setq-local time-stamp-line-limit 10)
  (setq-local time-stamp-start "^;; Modified: ")
  (setq-local time-stamp-end "$")
  (setq-local time-stamp-format "%:y-%02m-%02d")
  (add-hook 'before-save-hook #'time-stamp nil t))

(add-hook 'emacs-lisp-mode-hook #'aj/elisp-timestamps)
#+END_SRC
**** Nameless
#+BEGIN_SRC emacs-lisp
(use-package nameless
  :defer t
  :init (add-hook 'emacs-lisp-mode-hook #'nameless-mode)
  (setq nameless-private-prefix t
        nameless-affect-indentation-and-filling nil))
#+END_SRC
**** Electric-quote-mode
#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-lisp-mode-hook #'electric-quote-local-mode)
(setq electric-quote-context-sensitive t)
#+END_SRC

*** aggressive-indent
#+begin_src emacs-lisp
(use-package aggressive-indent
  :commands aggressive-indent-mode
  :init (add-hook 'prog-mode-hook #'aggressive-indent-mode)
  :config (add-hook 'reb-mode-hook (lambda () (aggressive-indent-mode -1))) ;; meaningless and shadows the important keybinding C-c C-q
  (delight 'aggressive-indent-mode (all-the-icons-faicon "indent" :v-adjust 0.02) t))
#+end_src



*** Outline
**** Outshine :ARCHIVE:
Could be used better some day, need to define good keybindings and stuff, and then navigation could be very easy.
http://www.modernemacs.com/post/outline-ivy/
#+BEGIN_SRC emacs-lisp
(use-package outshine
  :init
  (add-hook 'outline-minor-mode-hook 'outshine-hook-function)
  :config  (setq outshine-use-speed-commands t))

#+END_SRC
**** outline-magic
Well?
#+BEGIN_SRC emacs-lisp
(use-package outline-magic
  :commands outline-cycle
  :init (with-eval-after-load 'outline
          (bind-key "<C-tab>" 'outline-cycle outline-minor-mode-map)))
#+END_SRC

**** Outline hydra
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'outline
  (defhydra hydra-outline (:color pink :hint nil)
    "
^Hide^             ^Show^           ^Move
^^^^^^------------------------------------------------------
_z_: sublevels     _a_: all         _u_: up
_t_: body          _e_: entry       _n_: next visible
_o_: other         _i_: children    _p_: previous visible
_c_: entry         _k_: branches    _f_: forward same level
_l_: leaves        _s_: subtree     _b_: backward same level
_d_: subtree     _<tab>_: toggle

"
    ;; Hide
    ("z" outline-hide-sublevels)    ; Hide everything but the top-level headings
    ("t" outline-hide-body)         ; Hide everything but headings (all body lines)
    ("o" outline-hide-other)        ; Hide other branches
    ("c" outline-hide-entry)        ; Hide this entry's body
    ("l" outline-hide-leaves)       ; Hide body lines in this entry and sub-entries
    ("d" outline-hide-subtree)      ; Hide everything in this entry and sub-entries
    ;; Show
    ("a" outline-show-all)          ; Show (expand) everything
    ("e" outline-show-entry)        ; Show this heading's body
    ("i" outline-show-children)     ; Show this heading's immediate child sub-headings
    ("k" outline-show-branches)     ; Show all sub-headings under this heading
    ("s" outline-show-subtree)      ; Show (expand) everything in this heading & below
    ("<tab>" outline-cycle)
    ;; Move
    ("u" outline-up-heading)                ; Up
    ("n" outline-next-visible-heading)      ; Next
    ("p" outline-previous-visible-heading)  ; Previous
    ("f" outline-forward-same-level)        ; Forward - same level
    ("b" outline-backward-same-level)       ; Backward - same level
    ("q" nil "leave"))

  (bind-key "C-c #" 'hydra-outline/body outline-minor-mode-map)) ; by example
#+END_SRC

*** Origami folding
#+BEGIN_SRC emacs-lisp
(use-package origami
  :commands origami-mode
  :config (bind-keys :map origami-mode-map
                     ("<tab>" . origami-recursively-toggle-node)
                     ("<backtab>" . origami-toggle-all-nodes))
  (delight 'origami-mode (all-the-icons-octicon "fold") t))
#+END_SRC

*** octave-mode
#+begin_src emacs-lisp
(autoload 'octave-mode "octave" nil t)
(setq auto-mode-alist
      (cons '("\\.m$" . octave-mode) auto-mode-alist))
#+end_src
*** Tabs or spaces
#+begin_src emacs-lisp
(setq-default tab-width 4) ; or any other preferred value
(defvaralias 'c-basic-offset 'tab-width)
(defvaralias 'cperl-indent-level 'tab-width)
(defvaralias 'js-indent-level 'tab-width)

(use-package smart-tabs-mode
  :commands smart-tabs-insinuate
  :init (smart-tabs-insinuate 'c 'c++ 'java 'javascript 'cperl 'python 'ruby 'nxml)
  )

(add-hook 'emacs-lisp-mode-hook
		  (lambda ()
			;; Use spaces, not tabs.
			(setq indent-tabs-mode nil)))
#+end_src

*** smartparens
#+begin_src emacs-lisp
(use-package smartparens
  :init (require 'smartparens-config)
  :config
  (smartparens-global-mode t)
  (add-to-list 'sp-ignore-modes-list 'org-agenda-mode)
  (show-smartparens-global-mode t)
  (sp-use-smartparens-bindings)
  (sp-pair "`" nil :actions :rem) ;den sabbar org-cdlatex-mode m.m.
  (sp-local-pair 'org-mode "\\(" "\\)" :trigger "$$")
  (face-spec-reset-face 'sp-show-pair-match-face)
  (face-spec-reset-face 'sp-show-pair-mismatch-face)
  (set-face-attribute 'sp-show-pair-match-face nil :inherit 'show-paren-match)
  (set-face-attribute 'sp-show-pair-mismatch-face nil :inherit 'show-paren-mismatch)
  (define-key smartparens-mode-map (kbd "M-<delete>") 'undefined))
;; sista sabbar mitt skrivande, borde bara kopplas till org-mode, men vet inte hur)
#+end_src

*** Comment-dwim-2
To only activate it in prog-mode, we define a minor mode with the binding.
#+begin_src emacs-lisp
(use-package comment-dwim-2
  :init
  (defvar comment-dwim-2-mode-map
    (let ((map (make-sparse-keymap)))
      (define-key map (kbd "C-c C-;") #'comment-dwim-2)
      map))

  (define-minor-mode comment-dwim-2-mode
    "Binds ‘comment-dwim-2’"
    :keymap comment-dwim-2-mode-map)


  (add-hook 'prog-mode-hook #'comment-dwim-2-mode))
#+end_src

*** Minibuffer evaluation
#+BEGIN_SRC emacs-lisp
(add-hook 'eval-expression-minibuffer-setup-hook #'smartparens-mode)
#+END_SRC
*** CPERL
cperl instead of perl-mode
#+begin_src emacs-lisp
(use-package cperl-mode
  :straight nil
  :defer t
  :init (defalias 'perl-mode 'cperl-mode)
  :functions cperl-set-style
  :config (cperl-set-style "GNU")
  (defun aj/cperl-eldoc-documentation-function ()
    "Return meaningful doc string for `eldoc-mode'."
    (car (let ((cperl-message-on-help-error nil))
           (cperl-get-help))))
  (add-hook 'cperl-mode-hook (eldoc-mode))
  (add-hook 'cperl-mode-hook
            (lambda () (set (make-local-variable 'eldoc-documentation-function)
                       'aj/cperl-eldoc-documentation-function))))

;; ;; helm-perldoc:setup takes long time on low power platform
;; (helm-perldoc:setup)
;; (add-hook 'cperl-mode-hook 'helm-perldoc:carton-setup)

#+end_src

*** Notifications while compiling
#+begin_src emacs-lisp
  (autoload 'notifications-notify "notifications")
  (defun aj/compile-notify (buffer message)
    (notifications-notify :title "Emacs kompilering" :body message :urgency "critical"))
  (add-to-list 'compilation-finish-functions 'aj/compile-notify)
#+end_src

*** Prettify
#+BEGIN_SRC emacs-lisp
(global-prettify-symbols-mode t)
(setq prettify-symbols-unprettify-at-point t)
#+END_SRC
*** A few fixes from ESK
#+begin_src emacs-lisp
(defun esk-local-comment-auto-fill ()
  (setq-local comment-auto-fill-only-comments t)
  (auto-fill-mode t))

(add-hook 'prog-mode-hook 'esk-local-comment-auto-fill)
#+end_src
*** Idle-highlight-mode 
#+begin_src emacs-lisp
(use-package idle-highlight-mode
  :hook prog-mode)
#+end_src
** Text-modes and spelling

*** Visual-line-mode
**** Text-mode uses visual-line-mode and visual-fill-column-mode
#+begin_src emacs-lisp
(add-hook 'text-mode-hook 'turn-on-visual-line-mode)

(use-package visual-fill-column
  :init (add-hook 'visual-line-mode-hook #'visual-fill-column-mode)
  :config
  (setq-default visual-fill-column-width 100)
  (setq split-window-preferred-function #'visual-fill-column-split-window-sensibly)
  (advice-add 'text-scale-increase :after #'visual-fill-column-adjust))
#+end_src

**** Define a binding for killing logical line in visual-line-mode, make sure this works also in org-mode, and that org-mode calls org-kill-line even if visual-line-mode is activated
#+begin_src emacs-lisp
;;(with-eval-after-load 'simple
(define-key visual-line-mode-map [remap kill-line] nil)
(bind-keys :map visual-line-mode-map
           ("C-k" . kill-visual-line)
           ("C-S-k" . kill-line))

(with-eval-after-load 'org
  (define-key org-mode-map [remap kill-line] nil)
  (bind-keys :map org-mode-map
             ("C-k" . org-kill-line)
             ("C-S-k" . kill-line))

  ;; Make org-kill-line take priority over kill-visual-line
  (defvar aj/org-visual-line-mode-map (copy-keymap visual-line-mode-map))
  (define-key aj/org-visual-line-mode-map (kbd "C-k") #'org-kill-line)
  (define-key aj/org-visual-line-mode-map  [remap kill-line] nil)
  (define-key aj/org-visual-line-mode-map  (kbd "C-S-k") #'kill-line)

  (defun aj/org-override-visual-line-mode-map ()
    (setq minor-mode-overriding-map-alist
          (list (cons visual-line-mode aj/org-visual-line-mode-map))))

  (add-hook 'org-mode-hook #'aj/org-override-visual-line-mode-map))

#+end_src

*** No, sentences don’t end with double space
That’s a stupid convention from the days of the typewriter (and in Swedish we don’t even use the longer (not double!) spaces after sentences that are good typographic practice in English).
#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
#+END_SRC
*** Fill-paragraph fixes
I generally don’t want hard line breaks in my text-mode paragraphs, so a very wide fill-column allows me to use ~M-q~ to remove all line breaks in a paragraph.

However, sometimes I put every sentence on it’s own line (good for version control) and then it would be good if ~fill-paragraph~ made sure that this was the case instead.

The minor mode defined below takes care of this. I advice ~fill-region-as-paragraph~ which is called by ~org-fill-paragraph~ (which is the most common way for me of invoking it), but perhaps there can be some invocations that are not matched by this. It would probably be cleaner to remap some keys, but this covers many cases in one go.

#+BEGIN_SRC emacs-lisp
(add-hook 'text-mode-hook (lambda () (setq fill-column 99999)))


(define-minor-mode aj/one-sentence-per-line-mode
  "Minor mode that overrides `fill-region-as-paragraph' to
  arrange every sentence on its own line"
  ;; (message "hej")
  ;; (if aj/one-sentence-per-line-mode
  ;;     (font-lock-add-keywords nil aj/missing-eol-period-fl-keywords)
  ;;   (font-lock-remove-keywords nil aj/missing-eol-period-fl-keywords))
  )

;; (defvar aj/missing-eol-period-fl-keywords
;;   '(("^[^#:\\*].+\\(\\b[[:word:]]+[^].?:]\\)$" 1 'font-lock-warning-face prepend)))

(defun aj/one-sentence-fill-override (fun from to &rest args)
  (if aj/one-sentence-per-line-mode
      (aj/one-sentence-per-line-region from to)
    (apply fun from to args)))

(advice-add 'fill-region-as-paragraph :around #'aj/one-sentence-fill-override)

(defun aj/one-sentence-per-line-region (from to)
  "Makes one sentence per line in region"
  (interactive "r")
  (let ((se (sentence-end)))
    (save-excursion
      (goto-char from)
      ;; start by removing all but the last line breaks
      (while (search-forward "\n" (1- to) t)
        (replace-match " " t t))
      (goto-char from)
      ;; has to changed? too much?
      (while (search-forward-regexp se (- to 2) t)
        (replace-match "\n" t nil nil 2)))))


(defun aj/set-org-sentence-end ()
  "Allow sentences to end with an org-bracket-link

I often put `org-annotate' comments after sentences, and these
should be kept together."
  (setq-local
   sentence-end
   (format
    "\\(?9:[.?!…‽][]\"'”’)}]*\\(?8:%s\\)?\\(?2:$\\|[	  ]\\)\\|[。．？！]+\\)[
]*"
    org-bracket-link-regexp)))

(add-hook 'org-mode-hook #'aj/set-org-sentence-end)
#+END_SRC

*** Fix text-mode syntax table and char table for quote symbols
When writing english with contractions using "right single quotation mark", ~’~, it needs to be treated as a word character, similar to how ~'~ is treated in ~text-mode-syntax-table~.

In addition, words made up of characters from different scripts won’t be considered a word by word-movement functions etc. Apperently the curly quote symbols in unicode is in the ~symbol~ script, whereas "ordinary" letters and the straight quotes are ~latin~ (I guess this is for historical reasons). I don’t know if there are any negative effects with putting the curly quotes in ~latin~, but it makes word navigation work. Maybe I should keep the changes to ~’~.

#+BEGIN_SRC emacs-lisp
(modify-syntax-entry ?’ "w" text-mode-syntax-table)
(dolist (c '(?“ ?” ?‘ ?’))
  (set-char-table-range char-script-table c 'latin))
#+END_SRC

*** WC-mode :ARCHIVE:
In some way interacts with the advice in delight.el to ~format-mode-line~ and causes ~wc-mode-count~ to be called even if ~wc-mode~ is not activated.
Disable for now. (I never use it).
 #+begin_src emacs-lisp
(use-package wc-mode
  :commands wc-mode
  :config (setq wc-modeline-format "[W:%tw]"))
#+end_src

*** Abbrev-mode
In the abbrev-file I have defined two tables to use as parents of ~text-mode-abbrev-table~, ~aj/swedish-abbrevs~ and ~aj/english-abbrevs~. They are activated when writing in English or Swedish as defined by the functions below (the ~:enable-function~ of the tables).

I also define abbrevs for english which expand "dont" to "do not" etc. in the table ~aj/formal-english-abbrevs~. This is activated via the minor mode ~aj/formal-english-minor-mode~.

Editing abbrevs with ~edit-abbrevs~ and saving them in the abbrev-file doesn’t seem to preserve properties. Therefore properties are added below (Some of this will be fixed in 27.1).
#+BEGIN_SRC emacs-lisp
(use-package abbrev
  :straight nil
  :delight
  :init
  (add-hook 'text-mode-hook #'abbrev-mode)
  (setq abbrev-file-name "~/.emacs.d/config/abbrev_defs")
  :config
  ;; Define a special abbrev for i->I, use it only when writing non-Swedish
  (require 'ispell)
  (defun aj/make-i-I ()
    (when (or (bound-and-true-p orgqda-transcript-mode)
              (and
               ispell-local-dictionary
               (not (string-match-p "sv" ispell-local-dictionary))))
      (zap-to-char -1 ?i)
      (insert "I")))


  ;; TODO, check use of ispell-local-dictionary, ispell-dictionary, ispell-current-dictionary
  (defun aj/writing-english-p ()
    (if ispell-local-dictionary
        (string-match-p "en" ispell-local-dictionary)
      (and flyspell-mode ispell-dictionary
           (string-match-p "en" ispell-dictionary))))

  (defun aj/writing-swedish-p ()
    (if ispell-local-dictionary
        (string-match-p "sv" ispell-local-dictionary)
      (and flyspell-mode ispell-dictionary
           (string-match-p "sv" ispell-dictionary))))

  (with-eval-after-load abbrev-file-name
    (abbrev-table-put aj/english-abbrevs :enable-function #'aj/writing-english-p)
    (abbrev-table-put aj/swedish-abbrevs :enable-function #'aj/writing-swedish-p)
    (abbrev-table-put text-mode-abbrev-table
                      :parents (list aj/english-abbrevs aj/swedish-abbrevs))
    ;; to add or replace it every time abbrev-file is loaded:
    (setf (alist-get 'aj/formal-english-minor-mode abbrev-minor-mode-table-alist)
          aj/formal-english-abbrevs)))

(define-minor-mode aj/formal-english-minor-mode
  "Minor mode for expanding abbrevs like \"dont\" to \"do not\"."
  :lighter ""
  (if aj/formal-english-minor-mode
      (font-lock-add-keywords nil (aj/formal-english-fl-keywords))
    (font-lock-remove-keywords nil (aj/formal-english-fl-keywords)))
  (font-lock-flush))

(defvar aj/formal-english-highlights
  '("aren't" "aren’t" "can't" "can’t" "couldn't" "couldn’t" "could've" "could’ve" "didn't" "didn’t" "doesn't" "doesn’t" "don't" "don’t" "hadn't" "hadn’t" "hasn't" "hasn’t" "haven't" "haven’t" "i'll" "i’ll" "isn't" "isn’t" "mightn't" "mightn’t" "mustn't" "mustn’t" "shouldn't" "shouldn’t" "should've" "should’ve" "that's" "that’s" "there's" "there’s" "wasn't" "wasn’t" "we're" "we’re" "weren't" "weren’t" "we've" "we’ve" "what's" "what’s" "where's" "where’s" "won't" "won’t" "wouldn't" "wouldn’t" "would've" "would’ve"))

;; could be precomputed but ...
(defun aj/formal-english-fl-keywords ()
  `((,(regexp-opt aj/formal-english-highlights) 0 'hi-pink prepend)))
#+END_SRC

*** Ispell + flyspell
**** Options, define languages, hunspell, etc.
#+begin_src emacs-lisp
(setq-default ispell-program-name "hunspell")

(setq ispell-silently-savep t
      ;; ispell-dictionary "sv_SE"
      )

;; (setq ispell-local-dictionary-alist
;;       '(("en_GB"
;;          "[[:alpha:]]" "[^[:alpha:]]"
;;          "[’'´.0-b:-]" t ("-d" "en_GBz-large")
;;          nil utf-8)
;;         ("en_US"
;;          "[[:alpha:]]" "[^[:alpha:]]"
;;          "[’'´.0-b:-]" t ("-d" "en_US")
;;          nil utf-8)
;;         ("en_GB,sv_SE"
;;          "[[:alpha:]]" "[^[:alpha:]]"
;;          "[’'´.0-b:-]" t ("-d" "en_GBz-large,sv_SE")
;;          nil utf-8)
;;         ("blandat"
;;          "[[:alpha:]]" "[^[:alpha:]]"
;;          "[ø’'´.0-b:-]" t ("-d" "en_GBz-large,sv_SE,da_DK")
;;          nil utf-8)
;;         ("en_US,sv_SE"
;;          "[[:alpha:]]" "[^[:alpha:]]"
;;          "[’'´.0-b:-]" t ("-d" "en_US,sv_SE")
;;          nil utf-8)))

;; (with-eval-after-load 'ispell

;; ispell-set-spellchecker-params has to be called
;; before ispell-hunspell-add-multi-dic will work
;; (ispell-set-spellchecker-params)
;;(ispell-hunspell-add-multi-dic "en_GB,sv_SE")
;;(ispell-hunspell-add-multi-dic "en_US,sv_SE")

;; but I want to have control over all parameters,
;; quoting characters and personal dictionaries.

(add-hook 'ispell-initialize-spellchecker-hook #'aj/extra-dicts)
(defun aj/extra-dicts ()
  (setq ispell-base-dicts-override-alist
        '(("en_GB"
           "[[:alpha:]]" "[^[:alpha:]]"
           "[’'´.0-b:-]" t ("-d" "en_GBz-large")
           nil utf-8)
          ("en_US"
           "[[:alpha:]]" "[^[:alpha:]]"
           "[’'´.0-b:-]" t ("-d" "en_US")
           nil utf-8)
          ("en_GB,sv_SE"
           "[[:alpha:]]" "[^[:alpha:]]"
           "[’'´.0-b:-]" t ("-d" "en_GBz-large,sv_SE")
           nil utf-8)
          ("blandat"
           "[[:alpha:]]" "[^[:alpha:]]"
           "[ø’'´.0-b:-]" t ("-d" "en_GBz-large,sv_SE,da_DK")
           nil utf-8)
          ("en_US,sv_SE"
           "[[:alpha:]]" "[^[:alpha:]]"
           "[’'´.0-b:-]" t ("-d" "en_US,sv_SE")
           nil utf-8))))

#+END_SRC

**** flyspell-hydra and custom commands
#+BEGIN_SRC emacs-lisp
(bind-key "C-c l" 'hydra-flyspell/body)
(defhydra hydra-flyspell (:color blue :hint nil)
  "
^Correct:^    _,_: auto-correct   _c_orrect Current: %(identity ispell-current-dictionary)
^Toggle:^     _l_: turn %(if flyspell-mode \"off\" \"on \") flyspell _L_ toggle+disable, turn: %(if flyspell-mode \"off\" \"on \")
^Languages:^  _s_venska   _b_ritish  _d_: svenska-british _a_: blandat  _u_s english
"
  ("l" flyspell-mode)
  ("L" aj/disable-enable-flyspell-permanently-in-file)
  ("c" ispell-word)
  ("," flyspell-auto-correct-word :color red)
  ("s" (aj/ispell-change-dictionary "sv_SE"))
  ("S" (aj/ispell-change-dictionary-store "sv_SE"))
  ("b" (aj/ispell-change-dictionary "en_GB"))
  ("B" (aj/ispell-change-dictionary-store "en_GB"))
  ("d" (aj/ispell-change-dictionary "en_GB,sv_SE"))
  ("D" (aj/ispell-change-dictionary-store "en_GB,sv_SE"))
  ("a" (aj/ispell-change-dictionary "blandat"))
  ("A" (aj/ispell-change-dictionary-store "blandat"))
  ("u" (aj/ispell-change-dictionary "en_US"))
  ("U" (aj/ispell-change-dictionary-store "en_US"))
  ("q" nil))

(defun aj/ispell-change-dictionary (dict)
  "Change dictionary, enable ‘flyspell-mode’, disable ‘guess-language-mode’"
  (ispell-change-dictionary dict)
  (flyspell-mode)
  (guess-language-mode -1))

(defun aj/disable-enable-flyspell-permanently-in-file ()
  (interactive)
  (save-excursion
    (save-restriction
      (widen)
      (if flyspell-mode
          (progn
            (flyspell-mode -1)
            (guess-language-mode -1)
            (add-file-local-variable 'aj/inhibit-flyspell t))
        (flyspell-mode)
        (goto-char (point-min))
        (when (search-forward "Local Variables" nil t)
          (flush-lines "aj/inhibit-flyspell: t"))))))

(defun aj/ispell-change-dictionary-store (dict)
  (interactive (list (completing-read
                      "Dictionary: "
                      (mapcar #'car ispell-dictionary-alist))))
  (save-excursion
    (aj/ispell-change-dictionary dict)
    (add-file-local-variable 'ispell-local-dictionary dict)))

(advice-add 'ispell-change-dictionary :after #'aj/ispell-change-dictionary-merge-personal)

(defun aj/ispell-change-dictionary-merge-personal (dict &rest args)
  "If this is a combined dictionary (hunspell), merges all
personal dictionaries into a combined personal dictionary."
  (when (and dict
             (string-match "," dict))
    (let* ((filenamefn (apply-partially #'format "~/.hunspell_%s"))
           (dictfiles
            (cons (funcall filenamefn dict)
                  (mapcar filenamefn (split-string dict "," t " ")))))
      (with-temp-buffer
        (dolist (d dictfiles)
          (when (file-readable-p d) (insert-file-contents d)))
        (unless (eq (point-min) (point-max))
          (delete-duplicate-lines (point-min) (point-max))
          (write-file (car dictfiles))))
      ;; should be overridden in `ispell-buffer-local-dict' if we have
      ;; a local variable definition in the buffer
      ;; tvivlar på att detta är rätt kanske:
      ;; (setq-local ispell-local-pdict (car dictfiles))

      ;; eller så borde den avsättas om vi växlat till en icke-mergad.
      )))
#+end_src

**** Guess language, conditional enabling of flyspell and setting of languages for flyspell, typo and langtool.
#+BEGIN_SRC emacs-lisp
(use-package guess-language
  :defer t
  :config
  (setq guess-language-langcodes '((en . ("en_GB" "English"))
                                   (sv . ("sv_SE" "Swedish")))
        guess-language-languages '(en sv)
        guess-language-min-paragraph-length 45)
  (add-to-list 'guess-language-after-detection-functions
               #'aj/set-langtool-language)

  (defun aj/set-langtool-language (lang _beg _end)
    (cl-case lang
      (sv (setq-local langtool-default-language "sv-SE"))
      (en (setq-local langtool-default-language "en-GB"))))

  :delight guess-language-mode)



(defvar aj/flyspell-modes '(org-mode mu4e-compose-mode))
(defvar-local aj/inhibit-flyspell nil)
(put 'aj/inhibit-flyspell 'safe-local-variable #'booleanp)

;; DISABLE AUTO-activation for a while. See if this leads to less
;; multiple ispell-processes bugs.


;; ;; Functions that maybe enables flyspell and guess-language, a second
;; ;; after local variables are read (to ensure ispell language and
;; ;; aj/inhabit-flyspell is set).

;; (add-hook 'hack-local-variables-hook #'aj/maybe-enable-flyspell-and-guess-language)

;; (defun aj/maybe-enable-flyspell-and-guess-language ()
;;   (run-with-idle-timer 1 nil #'aj/maybe-enable-flyspell-and-guess-language-fn (current-buffer)))

;; (defun aj/maybe-enable-flyspell-and-guess-language-fn (buf)
;;   (when (buffer-live-p buf)
;;     (with-current-buffer buf
;;       (when (and (not aj/inhibit-flyspell)
;;                  (member major-mode aj/flyspell-modes))
;;         (flyspell-mode 1)
;;         (aj/set-langtool-language-from-ispell-dict))
;;       (if (or (eq major-mode 'mu4e-compose-mode)
;;               (and flyspell-mode (not ispell-local-dictionary)))
;;           (guess-language-mode 1)
;;         (guess-language-mode -1)))))

;; (defun aj/set-langtool-language-from-ispell-dict ()
;;   (when (and ispell-local-dictionary
;;              (< (length ispell-local-dictionary) 7))
;;     (setq-local langtool-default-language
;;                 (replace-regexp-in-string "\_" "-" ispell-local-dictionary))))
#+END_SRC

**** Extra flyspell bindings
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'flyspell
  (bind-keys :map flyspell-mode-map
             ("C-,"   . flyspell-auto-correct-previous-word)
             ("C-;"   . flyspell-check-previous-highlighted-word)
             ("C-M-," . flyspell-goto-next-error)))
#+END_SRC
**** Helm flyspell, on C-ö
#+BEGIN_SRC emacs-lisp
(use-package helm-flyspell
  :commands helm-flyspell-correct
  :init (with-eval-after-load 'flyspell
          (bind-key "C-ö" 'helm-flyspell-correct flyspell-mode-map)))
#+END_SRC
**** Extra areas to skip in org-mode
#+BEGIN_SRC emacs-lisp
(defun aj/org-flyspell-skip-links (fun)
  (if (memq (face-at-point) '(org-link org-date org-scheduled))
      nil
    (funcall fun)))

(advice-add 'org-mode-flyspell-verify :around #'aj/org-flyspell-skip-links)

#+END_SRC

**** Ispell-multi, keep processes for multiple languages going. :ARCHIVE:

#+begin_src emacs-lisp
(use-package ispell-multi
  :load-path "~/kodat/elisp/ispell-multi"
  :after ispell
  :config (ispell-multi-activate))

#+end_src

**** COMMENT With wcheck :ARCHIVE:
#+BEGIN_SRC emacs-lisp
(setq ispell-really-hunspell t)

(setq  wcheck--timer-idle .1)
(set-face-attribute 'wcheck-default-face nil :underline 'unspecified :inherit 'flyspell-incorrect)

(setq-default
 wcheck-language "English"
 wcheck-language-data
 '(("English"
    (program . "/usr/bin/hunspell")
    (args . ("-l" "-d" "en_US"))
    (action-program . "/usr/bin/hunspell")
    (action-args . ("-a" "-d" "en_US"))
    (action-parser . wcheck-parser-ispell-suggestions))
   ("Swedish"
    (program . "/usr/bin/hunspell")
    (args . ("-l" "-d" "sv_SE"))
    (action-program . "/usr/bin/hunspell")
    (action-args . ( "-m" "-a" "-d" "sv_SE" "-i" "utf-8"))
    (action-parser . wcheck-parser-ispell-suggestions))
   ("sv-en"
    (program "/usr/bin/hunspell")
    (args . ("-l" "-d" "sv_SE,en_GB"))
    (action-program . "/usr/bin/hunspell")
    (action-args . ( "-m" "-a" "-d" "sv_SE,en_GB" "-i" "utf-8"))
    (action-parser . wcheck-parser-ispell-suggestions)))))


;; toggle between Danish and English easily
(let ((langs '("English" "Swedish")))
  (setq lang-ring (make-ring (length langs)))
  (dolist (elem langs) (ring-insert lang-ring elem)))

(defun aj/cycle-ispell-languages ()
  (interactive)
  (let ((lang (ring-ref lang-ring -1)))
	(ring-insert lang-ring lang)
	(wcheck-change-language lang)))

(global-set-key (kbd "C-c l") 'aj/cycle-ispell-languages)
(global-set-key (kbd "C-c L") 'wcheck-mode)


(global-set-key "\M-n" 'wcheck-spelling-suggestions)

#+END_SRC

*** Typo
For doing smart (curly) quotes, mainly in mails since org has it’s own mechanism
#+BEGIN_SRC emacs-lisp
(use-package typo
  :after mu4e
  :config
  (add-to-list 'typo-quotation-marks  '("Swedish" "»" "«" "›" "‹")
               ;; '("Swedish" "”" "”" "’" "’")
               )
  (setq-default typo-language "Swedish")
  (typo-global-mode 1)
  (add-hook 'mu4e-compose-mode-hook #'typo-mode)
  (defun aj/toggle-en-sv-typo ()
    (interactive)
    (setq typo-language
          (if (string= typo-language "English")
              "Swedish"
            "English")))
  (bind-key "C-c C-ö" #'aj/toggle-en-sv-typo mu4e-compose-mode-map))
#+END_SRC

*** [[https://github.com/mhayashi1120/Emacs-langtool][Language tool]]
#+BEGIN_SRC emacs-lisp
(use-package langtool
  :bind (("C-x 4 w" . langtool-check)
         ("C-x 4 W" . langtool-check-done)
         ("C-x 4 l" . langtool-switch-default-language)
         ("C-x 4 4" . langtool-show-message-at-point)
         ("C-x 4 c" . langtool-correct-buffer))
  :config
  (setq langtool-language-tool-jar nil
        langtool-java-classpath
        "/usr/share/java/languagetool/*:/usr/share/languagetool"
        langtool-mother-tongue "sv"
        langtool-disabled-rules '("WHITESPACE_RULE"
                                  "EN_QUOTES")))
#+END_SRC

*** Word lookups (definition, translation, synonyms). Use define-word for online word definitions and SDCV for Webster's dictionary installed locally
My extra libraries can be found at:  https://gitlab.com/andersjohansson/define-word-thesaurus and  https://gitlab.com/andersjohansson/define-word-tyda.

Instructions for getting Webster’s dictionary: http://mbork.pl/2017-01-14_I'm_now_using_the_right_dictionary

#+BEGIN_SRC emacs-lisp
(use-package define-word
  :commands (define-word define-word-at-point))

(use-package define-word-thesaurus
  :straight (:host gitlab
                   :repo "andersjohansson/define-word-thesaurus"
                   :files ("*.el" "*.py"))
  :after define-word)
(use-package define-word-tyda
  :straight (:host gitlab :repo "andersjohansson/define-word-tyda")
  :after define-word)
;; (use-package define-word-synonymer
;;   :load-path "~/kodat/elisp/define-word-tyda/"
;;   :after define-word)
(use-package sdcv-mode
  :straight nil
  :commands 'sdcv-search)
(use-package google-translate
  :commands 'google-translate-smooth-translate
  :init (setq google-translate-translation-directions-alist
              '(("sv" . "en") ("en" . "sv") ("da" . "sv"))))

;; needs wn, installed with aur package wordnet-cli
(use-package synosaurus
  ;; :pin "melpa"
  :commands (synosaurus-lookup synosaurus-choose-and-replace)
  :custom (synosaurus-choose-method 'default) ; this means completing-read, which gives me helm completion
  )

(defhydra hydra-word-lookup
  (:color blue)
  ("w" sdcv-search "in Webster's")
  ("p" define-word-at-point "word at point")
  ("<RET>" define-word "define word")
  ("t" (define-word (read-from-minibuffer "Tyda: " ) 'tyda) "tyda")
  ("T" (define-word-at-point nil 'tyda) "Tyda at point")
  ("c" (define-word (read-from-minibuffer "Synonymer: " ) 'synonymer) "synonymer")
  ("C" (define-word-at-point nil 'synonymer) "Synonymer at point")
  ("s" (define-word (read-from-minibuffer "Thesaurus: " ) 'thesaurus) "Thesaurus")
  ("S" (define-word-at-point nil 'thesaurus) "Thesaurus at point")
  ("a" synosaurus-lookup "synosaurus")
  ("A" synosaurus-choose-and-replace "Synosaurus at point")
  ("g" google-translate-smooth-translate "Google translate"))

(bind-key "C-x l"  #'hydra-word-lookup/body)
#+END_SRC
** Special modes 
*** Spotify
#+begin_src emacs-lisp
(use-package spotify
  :straight (spotify :host github :repo "danielfm/spotify.el" :files ("*.el" "*.py"))
  :defer t
  :custom
  (spotify-transport 'connect)
  (spotify-api-locale "sv_SE")
  (spotify-api-country "SE")
  (spotify-player-status-format " %p %a: %t ")
  (spotify-api-search-limit 100)
  :config
  (setq spotify-player-status-playing-text (all-the-icons-faicon "play-circle" :v-adjust 0.01)
        spotify-player-status-paused-text (all-the-icons-faicon "pause-circle" :v-adjust 0.01)
        spotify-player-status-stopped-text (all-the-icons-faicon "stop-circle" :v-adjust 0.01)))
#+end_src
*** Extra definitions for ~auto-mode-alist~
#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist
             '("\\.\\(timer\\|service\\)\\'" . conf-mode))
#+end_src
*** Pdf-view (pdf-tools)
**** Main settings
pdf-loader handles deferred loading. Then settings are applied after loading pdf-view
#+BEGIN_SRC emacs-lisp
(use-package pdf-tools
  :commands pdf-loader-install ;; TODO (fel?)
  :init (pdf-loader-install))

(with-eval-after-load 'pdf-view
  (defun pdf-view-current-pagelabel (&optional window)
    (nth (1- (pdf-view-current-page window)) (pdf-info-pagelabels)))
  
  (setq-default pdf-view-display-size 'fit-page)
  (add-hook 'pdf-view-mode-hook (lambda () (auto-revert-mode -1) (whole-line-or-region-local-mode -1)))

  (delight 'pdf-view-midnight-minor-mode " ☾" "pdf-misc")
  (defvar aj/pdf-view-midnight-list
    '(("#657b83" . "#fdf6e3")
      ("#333333" . "#fffff8")))
  (setq pdf-view-midnight-colors (car aj/pdf-view-midnight-list))

  (defun aj/pdf-view-midnight-toggle ()
    (interactive)
    (when-let ((ind (cl-position pdf-view-midnight-colors
                                 aj/pdf-view-midnight-list
                                 :test 'equal)))
      (setq pdf-view-midnight-colors
            (nth (mod (1+ ind) (length aj/pdf-view-midnight-list))
                 aj/pdf-view-midnight-list))
      (pdf-view-midnight-minor-mode 1)))

  (defvar aj/pdf-hl-color "#DED1EE")
  (defvar aj/pdf-ul-color "#633D91")
  (defvar aj/pdf-ol-color "#9C2F38")
  (defvar aj/pdf-note-color "#77599C")
  (defvar aj/pdf-hl-note-color "#E0EDD1" "used for highlights with notes")
  (setq pdf-annot-default-text-annotation-properties
        `((icon . "Comment")
          (color . ,aj/pdf-note-color)
          (label . ,user-full-name)
          (popup-is-open . nil)
          ;; (subject . "Comment")
          ))
  (defun aj/pdf-hl (edit) (interactive "P")
         (let ((pdf-annot-activate-created-annotations edit))
           (pdf-annot-add-markup-annotation (pdf-view-active-region t) 'highlight aj/pdf-hl-color)))
  (defun aj/pdf-hl-and-copy (edit) (interactive "P")
         (let ((pdf-annot-activate-created-annotations edit))
           (pdf-annot-add-markup-annotation (pdf-view-active-region) 'highlight aj/pdf-hl-color)
           (pdf-view-kill-ring-save)))
  (defun aj/pdf-ul (edit) (interactive "P")
         (let ((pdf-annot-activate-created-annotations edit))
           (pdf-annot-add-markup-annotation (pdf-view-active-region t) 'underline aj/pdf-ul-color)))
  (defun aj/pdf-ol (edit) (interactive "P")
         (let ((pdf-annot-activate-created-annotations edit))
           (pdf-annot-add-markup-annotation (pdf-view-active-region t) 'strike-out aj/pdf-ol-color)))
  (defun aj/pdf-sq (edit) (interactive "P")
         (let ((pdf-annot-activate-created-annotations edit))
           (pdf-annot-add-markup-annotation (pdf-view-active-region t) 'squiggly aj/pdf-ol-color)))
  (defun aj/pdf-hl-note () (interactive)
         (let ((pdf-annot-activate-created-annotations t))
           (pdf-annot-add-markup-annotation (pdf-view-active-region t) 'highlight aj/pdf-hl-note-color)))
  (defun aj/pdf-text (ev) (interactive "e")
         (let* ((pdf-annot-activate-created-annotations t)
                (posn (if (mouse-event-p ev)
                          (event-start ev)
                        (user-error "Not a mouse event")))
                (pw (posn-window posn)))
           ;;(with-current-buffer (window-buffer (posn-window posn))
           (unless (eq (window-buffer pw) (current-buffer))
             (select-window pw))
           (if (eq 'image (car-safe (posn-object posn)))
               (pdf-annot-add-text-annotation posn "Comment" `((color . ,aj/pdf-note-color)))
             (user-error "Not image?"))))
  (bind-keys
   :map pdf-view-mode-map
   ("s a" . pdf-view-auto-slice-minor-mode)
   ("q" . aj/pdf-quit)
   ("w" . aj/pdf-hl-and-copy)
   ;;("w" . aj/pdf-hl-and-copy)
   ("e" . aj/pdf-ul)
   ("r" . aj/pdf-ol)
   ("t" . aj/pdf-sq)
   ("y" . aj/pdf-hl-note)
   ("W" . (lambda () (interactive) (aj/pdf-hl t)))
   ("E" . (lambda () (interactive) (aj/pdf-ul t)))
   ("R" . (lambda () (interactive) (aj/pdf-ol t)))
   ("T" . (lambda () (interactive) (aj/pdf-sq t)))
   ("<C-S-mouse-1>" . aj/pdf-text))

  (defun aj/pdf-quit ()
    (interactive)
    (cl-case (read-char "Really close pdf? ")
      ((?q ?y) (kill-buffer))))

  ;; advice count-words
  (advice-add 'count-words :before-while #'aj/pdf-count-words)
  (defun aj/pdf-count-words (start end)
    (if (eq major-mode 'pdf-view-mode)
        (progn
          (pdf-view-assert-active-region)
          (let ((txt (pdf-view-active-region-text)))
            (with-temp-buffer
              (insert (car txt))
              (count-words--message "PDF region" (point-min) (point-max))))
          nil)
      t))

  (defun aj/other-window-pdf-next-page (n)
    (interactive "p")
    (when-let ((other-pdf-window
                (or (get-window-with-predicate #'pdf-util-pdf-window-p nil 'thisframe)
                    (get-window-with-predicate #'pdf-util-pdf-window-p nil 'visible))))
      (with-selected-window other-pdf-window
        (with-demoted-errors "%s"
          (pdf-view-next-page n)))))
  (defun aj/other-window-pdf-previous-page (n)
    (interactive "p")
    (aj/other-window-pdf-next-page (- (or n 1))))
  (bind-keys ("M-n" . aj/other-window-pdf-next-page)
             ("M-p" . aj/other-window-pdf-previous-page)))
#+END_SRC

**** pdf-zotxt-quote
Copying from a pdf with correct org-zotxt references and page numbers
https://gitlab.com/andersjohansson/pdf-zotxt-quote
#+BEGIN_SRC emacs-lisp
(use-package pdf-zotxt-quote
  :straight nil
  :load-path ("~/kodat/elisp/pdf-zotxt-quote/" "~/kodat/elisp/zotxt-emacs/")
  :commands pdf-zotxt-quote-mode
  :config
  (setq pdf-zotxt-quote-fill-column 99999)
  (delight 'pdf-zotxt-quote-mode (all-the-icons-material "format_quote" :v-adjust 0) t))
#+END_SRC

** Various display customizations
*** Variable pitch
I want to use variable pitch for most things. But changing the default face to a variable pitch font is not a good idea, since so many tabular modes etc. depend on a monospace font. Setting it for ~prog-mode~, ~text-mode~ and in the modeline is good though.

#+begin_src emacs-lisp
(add-hook 'prog-mode-hook #'variable-pitch-mode)
(add-hook 'text-mode-hook #'variable-pitch-mode)
(set-face-attribute 'mode-line nil :family "Input Sans Condensed")
#+end_src
*** Document font
When editing longer text documents in org mode (or perhaps LaTeX) it’s good to use a nice sans serif like ET Book (https://github.com/edwardtufte/et-book).
This code defines a mode for doing a a local remapping to do that in a buffer.
Heavily inspired by the package ~mixed-pitch~ (https://gitlab.com/jabranham/mixed-pitch).
But also with some inspiration from here: https://lepisma.github.io/2017/10/28/ricing-org-mode/

#+begin_src emacs-lisp
(use-package doc-font
  ;; in /lisp
  :straight nil
  :commands doc-font-mode)

#+end_src
*** Toggle font size
Sometimes I feel the need for a generally bigger font.
#+begin_src emacs-lisp
(defvar aj/orig-font-size nil)

(add-hook 'after-init-hook (lambda () (setq aj/orig-font-size (face-attribute 'default :height))))

(defun aj/toggle-font-size ()
  (interactive)
  (if (= aj/orig-font-size (face-attribute 'default :height))
      (set-face-attribute 'default nil :height 135)
    (set-face-attribute 'default nil :height aj/orig-font-size)))
#+end_src


*** Flash active window :ARCHIVE:
Another way of finding the active buffer, well I don’t use it right now.
https://gist.github.com/anonymous/d87a27cc544cb4dd2bb1
#+BEGIN_SRC emacs-lisp
(bind-key "M-å" 'aj/flash-active-buffer)

(make-face 'aj/flash-active-buffer-face)
(set-face-attribute 'aj/flash-active-buffer-face nil
                    :inherit 'highlight)
(defun aj/flash-active-buffer ()
  (interactive)
  (run-at-time 0.2 nil
               (lambda (remap-cookie)
                 (face-remap-remove-relative remap-cookie))
               (face-remap-add-relative 'default 'flash-active-buffer-face)))
#+END_SRC
*** Beacon :ARCHIVE:
A way of higlighting where you are, don’t use it now.
#+BEGIN_SRC emacs-lisp
(use-package beacon
  :defer 3
  :delight
  :config (setq beacon-blink-duration 0.2
                beacon-blink-delay 0.1
                beacon-size 40
                beacon-color "#93a1a1")
  (dolist (l '(scroll-down-line scroll-up-line))
    (add-to-list 'beacon-dont-blink-commands l))
  (beacon-mode 1))
#+END_SRC
*** Stripe-buffer :ARCHIVE:
#+BEGIN_SRC emacs-lisp
(use-package stripe-buffer
  :config (progn
            (add-hook 'dired-mode-hook 'turn-on-stripe-buffer-mode)
            (add-hook 'org-mode-hook 'turn-on-stripe-table-mode)))
#+END_SRC
*** all the icons
**** Base package
#+BEGIN_SRC emacs-lisp
(use-package all-the-icons)
#+END_SRC

**** All the icons dired
Pretty icons in dired!

Also a hack to make it work with ~dired-subtree~, however this adds double icons when reverting a buffer with inserted subtrees.
#+BEGIN_SRC emacs-lisp
(use-package all-the-icons-dired
  :init (add-hook 'dired-mode-hook #'all-the-icons-dired-mode)
  :delight
  :config
  (add-hook 'dired-subtree-after-insert-hook #'aj/dired-subtree-all-the-icons)

  (defun aj/dired-subtree-all-the-icons ()
    (save-restriction
      (let ((all-the-icons-dired-displayed nil))
        (widen)
        (beginning-of-line)
        (narrow-to-region (point) end) ; works just because
                                        ; dired-subtree uses dynamic binding
        (all-the-icons-dired--display)))))

#+END_SRC
*** Modeline
**** Doom-modeline
#+BEGIN_SRC emacs-lisp
(use-package eldoc-eval)
(use-package doom-modeline
  :defer t
  :hook (after-init . doom-modeline-mode)
  :custom
  (doom-modeline-buffer-file-name-style 'truncate-all)
  (doom-modeline-bar-width (frame-parameter nil 'left-fringe))
  :config
  ;; shorten filenames when the window is narrow
  (defun aj/doom-modeline-shorten-file-name (name)
    (let ((limit (/ (window-text-width) 3)))
      (if (< limit (length name))
          (concat (substring name 0 (1- limit)) " ⋯")
        name)))

  (advice-add 'doom-modeline-update-buffer-file-name :override #'aj/doom-modeline-update-buffer-file-name)
  (add-hook 'window-configuration-change-hook #'doom-modeline-update-buffer-file-name)

  (defun aj/doom-modeline-update-buffer-file-name (&rest _)
    "Update buffer file name in mode-line."
    (setq doom-modeline--buffer-file-name
          (ignore-errors
            (save-match-data
              (if buffer-file-name
                  (aj/doom-modeline-shorten-file-name (doom-modeline-buffer-file-name))
                (propertize (aj/doom-modeline-shorten-file-name (buffer-name))
                            'face (if (doom-modeline--active)
                                      'doom-modeline-buffer-file
                                    'mode-line-inactive)
                            'help-echo "Buffer name
mouse-1: Previous buffer\nmouse-3: Next buffer"
                            'local-map mode-line-buffer-identification-keymap))))))
  ;; pdf pages with pagelabels
  (advice-add 'doom-modeline-update-pdf-pages :override #'aj/doom-modeline-update-pdf-pages)

  (defun aj/doom-modeline-update-pdf-pages ()
    "Update PDF pages. Use pagelabels if available."
    (setq doom-modeline--pdf-pages
          (let* ((cp (eval `(pdf-view-current-page)))
                 (physical (format "%d/%d"
                                   cp
                                   (pdf-cache-number-of-pages)))
                 (currlabel (pdf-view-current-pagelabel)))
            
            (propertize
             (if (equal currlabel (number-to-string cp))
                 (concat " P: " physical " ")
               (concat " P:" currlabel " (" physical ") "))
             'face (if (doom-modeline--active)
                       'mode-line
                     'mode-line-inactive)))))
  )
#+END_SRC

**** Moody :ARCHIVE:
#+BEGIN_SRC emacs-lisp
(use-package moody
  :config
  (setq x-underline-at-descent-line t)
  (setq moody-mode-line-height 26)
  ;; (moody-replace-mode-line-buffer-identification)
  ;; (moody-replace-vc-mode)
  :init
  (add-hook 'aj/face-definitions-hook #'aj/modeline-fix)

  (defun aj/modeline-fix (&optional theme)
    (when (aj/solarized-theme-p theme)
      (let ((line (face-attribute 'mode-line :underline)))
        (set-face-attribute 'mode-line          nil :overline line :box nil)
        (set-face-attribute 'mode-line-inactive nil :overline line :underline line :box nil)))))
#+END_SRC

**** [[https://github.com/TheBB/spaceline/][spaceline]] :ARCHIVE:
#+BEGIN_SRC emacs-lisp
(use-package spaceline-config
  :ensure spaceline
  :defer 3
  :config
  (setq spaceline-responsive t)
  (spaceline-helm-mode)
  (spaceline-info-mode)
  ;; (spaceline-emacs-theme)
  )
#+END_SRC

**** Spaceline all the icons :ARCHIVE:
#+BEGIN_SRC emacs-lisp
(use-package spaceline-all-the-icons
  :after spaceline
  :config
  (setq
   spaceline-all-the-icons-flycheck-alternate t
   spaceline-all-the-icons-clock-always-visible nil
   spaceline-all-the-icons-hide-long-buffer-path t
   spaceline-all-the-icons-buffer-path-p t
   spaceline-all-the-icons-highlight-file-name t
   powerline-default-separator nil
   spaceline-all-the-icons-separator-type 'none
   spaceline-all-the-icons-minor-modes-p t)

  (solarized-with-color-variables 'light
    (setq spaceline-all-the-icons-file-name-highlight base1))

  ;; Better conditions
  (put 'spaceline-all-the-icons-time-p :when
       '(or spaceline-all-the-icons-clock-always-visible
            (eq 'fullboth (frame-parameter nil 'fullscreen))))
  (put 'spaceline-all-the-icons-battery-status-p :when
       '(and active (bound-and-true-p fancy-battery-mode)
             (eq 'fullboth (frame-parameter nil 'fullscreen))))


  (put 'spaceline-all-the-icons-region-info-p :when
       '(and mark-active (not (eq major-mode 'pdf-view-mode))))
  ;; support pdf
  (spaceline-define-segment all-the-icons-position-aj
    "An `all-the-icons' Line & Column indicator"
    (propertize (if (eq major-mode 'pdf-view-mode)
                    (spaceline--pdfview-page-number)
                  (format-mode-line "%l:%2c"))

                'face `(:height ,(spaceline-all-the-icons--height 0.9) :inherit)
                'display '(raise 0.1))
    :tight t
    :priority -0.5)

  ;; shorten long buffer names:
  (spaceline-define-segment all-the-icons-buffer-id-aj
    "An `all-the-icons' segment to display current buffer id"
    (let* ((height (if spaceline-all-the-icons-slim-render 1.0 0.8))
           (raise  (if spaceline-all-the-icons-slim-render 0.1 0.2))

           (help-echo (format "Major-mode: `%s'" major-mode))

           (file-face `(:height ,(spaceline-all-the-icons--height height)))
           (show-path? (and active
                            spaceline-all-the-icons-buffer-path-p
                            (spaceline-all-the-icons--buffer-path)
                            (not spaceline-all-the-icons-slim-render)))

           (have-projectile? (and (fboundp 'projectile-project-p) (projectile-project-p)))
           (show-projectile? (and spaceline-all-the-icons-projectile-p have-projectile?))

           (buffer-id (if (and (buffer-file-name)
                               (or show-path? show-projectile?))
                          (file-name-nondirectory (buffer-file-name))
                        (format-mode-line "%b")))
           (limit (/ (window-text-width) 5))
           (buffer-id (if (< limit (length buffer-id))
                          (concat (substring buffer-id 0 (1- limit)) " ⋯")
                        buffer-id))

           (mouse-f (if have-projectile? 'projectile-find-file 'find-file)))

      (if (not (and spaceline-all-the-icons-highlight-file-name
                    show-path?))
          (add-to-list 'file-face :inherit t)
        (setq file-face (append `(:background ,(spaceline-all-the-icons--face-background default-face)) file-face))
        (setq file-face (append `(:foreground ,(or spaceline-all-the-icons-file-name-highlight
                                                   (spaceline-all-the-icons--face-background highlight-face))) file-face)))

      (propertize buffer-id
                  'face file-face
                  'display `(raise ,raise)
                  'help-echo help-echo
                  'mouse-face (spaceline-all-the-icons--highlight)
                  'local-map (make-mode-line-mouse-map 'mouse-1 mouse-f)))
    :tight t)


  ;; (spaceline-define-segment aj/all-the-icons-mode-icon
  ;;   "An `all-the-icons' segment indicating the current buffer's mode with an icon"
  ;;   (let ((icon (all-the-icons-icon-for-mode major-mode)))
  ;;     (unless (symbolp icon)
  ;;       (propertize icon
  ;;                   'help-echo (format "Major-mode: `%s'" major-mode)
  ;;                   'display '(raise 0)
  ;;                   'face `(:height ,(spaceline-all-the-icons--height 1.0)
  ;;                                   ,@(get-text-property 0 'face icon)
  ;;                                   ;; :inherit (powerline-active1)
  ;;                                   )))))


  (defun aj/spaceline-all-the-icons-theme (&rest additional-segments)
    "Install the `spaceline-ml-all-the-icons'.
Add ADDITIONAL-SEGMENTS to the end of the theme."
    (interactive)
    (spaceline-compile
      "all-the-icons"
      '((all-the-icons-anzu
         :face mode-line
         :skip-alternate t)

        ((all-the-icons-modified
          all-the-icons-bookmark
          all-the-icons-dedicated
          all-the-icons-window-number
          all-the-icons-eyebrowse-workspace
          all-the-icons-buffer-size) :face highlight-face :skip-alternate t)

        ;; all-the-icons-separator-left-active-1

        (all-the-icons-mode-icon
         ((all-the-icons-buffer-path
           all-the-icons-buffer-id-aj) :separator ""))

        ;; all-the-icons-separator-left-extra-2

        ;; all-the-icons-separator-left-extra-1
        ;; all-the-icons-separator-left-inactive

        (all-the-icons-minor-modes :separator " " :priority -0.1)

        ((all-the-icons-vc-icon
          all-the-icons-vc-status
          all-the-icons-git-ahead
          all-the-icons-git-status
          all-the-icons-flycheck-status
          all-the-icons-package-updates)
         ;; :face other-face
         :separator (spaceline-all-the-icons--separator
                     spaceline-all-the-icons-secondary-separator " ")
         :priority 0.5)

        (((all-the-icons-position-aj :priority -1)
          ((all-the-icons-process
            all-the-icons-region-info
            all-the-icons-text-scale)
           :priority 0.0)
          (all-the-icons-narrowed :priority -1))
         :separator (spaceline-all-the-icons--separator
                     spaceline-all-the-icons-primary-separator " "))

        ;; all-the-icons-separator-left-extra-2
        ;; all-the-icons-separator-left-inactive
        ;; all-the-icons-separator-right-active-1

        ((all-the-icons-which-function)
         :separator ""))

      ;; right
      `((spaceline-mu4e-alert-segment :when active :priority 1)
        (global :when active :priority 1)


        ((((org-pomodoro
            (all-the-icons-org-clock-current-task
             :global-override 'org-mode-line-string))
           :priority -0.7)
          all-the-icons-battery-status
          all-the-icons-time)
         :separator " " ;; (spaceline-all-the-icons--separator spaceline-all-the-icons-primary-separator " ")
         ;; :face default-face
         :when active
         :priority 0)))
    (setq-default mode-line-format spaceline-all-the-icons-theme))

  (aj/spaceline-all-the-icons-theme)

  (spaceline-all-the-icons--setup-anzu)
  (spaceline-toggle-all-the-icons-narrowed-on)
  )
#+END_SRC
***** Weather :ARCHIVE:
#+BEGIN_SRC emacs-lisp
(use-package yahoo-weather
  :after spaceline-all-the-icons
  :config (yahoo-weather-mode))
#+END_SRC

**** Remove or shorten more minor-mode lighters
#+begin_src emacs-lisp
(delight `((undo-tree-mode "" undo-tree)
           (eldoc-mode "" eldoc)
           (auto-revert-mode ,(all-the-icons-material "restore_page" :v-adjust -0.15) autorevert)
           (smartparens-mode "" smartparens)
           (elisp-slime-nav-mode "" elisp-slime-nav)
           (auto-dim-other-buffers-mode "" auto-dim-other-buffers)
           (flyspell-mode ,(all-the-icons-material "spellcheck") flyspell)
           (org-cdlatex-mode " 𝛀" org)
           (visual-line-mode "" simple)
           (auto-fill-function ,(all-the-icons-material "wrap_text" :v-adjust -0.15) simple)
           (buffer-face-mode "" face-remap)
           (org-indent-mode "" org-indent)
           (hi-lock-mode ,(all-the-icons-material "format_color_text" :v-adjust -0.1) hi-lock)
           (org-src-mode "" org-src)
           (magit-auto-revert-mode "" magit)
           (outline-minor-mode ,(all-the-icons-octicon "list-unordered" :v-adjust 0.1) outline)))

;; (delight 'emacs-lisp-mode " Elisp" :major)
#+end_src
*** Themes
**** My own face definitions
Load my own face customizations after enabling a theme.
#+BEGIN_SRC emacs-lisp

;; Would it be possible to do it as a custom theme that is enabled
;; after other themes? It would be cleaner (disableable).
;; But it is tricky, to get the evaluation logic (is solarized
;; loaded?) working as well as the hook. It could be modifications of
;; the var aj/face-defs but we would still need to do dynamic checks
;; of what theme is loaded for some of the faces before calling
;; custom-theme-set-faces with this variable. Much hassle.

;; (deftheme aj/face-definitions
;;   "Extra face definitions to be loaded after other themes")

;; (defvar aj/face-defs
;;   (list
;;    '(org-table ((t :inherit 'fixed-pitch)))
;;    '(org-date ((t :inherit 'fixed-pitch)))))


;; (defun aj/enable-face-definitions (en-theme theme)
;;   (funcall en-theme theme)
;;   (apply #'custom-theme-set-faces
;;          'aj/face-definitions
;;          aj/face-defs)

;;   (funcall en-theme 'aj/face-definitions)

;;   )


(defun aj/apply-face-definitions (&optional theme)
  "Do face definition stuff after loading theme.
Also runs hook aj/face-definitions-hook."
  (unless (eq theme 'user) ;enable theme calls itself with user theme.
    (set-face-attribute 'scroll-bar nil :foreground (face-attribute 'widget-field :background))

    (with-eval-after-load 'org-faces

      (set-face-attribute 'org-meta-line nil :inherit 'org-drawer)

      (set-face-attribute 'org-block-begin-line nil :height 0.9)
      (set-face-attribute 'org-block-end-line nil :height 0.9)
      (set-face-attribute 'org-block nil :height 0.95)

      (set-face-attribute 'org-quote nil :weight 'normal :height 0.95 :inherit 'default)
      (set-face-attribute 'org-verse nil :inherit 'org-table)
      ;; (set-face-attribute 'org-tag nil :weight 'normal :inherit
      ;; 'show-paren-match)

      (set-face-attribute 'org-special-keyword nil :weight 'normal :inherit 'shadow)

      ;; Use fixed-pitch for checkbox, compressed font for table
      (set-face-attribute 'org-checkbox nil :inherit 'fixed-pitch)
      (set-face-attribute 'org-table nil :family "Input Mono Compressed")

      ;; specific for solarized
      ;; level colors in solarized are bad
      (when (aj/solarized-theme-p)
        (solarized-with-color-variables 'dark
                                        (set-face-attribute 'org-level-1 nil :foreground violet)
                                        (set-face-attribute 'org-level-2 nil :foreground blue)
                                        (set-face-attribute 'org-level-3 nil :foreground cyan)
                                        (set-face-attribute 'org-level-4 nil :foreground green)
                                        (set-face-attribute 'org-level-5 nil :foreground yellow)
                                        (set-face-attribute 'org-level-6 nil :foreground orange)
                                        (set-face-attribute 'org-level-7 nil :foreground red)
                                        (set-face-attribute 'org-level-8 nil :foreground magenta))))

    (cond
     ((eq theme 'solarized-light)
      (setq org-n-level-faces 8))
     ((eq theme 'solarized-dark)
      ;; the yellow-red ones are garish contrast-colors to the background
      (setq org-n-level-faces 4)))

    ;; the thing solarized does with mode-line underline is bad.
    ;; (when (member theme '(solarized-dark solarized-light))
    ;;   (set-face-attribute 'mode-line nil :underline nil :overline nil)
    ;;   (set-face-attribute 'mode-line-inactive nil :underline nil :overline nil)
    ;;   (set-face-attribute 'header-line nil :underline nil :overline nil))

    (with-eval-after-load 'idle-highlight-mode
      (set-face-attribute 'idle-highlight nil :inherit nil :underline t))

    ;; Makes text indent kind of correct amount (I use a variable-pitch
    ;; face as standard)
    ;; (with-eval-after-load 'org-indent
    ;;   (set-face-attribute 'org-indent nil :inherit 'org-hide))

    (with-eval-after-load 'org-inlinetask
      (set-face-attribute 'org-inlinetask nil :inherit 'org-level-5))

    (run-hook-with-args 'aj/face-definitions-hook theme)))

(advice-add 'enable-theme :after #'aj/apply-face-definitions)
#+END_SRC
**** Gruvbox
#+BEGIN_SRC emacs-lisp
(use-package autothemer) ;; TODO, fix as dep of gruvbox
(use-package gruvbox
  :straight nil
  :load-path "~/kodat/elisp/gruvbox-theme/"
  :init
  (add-to-list 'custom-theme-load-path "~/kodat/elisp/gruvbox-theme/"))
#+END_SRC

**** Define themes to use for dark and light and load light theme
#+BEGIN_SRC emacs-lisp
(defvar aj/light-theme 'gruvbox-light-hard)
(defvar aj/dark-theme 'gruvbox-dark-medium)

(load-theme aj/light-theme)
#+END_SRC
**** Dark-light-switching
#+BEGIN_SRC emacs-lisp
(defun aj/toggle-light-dark ()
  "Toggles light and dark solarized theme in Emacs and Arc theme in gtk."
  (interactive)
  (cond
   ((custom-theme-enabled-p aj/light-theme)
    (disable-theme aj/light-theme)
    (unless (custom-theme-p aj/dark-theme)
      ;; I seldom use the dark theme, so now is the time to load it
      (load-theme aj/dark-theme t t))
    (enable-theme aj/dark-theme)
    (call-process-shell-command
     "dconf write /org/gnome/desktop/interface/gtk-theme \"'Arc-Dark'\""))
   ((custom-theme-enabled-p aj/dark-theme)
    (disable-theme aj/dark-theme)
    (enable-theme aj/light-theme)
    (call-process-shell-command
     "dconf write /org/gnome/desktop/interface/gtk-theme \"'Arc'\""))
   (t
    (enable-theme 'aj/light-theme))))

(bind-key "S-<f11>" #'aj/toggle-light-dark)
#+END_SRC
**** Base 16 :ARCHIVE:
Works ok... But also here, too bright oranges
Which are nice?
- Dark
  + base16-materia
  + base16-material (similar)
- light
  + mexico-light
  + tomorrow


#+BEGIN_SRC emacs-lisp
(use-package base16-theme
  :config
  (load-theme 'base16-mexico-light t))
#+END_SRC
**** Tomorrow :ARCHIVE:
Is almost good, but it lacks some definitions, and the yellow and orange have bad contrast against white (too bright)
#+BEGIN_SRC emacs-lisp
(use-package color-theme-sanityinc-tomorrow
:init (load-theme 'sanityinc-tomorrow-day))

#+END_SRC
**** bbatsov’s solarized :ARCHIVE:
#+begin_src emacs-lisp
(use-package solarized-theme
  :init
  (setq solarized-scale-org-headlines nil
        solarized-distinct-fringe-background t
        solarized-high-contrast-mode-line nil)
  (load-theme 'solarized-light))
#+end_src
**** sellout’s solarized :ARCHIVE:
I actually liked this more, especially the unified-branch which I used here. But it has kind of stagnated, and has so few definitions.
#+BEGIN_SRC emacs-lisp
(use-package solarized-definitions
  :if (display-graphic-p)
  :load-path "~/kodat/elisp/emacs-color-theme-solarized/"
  :demand t
  :init (add-to-list 'custom-theme-load-path
                     "~/kodat/elisp/emacs-color-theme-solarized/"))
(when (display-graphic-p)
  (setq frame-background-mode 'light)
  (load-theme 'solarized t)
  (mapc 'frame-set-background-mode (frame-list))

  (defun toggle-night-color-theme ()
    "Switch to/from night color scheme."
    (interactive)
    (if (eq frame-background-mode 'dark)
        (progn
          (setq frame-background-mode 'light)
          (setq pdf-view-midnight-colors '("#657b83" . "#fdf6e3")))
      (setq frame-background-mode  'dark)
      (setq pdf-view-midnight-colors '("#839496" . "#002b36" )))

    (load-theme 'solarized)
    (mapc 'frame-set-background-mode (frame-list))
    (powerline-reset)
    (aj/apply-face-definitions))
  (bind-key "<f9>" 'toggle-night-color-theme))
#+END_SRC


*** Hl-line
#+begin_src emacs-lisp
(add-hook 'prog-mode-hook 'hl-line-mode)
;; (use-package hl-line+
;;   :ensure t
;;   :defer 5
;;   :config
;;   (hl-line-toggle-when-idle))
#+end_src

*** Cursor
#+begin_src emacs-lisp
(setq-default cursor-type 'bar)
(setq-default cursor-in-non-selected-windows 'hollow)
(blink-cursor-mode -1)
(setq blink-cursor-alist '((bar . (bar . 1))))

;; (use-package cursor-chg
;;   :defer 5
;;   :init (setq curchg-default-cursor-color (face-attribute 'font-lock-type-face :foreground))
;;   :config
;;   ;; (setq curchg-idle-cursor-type 'box)
;;   ;; (toggle-cursor-type-when-idle -1)
;;   (setq curchg-overwrite/read-only-cursor-type 'box)
;;   (change-cursor-mode 1))
#+end_src

*** Fullscreen toggling
#+begin_src emacs-lisp
(defvar aj/last-fullscreen-param nil)

(defun aj/toggle-fullscreen (&optional f)
  (interactive)
  (let ((current-value (frame-parameter nil 'fullscreen)))
    (set-frame-parameter nil 'fullscreen
                         (if (equal 'fullboth current-value)
                             aj/last-fullscreen-param

                           (setq aj/last-fullscreen-param current-value)
                           ;; (fancy-battery-mode +1)
                           'fullboth))))

;; (autoload 'fancy-battery-mode "fancy-battery")

(bind-key "<f11>" #'aj/toggle-fullscreen)
#+end_src

*** Writeroom
#+BEGIN_SRC emacs-lisp
(use-package writeroom-mode
  :commands writeroom-mode
  :bind ("<f12>" . writeroom-mode)
  :config (setq writeroom-width 80
                writeroom-mode-line t
                writeroom-extra-line-spacing 0.1
                writeroom-global-effects '(writeroom-set-fullscreen)))
#+END_SRC

*** Readable-frame :ARCHIVE:
With some inspiration from here: https://lepisma.github.io/2017/10/28/ricing-org-mode/
Launches a frame with a serif font and writeroom, to read texts in org-mode.
#+BEGIN_SRC emacs-lisp
(use-package reading-frame
  :load-path "~/kodat/elisp/reading-frame/"
  :commands reading-frame-make-frame)
#+END_SRC

*** Colours in shell output
From: http://stackoverflow.com/questions/4726220/how-to-have-colors-in-the-output-of-emacs-shell-command/4729543#4729543
#+begin_src emacs-lisp
(use-package ansi-color
  :commands (ansi-color-apply-on-region ansi-color-make-color-map))

(defadvice display-message-or-buffer (before ansi-color activate)
  "Process ANSI color codes in shell output."
  (let ((buf (ad-get-arg 0)))
    (and (bufferp buf)
         (string= (buffer-name buf) "*Shell Command Output*")
         (with-current-buffer buf
           (ansi-color-apply-on-region (point-min) (point-max))))))
#+end_src


** Special libraries for research :org_async:
*** ajf
Some special functions for managing my data files.
#+begin_src emacs-lisp
(use-package aj-forskning
  :straight nil
  :load-path "~/kodat/elisp/orgqda"
  :defer t)

;;; font-lock () och {}
(with-eval-after-load 'org
  (defvar ajf/font-lock-brackets-keywords
	'(("{[^}]+}" (0 '(face font-lock-type-face) append))
	  ("([^)]+)" (0 '(face font-lock-variable-name-face) append))))

  (defun ajf/font-lock-brackets ()
	(dolist (el ajf/font-lock-brackets-keywords)
	  (add-to-list 'org-font-lock-extra-keywords el t)))

  (add-hook 'org-font-lock-set-keywords-hook #'ajf/font-lock-brackets))
#+end_src

*** mplayer-mode
I use my fork, available here: https://github.com/andersjohansson/mplayer-mode/tree/org-sessions
#+BEGIN_SRC emacs-lisp
  (use-package mplayer-mode
    :straight nil
	:load-path "~/kodat/elisp/mplayer-mode/"
	:defer t
	:config (setq mplayer-display-time-in-modeline nil
				  mplayer-default-seek-step 2))
#+END_SRC

*** orgqda
Available at: https://github.com/andersjohansson/orgqda
#+BEGIN_SRC emacs-lisp
(use-package orgqda-helm-tags
  :straight nil
  :after orgqda
  :config (setq orgqda-helm-tags-include-excluded t))
#+END_SRC

*** orgqda-transcript
Also at: https://github.com/andersjohansson/orgqda
#+BEGIN_SRC emacs-lisp
(use-package orgqda-transcript
  :straight nil
  :load-path "~/kodat/elisp/orgqda"
  :defer t
  :config (setq orgqda-transcript-bind-fn-keys t
                orgqda-transcript-set-up-speaker-keys t
                orgqda-transcript-rebind-c-s-ret t
                orgqda-transcript-rebind-s-ret t)

  (defun aj/q-hydra-pre ()
    (undo-boundary)
    (insert "q"))
  (defhydra aj/q-hydra (:body-pre aj/q-hydra-pre
                                  :color blue
                                  :timeout 1)
    "other: "
    ("y" (progn (zap-to-char -1 ?q) (orgqda-transcript-insert-parenthesis-other-speaker "yeah")) "yeah")
    ("2" (progn (zap-to-char -1 ?q) (orgqda-transcript-insert-parenthesis-other-speaker "yeah yeah")) "yeah yeah")
    ("3" (progn (zap-to-char -1 ?q) (orgqda-transcript-insert-parenthesis-other-speaker "yeah yeah yeah")) "yeah yeah yeah")
    ("4" (progn (zap-to-char -1 ?q) (orgqda-transcript-insert-parenthesis-other-speaker "yeah yeah yeah yeah")) "yeah yeah yeah yeah")
    ("o" (progn (zap-to-char -1 ?q) (orgqda-transcript-insert-parenthesis-other-speaker "ok")) "ok")
    ("i" (progn (zap-to-char -1 ?q) (orgqda-transcript-insert-parenthesis-other-speaker "oh yeah")) "oh yeah")
    ("å" (progn (zap-to-char -1 ?q) (orgqda-transcript-insert-parenthesis-other-speaker "ok yeah")) "ok yeah")
    ("n" (progn (zap-to-char -1 ?q) (orgqda-transcript-insert-parenthesis-other-speaker "mhm")) "mhm")
    ("m" (progn (zap-to-char -1 ?q) (orgqda-transcript-insert-parenthesis-other-speaker "mmm")) "mmm")
    ("l" (progn (zap-to-char -1 ?q) (insert "(laugh)")))
    ("c" (progn (zap-to-char -1 ?q) (insert "[country]")))
    ("C" (progn (zap-to-char -1 ?q) (insert "[city]"))))

  (define-key orgqda-transcript-mode-map "q" #'aj/q-hydra/body)

  ;; (defun aj/say-yeah (&optional arg)
  ;;   (interactive "P")
  ;;   (zap-to-char -1 ?q)
  ;;   (orgqda-transcript-insert-parenthesis-other-speaker
  ;;    (pcase arg
  ;;      ('(4) "yeah yeah")
  ;;      ('(16) "yeah yeah yeah")
  ;;      ((pred integerp) (s-repeat arg "yeah "))
  ;;      (_ "yeah"))))

  (defhydra aj/hydra-mplayer (:color blue)
    ("SPC"     #'mplayer-toggle-pause "pause")
    ("RET"     #'mplayer-toggle-pause-with-rewind "pause rew")
    ("<right>" #'mplayer-seek-forward "forward" :color pink)
    ("<left>"  #'mplayer-seek-backward "backward" :color pink)
    ("f"       #'mplayer-faster "faster" :color pink)
    ("s"       #'mplayer-slower "slower":color pink)
    ("r"       #'mplayer-reset-speed "reset speed")
    ("p"       #'mplayer-seek-position "seek pos")
    ("g"       #'mplayer-seek-timestamp "seek ts")
    ("t"       #'mplayer-insert-position "insert pos")
    ("d"       #'mplayer-toggle-osd "toggle osd")
    ("i"       #'mplayer-insert-timestamp "insert ts")
    ("Q"       #'mplayer-quit-mplayer "Quit mplayer")
    ("q" nil))

  (define-key orgqda-transcript-mode-map (kbd "C-c m") #'aj/hydra-mplayer/body)

  (defvar aj/mplayer-last-seek-f (current-time))
  (defvar aj/mplayer-number-of-seeks-f 0)
  (defvar aj/mplayer-last-seek-b (current-time))
  (defvar aj/mplayer-number-of-seeks-b 0)
  (defvar aj/mplayer-seek-sequence '(0 .9 1.5 2 4))
  (put 'aj/mplayer-seek-sequence 'safe-local-variable
       (lambda (x) (cl-every #'numberp x)))

  (defun aj/mplayer-seek-backward ()
    (interactive)
    (if (and (eq last-command 'aj/mplayer-seek-backward)
             (> 1.0 (float-time (time-subtract (current-time) aj/mplayer-last-seek-b))))
        (cl-incf aj/mplayer-number-of-seeks-b)
      (setq aj/mplayer-number-of-seeks-b 1))
    (mplayer-seek-backward
     (or (nth aj/mplayer-number-of-seeks-b aj/mplayer-seek-sequence) 5))
    (setq aj/mplayer-last-seek-b (current-time)))

  (defun aj/mplayer-seek-forward ()
    (interactive)
    (if (and (eq last-command 'aj/mplayer-seek-forward)
             (> 1.0 (float-time (time-subtract (current-time) aj/mplayer-last-seek-f))))
        (cl-incf aj/mplayer-number-of-seeks-f)
      (setq aj/mplayer-number-of-seeks-f 1))
    (mplayer-seek-forward
     (or (nth aj/mplayer-number-of-seeks-f aj/mplayer-seek-sequence) 5))
    (setq aj/mplayer-last-seek-f (current-time)))

  (bind-key "<f1>" #'aj/mplayer-seek-backward orgqda-transcript-mode-map)
  (bind-key "<f2>" #'aj/mplayer-seek-forward orgqda-transcript-mode-map)

  (bind-key "C-S-a" #'orgqda-transcript-beginning-or-indentation orgqda-transcript-mode-map)
  (bind-key "C-S-e" #'end-of-line orgqda-transcript-mode-map)
  (dolist (key `(("1" . mplayer-toggle-pause-with-rewind)
                 ("2" . mplayer-seek-backward)
                 ("3" . mplayer-seek-forward)))
    (define-key orgqda-transcript-mode-map (car key) (cdr key)))

  (bind-key "C-+" #'aj/repeat-last-words orgqda-transcript-mode-map))
#+END_SRC

** Standard frame parameters
I want my windows to launch at half screen width, to the left. But on my narrow laptop screen probably a little wider (90 chars).
#+begin_src emacs-lisp
(when (display-graphic-p)
  (add-to-list 'default-frame-alist '(top . 0))
  (add-to-list 'default-frame-alist '(left . (+ -9)))
  (add-to-list 'default-frame-alist '(fullscreen . fullheight))
  (add-to-list 'default-frame-alist '(scroll-bar-width . 7))
  
  (defun aj/frame-to-left ()
    (interactive)
    (if (> (x-display-pixel-width) aj/large-screen-min-width)
        (let ((hw (/ (/ (x-display-pixel-width) 2 ) (frame-char-width))))
          (add-to-list 'default-frame-alist (cons 'width hw))
          (set-frame-parameter nil 'width hw))
      (set-frame-parameter nil 'width 90)
      (add-to-list 'default-frame-alist (cons 'width 90)) ;small
      )
    (set-frame-parameter nil 'fullscreen 'fullheight)
    (set-frame-parameter nil 'left 0)
    (set-frame-parameter nil 'top 0))

  (add-hook 'after-init-hook #'aj/frame-to-left))
#+end_src

* Final
** Load custom loaddefs :org_async:ARCHIVE:
#+BEGIN_SRC emacs-lisp
(load-file aj/custom-loaddefs-file)
#+END_SRC
** Local variables for lisp
#+BEGIN_SRC emacs-lisp
;; Local Variables:
;; byte-compile-warnings: '(not free-vars)
;; End:
#+END_SRC

*  Local Variables :ARCHIVE:

# Local Variables:
# eval: (progn (require 'use-package))
# aj/inhibit-flyspell: t
# End:
